/* soapStub.h
   Generated by gSOAP 2.8.58 for webservice.h

gSOAP XML Web services tools
Copyright (C) 2000-2017, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#define SOAP_NAMESPACE_OF_ns1	"http://tempuri.org/"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20858
# error "GSOAP VERSION 20858 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class ns1__ArrayOfAnyType;	/* webservice.h:137 */
class _ns1__DoFunction;	/* webservice.h:140 */
class _ns1__DoFunctionResponse;	/* webservice.h:143 */
class _ns1__UploadTestResult;	/* webservice.h:146 */
class _ns1__UploadTestResultResponse;	/* webservice.h:149 */
class _ns1__CheckSSN;	/* webservice.h:152 */
class _ns1__CheckSSNResponse;	/* webservice.h:155 */
class _ns1__CheckSSN_USCORENEW;	/* webservice.h:158 */
class _ns1__CheckSSN_USCORENEWResponse;	/* webservice.h:161 */
class _ns1__Binding;	/* webservice.h:164 */
class _ns1__BindingResponse;	/* webservice.h:167 */
class _ns1__QueryBinding;	/* webservice.h:170 */
class _ns1__QueryBindingResponse;	/* webservice.h:173 */
class _ns1__SfcTestResult_USCOREUpload;	/* webservice.h:176 */
class _ns1__SfcTestResult_USCOREUploadResponse;	/* webservice.h:179 */
class _ns1__SaveSSN_USCORENEW;	/* webservice.h:182 */
class _ns1__SaveSSN_USCORENEWResponse;	/* webservice.h:185 */
class _ns1__test;	/* webservice.h:188 */
class _ns1__testResponse;	/* webservice.h:191 */
class _ns1__GETMACID;	/* webservice.h:194 */
class _ns1__GETMACIDResponse_GETMACIDResult;	/* webservice.h:727 */
class _ns1__GETMACIDResponse;	/* webservice.h:197 */
class _ns1__GetMacBySn;	/* webservice.h:200 */
class _ns1__GetMacBySnResponse;	/* webservice.h:203 */
class _ns1__CartonWeight_USCOREUpload;	/* webservice.h:206 */
class _ns1__CartonWeight_USCOREUploadResponse;	/* webservice.h:209 */
class _ns1__PCBData_USCOREUpload;	/* webservice.h:212 */
class _ns1__PCBData_USCOREUploadResponse;	/* webservice.h:215 */
class _ns1__GetShaoluKey;	/* webservice.h:218 */
class _ns1__GetShaoluKeyResponse;	/* webservice.h:221 */
class _ns1__ReleaseKey;	/* webservice.h:224 */
class _ns1__ReleaseKeyResponse;	/* webservice.h:227 */
class _ns1__BindKey;	/* webservice.h:230 */
class _ns1__BindKeyResponse;	/* webservice.h:233 */
class _ns1__GetSparrowCheckData;	/* webservice.h:236 */
class _ns1__GetSparrowCheckDataResponse;	/* webservice.h:239 */
class _ns1__BlindKeyNum;	/* webservice.h:242 */
class _ns1__BlindKeyNumResponse;	/* webservice.h:245 */
struct __ns1__DoFunction;	/* webservice.h:1319 */
struct __ns1__UploadTestResult;	/* webservice.h:1389 */
struct __ns1__CheckSSN;	/* webservice.h:1459 */
struct __ns1__CheckSSN_USCORENEW;	/* webservice.h:1529 */
struct __ns1__Binding;	/* webservice.h:1599 */
struct __ns1__QueryBinding;	/* webservice.h:1669 */
struct __ns1__SfcTestResult_USCOREUpload;	/* webservice.h:1739 */
struct __ns1__SaveSSN_USCORENEW;	/* webservice.h:1809 */
struct __ns1__test;	/* webservice.h:1879 */
struct __ns1__GETMACID;	/* webservice.h:1949 */
struct __ns1__GetMacBySn;	/* webservice.h:2019 */
struct __ns1__CartonWeight_USCOREUpload;	/* webservice.h:2089 */
struct __ns1__PCBData_USCOREUpload;	/* webservice.h:2159 */
struct __ns1__GetShaoluKey;	/* webservice.h:2229 */
struct __ns1__ReleaseKey;	/* webservice.h:2299 */
struct __ns1__BindKey;	/* webservice.h:2369 */
struct __ns1__GetSparrowCheckData;	/* webservice.h:2439 */
struct __ns1__BlindKeyNum;	/* webservice.h:2509 */
struct __ns1__DoFunction_;	/* webservice.h:2579 */
struct __ns1__UploadTestResult_;	/* webservice.h:2649 */
struct __ns1__CheckSSN_;	/* webservice.h:2719 */
struct __ns1__CheckSSN_USCORENEW_;	/* webservice.h:2789 */
struct __ns1__Binding_;	/* webservice.h:2859 */
struct __ns1__QueryBinding_;	/* webservice.h:2929 */
struct __ns1__SfcTestResult_USCOREUpload_;	/* webservice.h:2999 */
struct __ns1__SaveSSN_USCORENEW_;	/* webservice.h:3069 */
struct __ns1__test_;	/* webservice.h:3139 */
struct __ns1__GETMACID_;	/* webservice.h:3209 */
struct __ns1__GetMacBySn_;	/* webservice.h:3279 */
struct __ns1__CartonWeight_USCOREUpload_;	/* webservice.h:3349 */
struct __ns1__PCBData_USCOREUpload_;	/* webservice.h:3419 */
struct __ns1__GetShaoluKey_;	/* webservice.h:3489 */
struct __ns1__ReleaseKey_;	/* webservice.h:3559 */
struct __ns1__BindKey_;	/* webservice.h:3629 */
struct __ns1__GetSparrowCheckData_;	/* webservice.h:3699 */
struct __ns1__BlindKeyNum_;	/* webservice.h:3769 */

/* webservice.h:137 */
#ifndef SOAP_TYPE_ns1__ArrayOfAnyType
#define SOAP_TYPE_ns1__ArrayOfAnyType (7)
/* complex XSD type 'ns1:ArrayOfAnyType': */
class SOAP_CMAC ns1__ArrayOfAnyType {
      public:
        /// Sequence of elements 'ns1:anyType' of XSD type 'xsd:anyType' stored in dynamic array anyType of length __sizeanyType
        int __sizeanyType;
        char **anyType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ArrayOfAnyType
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ArrayOfAnyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ArrayOfAnyType, default initialized and not managed by a soap context
        virtual ns1__ArrayOfAnyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ArrayOfAnyType); }
      public:
        /// Constructor with initializations
        ns1__ArrayOfAnyType() : __sizeanyType(), anyType(), soap() { }
        virtual ~ns1__ArrayOfAnyType() { }
        /// Friend allocator used by soap_new_ns1__ArrayOfAnyType(struct soap*, int)
        friend SOAP_FMAC1 ns1__ArrayOfAnyType * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfAnyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:140 */
#ifndef SOAP_TYPE__ns1__DoFunction
#define SOAP_TYPE__ns1__DoFunction (8)
/* complex XSD type 'ns1:DoFunction': */
class SOAP_CMAC _ns1__DoFunction {
      public:
        /// Optional element 'ns1:FunctionName' of XSD type 'xsd:string'
        char *FunctionName;
        /// Optional element 'ns1:objs' of XSD type 'ns1:ArrayOfAnyType'
        ns1__ArrayOfAnyType *objs;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DoFunction
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__DoFunction; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DoFunction, default initialized and not managed by a soap context
        virtual _ns1__DoFunction *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__DoFunction); }
      public:
        /// Constructor with initializations
        _ns1__DoFunction() : FunctionName(), objs(), soap() { }
        virtual ~_ns1__DoFunction() { }
        /// Friend allocator used by soap_new__ns1__DoFunction(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DoFunction * SOAP_FMAC2 soap_instantiate__ns1__DoFunction(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:143 */
#ifndef SOAP_TYPE__ns1__DoFunctionResponse
#define SOAP_TYPE__ns1__DoFunctionResponse (9)
/* complex XSD type 'ns1:DoFunctionResponse': */
class SOAP_CMAC _ns1__DoFunctionResponse {
      public:
        /// Optional element 'ns1:DoFunctionResult' of XSD type 'ns1:ArrayOfAnyType'
        ns1__ArrayOfAnyType *DoFunctionResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DoFunctionResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__DoFunctionResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DoFunctionResponse, default initialized and not managed by a soap context
        virtual _ns1__DoFunctionResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__DoFunctionResponse); }
      public:
        /// Constructor with initializations
        _ns1__DoFunctionResponse() : DoFunctionResult(), soap() { }
        virtual ~_ns1__DoFunctionResponse() { }
        /// Friend allocator used by soap_new__ns1__DoFunctionResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DoFunctionResponse * SOAP_FMAC2 soap_instantiate__ns1__DoFunctionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:146 */
#ifndef SOAP_TYPE__ns1__UploadTestResult
#define SOAP_TYPE__ns1__UploadTestResult (10)
/* complex XSD type 'ns1:UploadTestResult': */
class SOAP_CMAC _ns1__UploadTestResult {
      public:
        /// Optional element 'ns1:objs' of XSD type 'ns1:ArrayOfAnyType'
        ns1__ArrayOfAnyType *objs;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__UploadTestResult
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__UploadTestResult; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__UploadTestResult, default initialized and not managed by a soap context
        virtual _ns1__UploadTestResult *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__UploadTestResult); }
      public:
        /// Constructor with initializations
        _ns1__UploadTestResult() : objs(), soap() { }
        virtual ~_ns1__UploadTestResult() { }
        /// Friend allocator used by soap_new__ns1__UploadTestResult(struct soap*, int)
        friend SOAP_FMAC1 _ns1__UploadTestResult * SOAP_FMAC2 soap_instantiate__ns1__UploadTestResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:149 */
#ifndef SOAP_TYPE__ns1__UploadTestResultResponse
#define SOAP_TYPE__ns1__UploadTestResultResponse (11)
/* complex XSD type 'ns1:UploadTestResultResponse': */
class SOAP_CMAC _ns1__UploadTestResultResponse {
      public:
        /// Optional element 'ns1:UploadTestResultResult' of XSD type 'ns1:ArrayOfAnyType'
        ns1__ArrayOfAnyType *UploadTestResultResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__UploadTestResultResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__UploadTestResultResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__UploadTestResultResponse, default initialized and not managed by a soap context
        virtual _ns1__UploadTestResultResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__UploadTestResultResponse); }
      public:
        /// Constructor with initializations
        _ns1__UploadTestResultResponse() : UploadTestResultResult(), soap() { }
        virtual ~_ns1__UploadTestResultResponse() { }
        /// Friend allocator used by soap_new__ns1__UploadTestResultResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__UploadTestResultResponse * SOAP_FMAC2 soap_instantiate__ns1__UploadTestResultResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:152 */
#ifndef SOAP_TYPE__ns1__CheckSSN
#define SOAP_TYPE__ns1__CheckSSN (12)
/* complex XSD type 'ns1:CheckSSN': */
class SOAP_CMAC _ns1__CheckSSN {
      public:
        /// Optional element 'ns1:strSN' of XSD type 'xsd:string'
        char *strSN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CheckSSN
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__CheckSSN; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CheckSSN, default initialized and not managed by a soap context
        virtual _ns1__CheckSSN *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__CheckSSN); }
      public:
        /// Constructor with initializations
        _ns1__CheckSSN() : strSN(), soap() { }
        virtual ~_ns1__CheckSSN() { }
        /// Friend allocator used by soap_new__ns1__CheckSSN(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CheckSSN * SOAP_FMAC2 soap_instantiate__ns1__CheckSSN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:155 */
#ifndef SOAP_TYPE__ns1__CheckSSNResponse
#define SOAP_TYPE__ns1__CheckSSNResponse (13)
/* complex XSD type 'ns1:CheckSSNResponse': */
class SOAP_CMAC _ns1__CheckSSNResponse {
      public:
        /// Optional element 'ns1:CheckSSNResult' of XSD type 'ns1:ArrayOfAnyType'
        ns1__ArrayOfAnyType *CheckSSNResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CheckSSNResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__CheckSSNResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CheckSSNResponse, default initialized and not managed by a soap context
        virtual _ns1__CheckSSNResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__CheckSSNResponse); }
      public:
        /// Constructor with initializations
        _ns1__CheckSSNResponse() : CheckSSNResult(), soap() { }
        virtual ~_ns1__CheckSSNResponse() { }
        /// Friend allocator used by soap_new__ns1__CheckSSNResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CheckSSNResponse * SOAP_FMAC2 soap_instantiate__ns1__CheckSSNResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:158 */
#ifndef SOAP_TYPE__ns1__CheckSSN_USCORENEW
#define SOAP_TYPE__ns1__CheckSSN_USCORENEW (14)
/* complex XSD type 'ns1:CheckSSN_NEW': */
class SOAP_CMAC _ns1__CheckSSN_USCORENEW {
      public:
        /// Optional element 'ns1:strSN' of XSD type 'xsd:string'
        char *strSN;
        /// Optional element 'ns1:station' of XSD type 'xsd:string'
        char *station;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CheckSSN_USCORENEW
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__CheckSSN_USCORENEW; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CheckSSN_USCORENEW, default initialized and not managed by a soap context
        virtual _ns1__CheckSSN_USCORENEW *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__CheckSSN_USCORENEW); }
      public:
        /// Constructor with initializations
        _ns1__CheckSSN_USCORENEW() : strSN(), station(), soap() { }
        virtual ~_ns1__CheckSSN_USCORENEW() { }
        /// Friend allocator used by soap_new__ns1__CheckSSN_USCORENEW(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CheckSSN_USCORENEW * SOAP_FMAC2 soap_instantiate__ns1__CheckSSN_USCORENEW(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:161 */
#ifndef SOAP_TYPE__ns1__CheckSSN_USCORENEWResponse
#define SOAP_TYPE__ns1__CheckSSN_USCORENEWResponse (15)
/* complex XSD type 'ns1:CheckSSN_NEWResponse': */
class SOAP_CMAC _ns1__CheckSSN_USCORENEWResponse {
      public:
        /// Optional element 'ns1:CheckSSN_NEWResult' of XSD type 'ns1:ArrayOfAnyType'
        ns1__ArrayOfAnyType *CheckSSN_USCORENEWResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CheckSSN_USCORENEWResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__CheckSSN_USCORENEWResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CheckSSN_USCORENEWResponse, default initialized and not managed by a soap context
        virtual _ns1__CheckSSN_USCORENEWResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__CheckSSN_USCORENEWResponse); }
      public:
        /// Constructor with initializations
        _ns1__CheckSSN_USCORENEWResponse() : CheckSSN_USCORENEWResult(), soap() { }
        virtual ~_ns1__CheckSSN_USCORENEWResponse() { }
        /// Friend allocator used by soap_new__ns1__CheckSSN_USCORENEWResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CheckSSN_USCORENEWResponse * SOAP_FMAC2 soap_instantiate__ns1__CheckSSN_USCORENEWResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:164 */
#ifndef SOAP_TYPE__ns1__Binding
#define SOAP_TYPE__ns1__Binding (16)
/* complex XSD type 'ns1:Binding': */
class SOAP_CMAC _ns1__Binding {
      public:
        /// Optional element 'ns1:ssn' of XSD type 'xsd:string'
        char *ssn;
        /// Optional element 'ns1:csn' of XSD type 'xsd:string'
        char *csn;
        /// Optional element 'ns1:key' of XSD type 'xsd:string'
        char *key;
        /// Optional element 'ns1:station' of XSD type 'xsd:string'
        char *station;
        /// Optional element 'ns1:user' of XSD type 'xsd:string'
        char *user;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__Binding
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__Binding; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__Binding, default initialized and not managed by a soap context
        virtual _ns1__Binding *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__Binding); }
      public:
        /// Constructor with initializations
        _ns1__Binding() : ssn(), csn(), key(), station(), user(), soap() { }
        virtual ~_ns1__Binding() { }
        /// Friend allocator used by soap_new__ns1__Binding(struct soap*, int)
        friend SOAP_FMAC1 _ns1__Binding * SOAP_FMAC2 soap_instantiate__ns1__Binding(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:167 */
#ifndef SOAP_TYPE__ns1__BindingResponse
#define SOAP_TYPE__ns1__BindingResponse (17)
/* complex XSD type 'ns1:BindingResponse': */
class SOAP_CMAC _ns1__BindingResponse {
      public:
        /// Optional element 'ns1:BindingResult' of XSD type 'ns1:ArrayOfAnyType'
        ns1__ArrayOfAnyType *BindingResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__BindingResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__BindingResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__BindingResponse, default initialized and not managed by a soap context
        virtual _ns1__BindingResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__BindingResponse); }
      public:
        /// Constructor with initializations
        _ns1__BindingResponse() : BindingResult(), soap() { }
        virtual ~_ns1__BindingResponse() { }
        /// Friend allocator used by soap_new__ns1__BindingResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__BindingResponse * SOAP_FMAC2 soap_instantiate__ns1__BindingResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:170 */
#ifndef SOAP_TYPE__ns1__QueryBinding
#define SOAP_TYPE__ns1__QueryBinding (18)
/* complex XSD type 'ns1:QueryBinding': */
class SOAP_CMAC _ns1__QueryBinding {
      public:
        /// Optional element 'ns1:DataType' of XSD type 'xsd:string'
        char *DataType;
        /// Optional element 'ns1:DataValue' of XSD type 'xsd:string'
        char *DataValue;
        /// Optional element 'ns1:querytype' of XSD type 'xsd:string'
        char *querytype;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__QueryBinding
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__QueryBinding; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__QueryBinding, default initialized and not managed by a soap context
        virtual _ns1__QueryBinding *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__QueryBinding); }
      public:
        /// Constructor with initializations
        _ns1__QueryBinding() : DataType(), DataValue(), querytype(), soap() { }
        virtual ~_ns1__QueryBinding() { }
        /// Friend allocator used by soap_new__ns1__QueryBinding(struct soap*, int)
        friend SOAP_FMAC1 _ns1__QueryBinding * SOAP_FMAC2 soap_instantiate__ns1__QueryBinding(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:173 */
#ifndef SOAP_TYPE__ns1__QueryBindingResponse
#define SOAP_TYPE__ns1__QueryBindingResponse (19)
/* complex XSD type 'ns1:QueryBindingResponse': */
class SOAP_CMAC _ns1__QueryBindingResponse {
      public:
        /// Optional element 'ns1:QueryBindingResult' of XSD type 'ns1:ArrayOfAnyType'
        ns1__ArrayOfAnyType *QueryBindingResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__QueryBindingResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__QueryBindingResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__QueryBindingResponse, default initialized and not managed by a soap context
        virtual _ns1__QueryBindingResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__QueryBindingResponse); }
      public:
        /// Constructor with initializations
        _ns1__QueryBindingResponse() : QueryBindingResult(), soap() { }
        virtual ~_ns1__QueryBindingResponse() { }
        /// Friend allocator used by soap_new__ns1__QueryBindingResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__QueryBindingResponse * SOAP_FMAC2 soap_instantiate__ns1__QueryBindingResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:176 */
#ifndef SOAP_TYPE__ns1__SfcTestResult_USCOREUpload
#define SOAP_TYPE__ns1__SfcTestResult_USCOREUpload (20)
/* complex XSD type 'ns1:SfcTestResult_Upload': */
class SOAP_CMAC _ns1__SfcTestResult_USCOREUpload {
      public:
        /// Optional element 'ns1:strEventPoint' of XSD type 'xsd:string'
        char *strEventPoint;
        /// Optional element 'ns1:strSSN' of XSD type 'xsd:string'
        char *strSSN;
        /// Optional element 'ns1:testresult' of XSD type 'xsd:string'
        char *testresult;
        /// Required element 'ns1:testtime' of XSD type 'xsd:dateTime'
        time_t testtime;
        /// Optional element 'ns1:testitem' of XSD type 'xsd:string'
        char *testitem;
        /// Optional element 'ns1:testvalue' of XSD type 'xsd:string'
        char *testvalue;
        /// Optional element 'ns1:strScanner' of XSD type 'xsd:string'
        char *strScanner;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SfcTestResult_USCOREUpload
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__SfcTestResult_USCOREUpload; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SfcTestResult_USCOREUpload, default initialized and not managed by a soap context
        virtual _ns1__SfcTestResult_USCOREUpload *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__SfcTestResult_USCOREUpload); }
      public:
        /// Constructor with initializations
        _ns1__SfcTestResult_USCOREUpload() : strEventPoint(), strSSN(), testresult(), testtime(), testitem(), testvalue(), strScanner(), soap() { }
        virtual ~_ns1__SfcTestResult_USCOREUpload() { }
        /// Friend allocator used by soap_new__ns1__SfcTestResult_USCOREUpload(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SfcTestResult_USCOREUpload * SOAP_FMAC2 soap_instantiate__ns1__SfcTestResult_USCOREUpload(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:179 */
#ifndef SOAP_TYPE__ns1__SfcTestResult_USCOREUploadResponse
#define SOAP_TYPE__ns1__SfcTestResult_USCOREUploadResponse (21)
/* complex XSD type 'ns1:SfcTestResult_UploadResponse': */
class SOAP_CMAC _ns1__SfcTestResult_USCOREUploadResponse {
      public:
        /// Optional element 'ns1:SfcTestResult_UploadResult' of XSD type 'ns1:ArrayOfAnyType'
        ns1__ArrayOfAnyType *SfcTestResult_USCOREUploadResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SfcTestResult_USCOREUploadResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__SfcTestResult_USCOREUploadResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SfcTestResult_USCOREUploadResponse, default initialized and not managed by a soap context
        virtual _ns1__SfcTestResult_USCOREUploadResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__SfcTestResult_USCOREUploadResponse); }
      public:
        /// Constructor with initializations
        _ns1__SfcTestResult_USCOREUploadResponse() : SfcTestResult_USCOREUploadResult(), soap() { }
        virtual ~_ns1__SfcTestResult_USCOREUploadResponse() { }
        /// Friend allocator used by soap_new__ns1__SfcTestResult_USCOREUploadResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SfcTestResult_USCOREUploadResponse * SOAP_FMAC2 soap_instantiate__ns1__SfcTestResult_USCOREUploadResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:182 */
#ifndef SOAP_TYPE__ns1__SaveSSN_USCORENEW
#define SOAP_TYPE__ns1__SaveSSN_USCORENEW (22)
/* complex XSD type 'ns1:SaveSSN_NEW': */
class SOAP_CMAC _ns1__SaveSSN_USCORENEW {
      public:
        /// Optional element 'ns1:strSSN' of XSD type 'xsd:string'
        char *strSSN;
        /// Optional element 'ns1:strEventPoint' of XSD type 'xsd:string'
        char *strEventPoint;
        /// Optional element 'ns1:strIspass' of XSD type 'xsd:string'
        char *strIspass;
        /// Optional element 'ns1:strFailcode' of XSD type 'xsd:string'
        char *strFailcode;
        /// Optional element 'ns1:strScanner' of XSD type 'xsd:string'
        char *strScanner;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SaveSSN_USCORENEW
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__SaveSSN_USCORENEW; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SaveSSN_USCORENEW, default initialized and not managed by a soap context
        virtual _ns1__SaveSSN_USCORENEW *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__SaveSSN_USCORENEW); }
      public:
        /// Constructor with initializations
        _ns1__SaveSSN_USCORENEW() : strSSN(), strEventPoint(), strIspass(), strFailcode(), strScanner(), soap() { }
        virtual ~_ns1__SaveSSN_USCORENEW() { }
        /// Friend allocator used by soap_new__ns1__SaveSSN_USCORENEW(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SaveSSN_USCORENEW * SOAP_FMAC2 soap_instantiate__ns1__SaveSSN_USCORENEW(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:185 */
#ifndef SOAP_TYPE__ns1__SaveSSN_USCORENEWResponse
#define SOAP_TYPE__ns1__SaveSSN_USCORENEWResponse (23)
/* complex XSD type 'ns1:SaveSSN_NEWResponse': */
class SOAP_CMAC _ns1__SaveSSN_USCORENEWResponse {
      public:
        /// Optional element 'ns1:SaveSSN_NEWResult' of XSD type 'ns1:ArrayOfAnyType'
        ns1__ArrayOfAnyType *SaveSSN_USCORENEWResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SaveSSN_USCORENEWResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__SaveSSN_USCORENEWResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SaveSSN_USCORENEWResponse, default initialized and not managed by a soap context
        virtual _ns1__SaveSSN_USCORENEWResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__SaveSSN_USCORENEWResponse); }
      public:
        /// Constructor with initializations
        _ns1__SaveSSN_USCORENEWResponse() : SaveSSN_USCORENEWResult(), soap() { }
        virtual ~_ns1__SaveSSN_USCORENEWResponse() { }
        /// Friend allocator used by soap_new__ns1__SaveSSN_USCORENEWResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SaveSSN_USCORENEWResponse * SOAP_FMAC2 soap_instantiate__ns1__SaveSSN_USCORENEWResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:188 */
#ifndef SOAP_TYPE__ns1__test
#define SOAP_TYPE__ns1__test (24)
/* complex XSD type 'ns1:test': */
class SOAP_CMAC _ns1__test {
      public:
        /// Optional element 'ns1:strSN' of XSD type 'xsd:string'
        char *strSN;
        /// Optional element 'ns1:aa' of XSD type 'xsd:string'
        char *aa;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__test
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__test; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__test, default initialized and not managed by a soap context
        virtual _ns1__test *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__test); }
      public:
        /// Constructor with initializations
        _ns1__test() : strSN(), aa(), soap() { }
        virtual ~_ns1__test() { }
        /// Friend allocator used by soap_new__ns1__test(struct soap*, int)
        friend SOAP_FMAC1 _ns1__test * SOAP_FMAC2 soap_instantiate__ns1__test(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:191 */
#ifndef SOAP_TYPE__ns1__testResponse
#define SOAP_TYPE__ns1__testResponse (25)
/* complex XSD type 'ns1:testResponse': */
class SOAP_CMAC _ns1__testResponse {
      public:
        /// Optional element 'ns1:testResult' of XSD type 'ns1:ArrayOfAnyType'
        ns1__ArrayOfAnyType *testResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__testResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__testResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__testResponse, default initialized and not managed by a soap context
        virtual _ns1__testResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__testResponse); }
      public:
        /// Constructor with initializations
        _ns1__testResponse() : testResult(), soap() { }
        virtual ~_ns1__testResponse() { }
        /// Friend allocator used by soap_new__ns1__testResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__testResponse * SOAP_FMAC2 soap_instantiate__ns1__testResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:194 */
#ifndef SOAP_TYPE__ns1__GETMACID
#define SOAP_TYPE__ns1__GETMACID (26)
/* complex XSD type 'ns1:GETMACID': */
class SOAP_CMAC _ns1__GETMACID {
      public:
        /// Optional element 'ns1:strSN' of XSD type 'xsd:string'
        char *strSN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GETMACID
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__GETMACID; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GETMACID, default initialized and not managed by a soap context
        virtual _ns1__GETMACID *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__GETMACID); }
      public:
        /// Constructor with initializations
        _ns1__GETMACID() : strSN(), soap() { }
        virtual ~_ns1__GETMACID() { }
        /// Friend allocator used by soap_new__ns1__GETMACID(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GETMACID * SOAP_FMAC2 soap_instantiate__ns1__GETMACID(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:727 */
#ifndef SOAP_TYPE__ns1__GETMACIDResponse_GETMACIDResult
#define SOAP_TYPE__ns1__GETMACIDResponse_GETMACIDResult (48)
/* complex XSD type 'ns1:GETMACIDResponse-GETMACIDResult': */
class SOAP_CMAC _ns1__GETMACIDResponse_GETMACIDResult {
      public:
        /// Sequence of elements '-any' of XSD type 'xsd:anyType' stored in dynamic array __any of length __size
        int __size;
        char *__any;
        char *__any_;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GETMACIDResponse_GETMACIDResult
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__GETMACIDResponse_GETMACIDResult; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GETMACIDResponse_GETMACIDResult, default initialized and not managed by a soap context
        virtual _ns1__GETMACIDResponse_GETMACIDResult *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__GETMACIDResponse_GETMACIDResult); }
      public:
        /// Constructor with initializations
        _ns1__GETMACIDResponse_GETMACIDResult() : __size(), __any(), __any_() { }
        virtual ~_ns1__GETMACIDResponse_GETMACIDResult() { }
        /// Friend allocator used by soap_new__ns1__GETMACIDResponse_GETMACIDResult(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GETMACIDResponse_GETMACIDResult * SOAP_FMAC2 soap_instantiate__ns1__GETMACIDResponse_GETMACIDResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:197 */
#ifndef SOAP_TYPE__ns1__GETMACIDResponse
#define SOAP_TYPE__ns1__GETMACIDResponse (27)
/* complex XSD type 'ns1:GETMACIDResponse': */
class SOAP_CMAC _ns1__GETMACIDResponse {
      public:
        /// Optional element 'ns1:GETMACIDResult' of XSD type 'ns1:GETMACIDResponse-GETMACIDResult'
        _ns1__GETMACIDResponse_GETMACIDResult *GETMACIDResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GETMACIDResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__GETMACIDResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GETMACIDResponse, default initialized and not managed by a soap context
        virtual _ns1__GETMACIDResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__GETMACIDResponse); }
      public:
        /// Constructor with initializations
        _ns1__GETMACIDResponse() : GETMACIDResult(), soap() { }
        virtual ~_ns1__GETMACIDResponse() { }
        /// Friend allocator used by soap_new__ns1__GETMACIDResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GETMACIDResponse * SOAP_FMAC2 soap_instantiate__ns1__GETMACIDResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:200 */
#ifndef SOAP_TYPE__ns1__GetMacBySn
#define SOAP_TYPE__ns1__GetMacBySn (28)
/* complex XSD type 'ns1:GetMacBySn': */
class SOAP_CMAC _ns1__GetMacBySn {
      public:
        /// Optional element 'ns1:strSN' of XSD type 'xsd:string'
        char *strSN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetMacBySn
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__GetMacBySn; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetMacBySn, default initialized and not managed by a soap context
        virtual _ns1__GetMacBySn *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__GetMacBySn); }
      public:
        /// Constructor with initializations
        _ns1__GetMacBySn() : strSN(), soap() { }
        virtual ~_ns1__GetMacBySn() { }
        /// Friend allocator used by soap_new__ns1__GetMacBySn(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetMacBySn * SOAP_FMAC2 soap_instantiate__ns1__GetMacBySn(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:203 */
#ifndef SOAP_TYPE__ns1__GetMacBySnResponse
#define SOAP_TYPE__ns1__GetMacBySnResponse (29)
/* complex XSD type 'ns1:GetMacBySnResponse': */
class SOAP_CMAC _ns1__GetMacBySnResponse {
      public:
        /// Optional element 'ns1:GetMacBySnResult' of XSD type 'ns1:ArrayOfAnyType'
        ns1__ArrayOfAnyType *GetMacBySnResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetMacBySnResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__GetMacBySnResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetMacBySnResponse, default initialized and not managed by a soap context
        virtual _ns1__GetMacBySnResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__GetMacBySnResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetMacBySnResponse() : GetMacBySnResult(), soap() { }
        virtual ~_ns1__GetMacBySnResponse() { }
        /// Friend allocator used by soap_new__ns1__GetMacBySnResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetMacBySnResponse * SOAP_FMAC2 soap_instantiate__ns1__GetMacBySnResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:206 */
#ifndef SOAP_TYPE__ns1__CartonWeight_USCOREUpload
#define SOAP_TYPE__ns1__CartonWeight_USCOREUpload (30)
/* complex XSD type 'ns1:CartonWeight_Upload': */
class SOAP_CMAC _ns1__CartonWeight_USCOREUpload {
      public:
        /// Optional element 'ns1:strSN' of XSD type 'xsd:string'
        char *strSN;
        /// Required element 'ns1:weight' of XSD type 'xsd:float'
        float weight;
        /// Required element 'ns1:ismore' of XSD type 'xsd:boolean'
        bool ismore;
        /// Optional element 'ns1:editby' of XSD type 'xsd:string'
        char *editby;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CartonWeight_USCOREUpload
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__CartonWeight_USCOREUpload; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CartonWeight_USCOREUpload, default initialized and not managed by a soap context
        virtual _ns1__CartonWeight_USCOREUpload *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__CartonWeight_USCOREUpload); }
      public:
        /// Constructor with initializations
        _ns1__CartonWeight_USCOREUpload() : strSN(), weight(), ismore(), editby(), soap() { }
        virtual ~_ns1__CartonWeight_USCOREUpload() { }
        /// Friend allocator used by soap_new__ns1__CartonWeight_USCOREUpload(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CartonWeight_USCOREUpload * SOAP_FMAC2 soap_instantiate__ns1__CartonWeight_USCOREUpload(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:209 */
#ifndef SOAP_TYPE__ns1__CartonWeight_USCOREUploadResponse
#define SOAP_TYPE__ns1__CartonWeight_USCOREUploadResponse (31)
/* complex XSD type 'ns1:CartonWeight_UploadResponse': */
class SOAP_CMAC _ns1__CartonWeight_USCOREUploadResponse {
      public:
        /// Optional element 'ns1:CartonWeight_UploadResult' of XSD type 'ns1:ArrayOfAnyType'
        ns1__ArrayOfAnyType *CartonWeight_USCOREUploadResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CartonWeight_USCOREUploadResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__CartonWeight_USCOREUploadResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CartonWeight_USCOREUploadResponse, default initialized and not managed by a soap context
        virtual _ns1__CartonWeight_USCOREUploadResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__CartonWeight_USCOREUploadResponse); }
      public:
        /// Constructor with initializations
        _ns1__CartonWeight_USCOREUploadResponse() : CartonWeight_USCOREUploadResult(), soap() { }
        virtual ~_ns1__CartonWeight_USCOREUploadResponse() { }
        /// Friend allocator used by soap_new__ns1__CartonWeight_USCOREUploadResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CartonWeight_USCOREUploadResponse * SOAP_FMAC2 soap_instantiate__ns1__CartonWeight_USCOREUploadResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:212 */
#ifndef SOAP_TYPE__ns1__PCBData_USCOREUpload
#define SOAP_TYPE__ns1__PCBData_USCOREUpload (32)
/* complex XSD type 'ns1:PCBData_Upload': */
class SOAP_CMAC _ns1__PCBData_USCOREUpload {
      public:
        /// Optional element 'ns1:partno' of XSD type 'xsd:string'
        char *partno;
        /// Optional element 'ns1:FTdata' of XSD type 'xsd:string'
        char *FTdata;
        /// Optional element 'ns1:version' of XSD type 'xsd:string'
        char *version;
        /// Optional element 'ns1:PCBsn' of XSD type 'xsd:string'
        char *PCBsn;
        /// Optional element 'ns1:cpu' of XSD type 'xsd:string'
        char *cpu;
        /// Optional element 'ns1:flash' of XSD type 'xsd:string'
        char *flash;
        /// Optional element 'ns1:rom' of XSD type 'xsd:string'
        char *rom;
        /// Optional element 'ns1:wifi' of XSD type 'xsd:string'
        char *wifi;
        /// Optional element 'ns1:bt' of XSD type 'xsd:string'
        char *bt;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__PCBData_USCOREUpload
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__PCBData_USCOREUpload; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__PCBData_USCOREUpload, default initialized and not managed by a soap context
        virtual _ns1__PCBData_USCOREUpload *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__PCBData_USCOREUpload); }
      public:
        /// Constructor with initializations
        _ns1__PCBData_USCOREUpload() : partno(), FTdata(), version(), PCBsn(), cpu(), flash(), rom(), wifi(), bt(), soap() { }
        virtual ~_ns1__PCBData_USCOREUpload() { }
        /// Friend allocator used by soap_new__ns1__PCBData_USCOREUpload(struct soap*, int)
        friend SOAP_FMAC1 _ns1__PCBData_USCOREUpload * SOAP_FMAC2 soap_instantiate__ns1__PCBData_USCOREUpload(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:215 */
#ifndef SOAP_TYPE__ns1__PCBData_USCOREUploadResponse
#define SOAP_TYPE__ns1__PCBData_USCOREUploadResponse (33)
/* complex XSD type 'ns1:PCBData_UploadResponse': */
class SOAP_CMAC _ns1__PCBData_USCOREUploadResponse {
      public:
        /// Optional element 'ns1:PCBData_UploadResult' of XSD type 'ns1:ArrayOfAnyType'
        ns1__ArrayOfAnyType *PCBData_USCOREUploadResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__PCBData_USCOREUploadResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__PCBData_USCOREUploadResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__PCBData_USCOREUploadResponse, default initialized and not managed by a soap context
        virtual _ns1__PCBData_USCOREUploadResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__PCBData_USCOREUploadResponse); }
      public:
        /// Constructor with initializations
        _ns1__PCBData_USCOREUploadResponse() : PCBData_USCOREUploadResult(), soap() { }
        virtual ~_ns1__PCBData_USCOREUploadResponse() { }
        /// Friend allocator used by soap_new__ns1__PCBData_USCOREUploadResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__PCBData_USCOREUploadResponse * SOAP_FMAC2 soap_instantiate__ns1__PCBData_USCOREUploadResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:218 */
#ifndef SOAP_TYPE__ns1__GetShaoluKey
#define SOAP_TYPE__ns1__GetShaoluKey (34)
/* complex XSD type 'ns1:GetShaoluKey': */
class SOAP_CMAC _ns1__GetShaoluKey {
      public:
        /// Optional element 'ns1:customer' of XSD type 'xsd:string'
        char *customer;
        /// Optional element 'ns1:ssn' of XSD type 'xsd:string'
        char *ssn;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetShaoluKey
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__GetShaoluKey; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetShaoluKey, default initialized and not managed by a soap context
        virtual _ns1__GetShaoluKey *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__GetShaoluKey); }
      public:
        /// Constructor with initializations
        _ns1__GetShaoluKey() : customer(), ssn(), soap() { }
        virtual ~_ns1__GetShaoluKey() { }
        /// Friend allocator used by soap_new__ns1__GetShaoluKey(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetShaoluKey * SOAP_FMAC2 soap_instantiate__ns1__GetShaoluKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:221 */
#ifndef SOAP_TYPE__ns1__GetShaoluKeyResponse
#define SOAP_TYPE__ns1__GetShaoluKeyResponse (35)
/* complex XSD type 'ns1:GetShaoluKeyResponse': */
class SOAP_CMAC _ns1__GetShaoluKeyResponse {
      public:
        /// Optional element 'ns1:GetShaoluKeyResult' of XSD type 'ns1:ArrayOfAnyType'
        ns1__ArrayOfAnyType *GetShaoluKeyResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetShaoluKeyResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__GetShaoluKeyResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetShaoluKeyResponse, default initialized and not managed by a soap context
        virtual _ns1__GetShaoluKeyResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__GetShaoluKeyResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetShaoluKeyResponse() : GetShaoluKeyResult(), soap() { }
        virtual ~_ns1__GetShaoluKeyResponse() { }
        /// Friend allocator used by soap_new__ns1__GetShaoluKeyResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetShaoluKeyResponse * SOAP_FMAC2 soap_instantiate__ns1__GetShaoluKeyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:224 */
#ifndef SOAP_TYPE__ns1__ReleaseKey
#define SOAP_TYPE__ns1__ReleaseKey (36)
/* complex XSD type 'ns1:ReleaseKey': */
class SOAP_CMAC _ns1__ReleaseKey {
      public:
        /// Optional element 'ns1:key' of XSD type 'xsd:string'
        char *key;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ReleaseKey
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__ReleaseKey; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ReleaseKey, default initialized and not managed by a soap context
        virtual _ns1__ReleaseKey *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__ReleaseKey); }
      public:
        /// Constructor with initializations
        _ns1__ReleaseKey() : key(), soap() { }
        virtual ~_ns1__ReleaseKey() { }
        /// Friend allocator used by soap_new__ns1__ReleaseKey(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ReleaseKey * SOAP_FMAC2 soap_instantiate__ns1__ReleaseKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:227 */
#ifndef SOAP_TYPE__ns1__ReleaseKeyResponse
#define SOAP_TYPE__ns1__ReleaseKeyResponse (37)
/* complex XSD type 'ns1:ReleaseKeyResponse': */
class SOAP_CMAC _ns1__ReleaseKeyResponse {
      public:
        /// Optional element 'ns1:ReleaseKeyResult' of XSD type 'ns1:ArrayOfAnyType'
        ns1__ArrayOfAnyType *ReleaseKeyResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ReleaseKeyResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__ReleaseKeyResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ReleaseKeyResponse, default initialized and not managed by a soap context
        virtual _ns1__ReleaseKeyResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__ReleaseKeyResponse); }
      public:
        /// Constructor with initializations
        _ns1__ReleaseKeyResponse() : ReleaseKeyResult(), soap() { }
        virtual ~_ns1__ReleaseKeyResponse() { }
        /// Friend allocator used by soap_new__ns1__ReleaseKeyResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ReleaseKeyResponse * SOAP_FMAC2 soap_instantiate__ns1__ReleaseKeyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:230 */
#ifndef SOAP_TYPE__ns1__BindKey
#define SOAP_TYPE__ns1__BindKey (38)
/* complex XSD type 'ns1:BindKey': */
class SOAP_CMAC _ns1__BindKey {
      public:
        /// Optional element 'ns1:key' of XSD type 'xsd:string'
        char *key;
        /// Optional element 'ns1:ssn' of XSD type 'xsd:string'
        char *ssn;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__BindKey
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__BindKey; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__BindKey, default initialized and not managed by a soap context
        virtual _ns1__BindKey *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__BindKey); }
      public:
        /// Constructor with initializations
        _ns1__BindKey() : key(), ssn(), soap() { }
        virtual ~_ns1__BindKey() { }
        /// Friend allocator used by soap_new__ns1__BindKey(struct soap*, int)
        friend SOAP_FMAC1 _ns1__BindKey * SOAP_FMAC2 soap_instantiate__ns1__BindKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:233 */
#ifndef SOAP_TYPE__ns1__BindKeyResponse
#define SOAP_TYPE__ns1__BindKeyResponse (39)
/* complex XSD type 'ns1:BindKeyResponse': */
class SOAP_CMAC _ns1__BindKeyResponse {
      public:
        /// Optional element 'ns1:BindKeyResult' of XSD type 'ns1:ArrayOfAnyType'
        ns1__ArrayOfAnyType *BindKeyResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__BindKeyResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__BindKeyResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__BindKeyResponse, default initialized and not managed by a soap context
        virtual _ns1__BindKeyResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__BindKeyResponse); }
      public:
        /// Constructor with initializations
        _ns1__BindKeyResponse() : BindKeyResult(), soap() { }
        virtual ~_ns1__BindKeyResponse() { }
        /// Friend allocator used by soap_new__ns1__BindKeyResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__BindKeyResponse * SOAP_FMAC2 soap_instantiate__ns1__BindKeyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:236 */
#ifndef SOAP_TYPE__ns1__GetSparrowCheckData
#define SOAP_TYPE__ns1__GetSparrowCheckData (40)
/* complex XSD type 'ns1:GetSparrowCheckData': */
class SOAP_CMAC _ns1__GetSparrowCheckData {
      public:
        /// Optional element 'ns1:SN' of XSD type 'xsd:string'
        char *SN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetSparrowCheckData
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__GetSparrowCheckData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetSparrowCheckData, default initialized and not managed by a soap context
        virtual _ns1__GetSparrowCheckData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__GetSparrowCheckData); }
      public:
        /// Constructor with initializations
        _ns1__GetSparrowCheckData() : SN(), soap() { }
        virtual ~_ns1__GetSparrowCheckData() { }
        /// Friend allocator used by soap_new__ns1__GetSparrowCheckData(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetSparrowCheckData * SOAP_FMAC2 soap_instantiate__ns1__GetSparrowCheckData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:239 */
#ifndef SOAP_TYPE__ns1__GetSparrowCheckDataResponse
#define SOAP_TYPE__ns1__GetSparrowCheckDataResponse (41)
/* complex XSD type 'ns1:GetSparrowCheckDataResponse': */
class SOAP_CMAC _ns1__GetSparrowCheckDataResponse {
      public:
        /// Optional element 'ns1:GetSparrowCheckDataResult' of XSD type 'ns1:ArrayOfAnyType'
        ns1__ArrayOfAnyType *GetSparrowCheckDataResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetSparrowCheckDataResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__GetSparrowCheckDataResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetSparrowCheckDataResponse, default initialized and not managed by a soap context
        virtual _ns1__GetSparrowCheckDataResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__GetSparrowCheckDataResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetSparrowCheckDataResponse() : GetSparrowCheckDataResult(), soap() { }
        virtual ~_ns1__GetSparrowCheckDataResponse() { }
        /// Friend allocator used by soap_new__ns1__GetSparrowCheckDataResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetSparrowCheckDataResponse * SOAP_FMAC2 soap_instantiate__ns1__GetSparrowCheckDataResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:242 */
#ifndef SOAP_TYPE__ns1__BlindKeyNum
#define SOAP_TYPE__ns1__BlindKeyNum (42)
/* complex XSD type 'ns1:BlindKeyNum': */
class SOAP_CMAC _ns1__BlindKeyNum {
      public:
        /// Optional element 'ns1:strSSN' of XSD type 'xsd:string'
        char *strSSN;
        /// Optional element 'ns1:strEventPoint' of XSD type 'xsd:string'
        char *strEventPoint;
        /// Optional element 'ns1:user' of XSD type 'xsd:string'
        char *user;
        /// Optional element 'ns1:Key' of XSD type 'xsd:string'
        char *Key;
        /// Optional element 'ns1:Key2' of XSD type 'xsd:string'
        char *Key2;
        /// Optional element 'ns1:Key3' of XSD type 'xsd:string'
        char *Key3;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__BlindKeyNum
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__BlindKeyNum; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__BlindKeyNum, default initialized and not managed by a soap context
        virtual _ns1__BlindKeyNum *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__BlindKeyNum); }
      public:
        /// Constructor with initializations
        _ns1__BlindKeyNum() : strSSN(), strEventPoint(), user(), Key(), Key2(), Key3(), soap() { }
        virtual ~_ns1__BlindKeyNum() { }
        /// Friend allocator used by soap_new__ns1__BlindKeyNum(struct soap*, int)
        friend SOAP_FMAC1 _ns1__BlindKeyNum * SOAP_FMAC2 soap_instantiate__ns1__BlindKeyNum(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:245 */
#ifndef SOAP_TYPE__ns1__BlindKeyNumResponse
#define SOAP_TYPE__ns1__BlindKeyNumResponse (43)
/* complex XSD type 'ns1:BlindKeyNumResponse': */
class SOAP_CMAC _ns1__BlindKeyNumResponse {
      public:
        /// Optional element 'ns1:BlindKeyNumResult' of XSD type 'ns1:ArrayOfAnyType'
        ns1__ArrayOfAnyType *BlindKeyNumResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__BlindKeyNumResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__BlindKeyNumResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__BlindKeyNumResponse, default initialized and not managed by a soap context
        virtual _ns1__BlindKeyNumResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__BlindKeyNumResponse); }
      public:
        /// Constructor with initializations
        _ns1__BlindKeyNumResponse() : BlindKeyNumResult(), soap() { }
        virtual ~_ns1__BlindKeyNumResponse() { }
        /// Friend allocator used by soap_new__ns1__BlindKeyNumResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__BlindKeyNumResponse * SOAP_FMAC2 soap_instantiate__ns1__BlindKeyNumResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:1319 */
#ifndef SOAP_TYPE___ns1__DoFunction
#define SOAP_TYPE___ns1__DoFunction (55)
/* Wrapper: */
struct SOAP_CMAC __ns1__DoFunction {
      public:
        /** Optional element 'ns1:DoFunction' of XSD type 'ns1:DoFunction' */
        _ns1__DoFunction *ns1__DoFunction;
      public:
        /** Return unique type id SOAP_TYPE___ns1__DoFunction */
        long soap_type() const { return SOAP_TYPE___ns1__DoFunction; }
        /** Constructor with member initializations */
        __ns1__DoFunction() : ns1__DoFunction() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__DoFunction * SOAP_FMAC2 soap_instantiate___ns1__DoFunction(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:1389 */
#ifndef SOAP_TYPE___ns1__UploadTestResult
#define SOAP_TYPE___ns1__UploadTestResult (59)
/* Wrapper: */
struct SOAP_CMAC __ns1__UploadTestResult {
      public:
        /** Optional element 'ns1:UploadTestResult' of XSD type 'ns1:UploadTestResult' */
        _ns1__UploadTestResult *ns1__UploadTestResult;
      public:
        /** Return unique type id SOAP_TYPE___ns1__UploadTestResult */
        long soap_type() const { return SOAP_TYPE___ns1__UploadTestResult; }
        /** Constructor with member initializations */
        __ns1__UploadTestResult() : ns1__UploadTestResult() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__UploadTestResult * SOAP_FMAC2 soap_instantiate___ns1__UploadTestResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:1459 */
#ifndef SOAP_TYPE___ns1__CheckSSN
#define SOAP_TYPE___ns1__CheckSSN (63)
/* Wrapper: */
struct SOAP_CMAC __ns1__CheckSSN {
      public:
        /** Optional element 'ns1:CheckSSN' of XSD type 'ns1:CheckSSN' */
        _ns1__CheckSSN *ns1__CheckSSN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CheckSSN */
        long soap_type() const { return SOAP_TYPE___ns1__CheckSSN; }
        /** Constructor with member initializations */
        __ns1__CheckSSN() : ns1__CheckSSN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__CheckSSN * SOAP_FMAC2 soap_instantiate___ns1__CheckSSN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:1529 */
#ifndef SOAP_TYPE___ns1__CheckSSN_USCORENEW
#define SOAP_TYPE___ns1__CheckSSN_USCORENEW (67)
/* Wrapper: */
struct SOAP_CMAC __ns1__CheckSSN_USCORENEW {
      public:
        /** Optional element 'ns1:CheckSSN_NEW' of XSD type 'ns1:CheckSSN_NEW' */
        _ns1__CheckSSN_USCORENEW *ns1__CheckSSN_USCORENEW;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CheckSSN_USCORENEW */
        long soap_type() const { return SOAP_TYPE___ns1__CheckSSN_USCORENEW; }
        /** Constructor with member initializations */
        __ns1__CheckSSN_USCORENEW() : ns1__CheckSSN_USCORENEW() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__CheckSSN_USCORENEW * SOAP_FMAC2 soap_instantiate___ns1__CheckSSN_USCORENEW(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:1599 */
#ifndef SOAP_TYPE___ns1__Binding
#define SOAP_TYPE___ns1__Binding (71)
/* Wrapper: */
struct SOAP_CMAC __ns1__Binding {
      public:
        /** Optional element 'ns1:Binding' of XSD type 'ns1:Binding' */
        _ns1__Binding *ns1__Binding;
      public:
        /** Return unique type id SOAP_TYPE___ns1__Binding */
        long soap_type() const { return SOAP_TYPE___ns1__Binding; }
        /** Constructor with member initializations */
        __ns1__Binding() : ns1__Binding() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__Binding * SOAP_FMAC2 soap_instantiate___ns1__Binding(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:1669 */
#ifndef SOAP_TYPE___ns1__QueryBinding
#define SOAP_TYPE___ns1__QueryBinding (75)
/* Wrapper: */
struct SOAP_CMAC __ns1__QueryBinding {
      public:
        /** Optional element 'ns1:QueryBinding' of XSD type 'ns1:QueryBinding' */
        _ns1__QueryBinding *ns1__QueryBinding;
      public:
        /** Return unique type id SOAP_TYPE___ns1__QueryBinding */
        long soap_type() const { return SOAP_TYPE___ns1__QueryBinding; }
        /** Constructor with member initializations */
        __ns1__QueryBinding() : ns1__QueryBinding() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__QueryBinding * SOAP_FMAC2 soap_instantiate___ns1__QueryBinding(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:1739 */
#ifndef SOAP_TYPE___ns1__SfcTestResult_USCOREUpload
#define SOAP_TYPE___ns1__SfcTestResult_USCOREUpload (79)
/* Wrapper: */
struct SOAP_CMAC __ns1__SfcTestResult_USCOREUpload {
      public:
        /** Optional element 'ns1:SfcTestResult_Upload' of XSD type 'ns1:SfcTestResult_Upload' */
        _ns1__SfcTestResult_USCOREUpload *ns1__SfcTestResult_USCOREUpload;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SfcTestResult_USCOREUpload */
        long soap_type() const { return SOAP_TYPE___ns1__SfcTestResult_USCOREUpload; }
        /** Constructor with member initializations */
        __ns1__SfcTestResult_USCOREUpload() : ns1__SfcTestResult_USCOREUpload() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SfcTestResult_USCOREUpload * SOAP_FMAC2 soap_instantiate___ns1__SfcTestResult_USCOREUpload(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:1809 */
#ifndef SOAP_TYPE___ns1__SaveSSN_USCORENEW
#define SOAP_TYPE___ns1__SaveSSN_USCORENEW (83)
/* Wrapper: */
struct SOAP_CMAC __ns1__SaveSSN_USCORENEW {
      public:
        /** Optional element 'ns1:SaveSSN_NEW' of XSD type 'ns1:SaveSSN_NEW' */
        _ns1__SaveSSN_USCORENEW *ns1__SaveSSN_USCORENEW;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SaveSSN_USCORENEW */
        long soap_type() const { return SOAP_TYPE___ns1__SaveSSN_USCORENEW; }
        /** Constructor with member initializations */
        __ns1__SaveSSN_USCORENEW() : ns1__SaveSSN_USCORENEW() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SaveSSN_USCORENEW * SOAP_FMAC2 soap_instantiate___ns1__SaveSSN_USCORENEW(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:1879 */
#ifndef SOAP_TYPE___ns1__test
#define SOAP_TYPE___ns1__test (87)
/* Wrapper: */
struct SOAP_CMAC __ns1__test {
      public:
        /** Optional element 'ns1:test' of XSD type 'ns1:test' */
        _ns1__test *ns1__test;
      public:
        /** Return unique type id SOAP_TYPE___ns1__test */
        long soap_type() const { return SOAP_TYPE___ns1__test; }
        /** Constructor with member initializations */
        __ns1__test() : ns1__test() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__test * SOAP_FMAC2 soap_instantiate___ns1__test(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:1949 */
#ifndef SOAP_TYPE___ns1__GETMACID
#define SOAP_TYPE___ns1__GETMACID (91)
/* Wrapper: */
struct SOAP_CMAC __ns1__GETMACID {
      public:
        /** Optional element 'ns1:GETMACID' of XSD type 'ns1:GETMACID' */
        _ns1__GETMACID *ns1__GETMACID;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GETMACID */
        long soap_type() const { return SOAP_TYPE___ns1__GETMACID; }
        /** Constructor with member initializations */
        __ns1__GETMACID() : ns1__GETMACID() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GETMACID * SOAP_FMAC2 soap_instantiate___ns1__GETMACID(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:2019 */
#ifndef SOAP_TYPE___ns1__GetMacBySn
#define SOAP_TYPE___ns1__GetMacBySn (95)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetMacBySn {
      public:
        /** Optional element 'ns1:GetMacBySn' of XSD type 'ns1:GetMacBySn' */
        _ns1__GetMacBySn *ns1__GetMacBySn;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetMacBySn */
        long soap_type() const { return SOAP_TYPE___ns1__GetMacBySn; }
        /** Constructor with member initializations */
        __ns1__GetMacBySn() : ns1__GetMacBySn() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetMacBySn * SOAP_FMAC2 soap_instantiate___ns1__GetMacBySn(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:2089 */
#ifndef SOAP_TYPE___ns1__CartonWeight_USCOREUpload
#define SOAP_TYPE___ns1__CartonWeight_USCOREUpload (99)
/* Wrapper: */
struct SOAP_CMAC __ns1__CartonWeight_USCOREUpload {
      public:
        /** Optional element 'ns1:CartonWeight_Upload' of XSD type 'ns1:CartonWeight_Upload' */
        _ns1__CartonWeight_USCOREUpload *ns1__CartonWeight_USCOREUpload;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CartonWeight_USCOREUpload */
        long soap_type() const { return SOAP_TYPE___ns1__CartonWeight_USCOREUpload; }
        /** Constructor with member initializations */
        __ns1__CartonWeight_USCOREUpload() : ns1__CartonWeight_USCOREUpload() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__CartonWeight_USCOREUpload * SOAP_FMAC2 soap_instantiate___ns1__CartonWeight_USCOREUpload(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:2159 */
#ifndef SOAP_TYPE___ns1__PCBData_USCOREUpload
#define SOAP_TYPE___ns1__PCBData_USCOREUpload (103)
/* Wrapper: */
struct SOAP_CMAC __ns1__PCBData_USCOREUpload {
      public:
        /** Optional element 'ns1:PCBData_Upload' of XSD type 'ns1:PCBData_Upload' */
        _ns1__PCBData_USCOREUpload *ns1__PCBData_USCOREUpload;
      public:
        /** Return unique type id SOAP_TYPE___ns1__PCBData_USCOREUpload */
        long soap_type() const { return SOAP_TYPE___ns1__PCBData_USCOREUpload; }
        /** Constructor with member initializations */
        __ns1__PCBData_USCOREUpload() : ns1__PCBData_USCOREUpload() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__PCBData_USCOREUpload * SOAP_FMAC2 soap_instantiate___ns1__PCBData_USCOREUpload(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:2229 */
#ifndef SOAP_TYPE___ns1__GetShaoluKey
#define SOAP_TYPE___ns1__GetShaoluKey (107)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetShaoluKey {
      public:
        /** Optional element 'ns1:GetShaoluKey' of XSD type 'ns1:GetShaoluKey' */
        _ns1__GetShaoluKey *ns1__GetShaoluKey;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetShaoluKey */
        long soap_type() const { return SOAP_TYPE___ns1__GetShaoluKey; }
        /** Constructor with member initializations */
        __ns1__GetShaoluKey() : ns1__GetShaoluKey() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetShaoluKey * SOAP_FMAC2 soap_instantiate___ns1__GetShaoluKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:2299 */
#ifndef SOAP_TYPE___ns1__ReleaseKey
#define SOAP_TYPE___ns1__ReleaseKey (111)
/* Wrapper: */
struct SOAP_CMAC __ns1__ReleaseKey {
      public:
        /** Optional element 'ns1:ReleaseKey' of XSD type 'ns1:ReleaseKey' */
        _ns1__ReleaseKey *ns1__ReleaseKey;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ReleaseKey */
        long soap_type() const { return SOAP_TYPE___ns1__ReleaseKey; }
        /** Constructor with member initializations */
        __ns1__ReleaseKey() : ns1__ReleaseKey() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__ReleaseKey * SOAP_FMAC2 soap_instantiate___ns1__ReleaseKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:2369 */
#ifndef SOAP_TYPE___ns1__BindKey
#define SOAP_TYPE___ns1__BindKey (115)
/* Wrapper: */
struct SOAP_CMAC __ns1__BindKey {
      public:
        /** Optional element 'ns1:BindKey' of XSD type 'ns1:BindKey' */
        _ns1__BindKey *ns1__BindKey;
      public:
        /** Return unique type id SOAP_TYPE___ns1__BindKey */
        long soap_type() const { return SOAP_TYPE___ns1__BindKey; }
        /** Constructor with member initializations */
        __ns1__BindKey() : ns1__BindKey() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__BindKey * SOAP_FMAC2 soap_instantiate___ns1__BindKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:2439 */
#ifndef SOAP_TYPE___ns1__GetSparrowCheckData
#define SOAP_TYPE___ns1__GetSparrowCheckData (119)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetSparrowCheckData {
      public:
        /** Optional element 'ns1:GetSparrowCheckData' of XSD type 'ns1:GetSparrowCheckData' */
        _ns1__GetSparrowCheckData *ns1__GetSparrowCheckData;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetSparrowCheckData */
        long soap_type() const { return SOAP_TYPE___ns1__GetSparrowCheckData; }
        /** Constructor with member initializations */
        __ns1__GetSparrowCheckData() : ns1__GetSparrowCheckData() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetSparrowCheckData * SOAP_FMAC2 soap_instantiate___ns1__GetSparrowCheckData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:2509 */
#ifndef SOAP_TYPE___ns1__BlindKeyNum
#define SOAP_TYPE___ns1__BlindKeyNum (123)
/* Wrapper: */
struct SOAP_CMAC __ns1__BlindKeyNum {
      public:
        /** Optional element 'ns1:BlindKeyNum' of XSD type 'ns1:BlindKeyNum' */
        _ns1__BlindKeyNum *ns1__BlindKeyNum;
      public:
        /** Return unique type id SOAP_TYPE___ns1__BlindKeyNum */
        long soap_type() const { return SOAP_TYPE___ns1__BlindKeyNum; }
        /** Constructor with member initializations */
        __ns1__BlindKeyNum() : ns1__BlindKeyNum() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__BlindKeyNum * SOAP_FMAC2 soap_instantiate___ns1__BlindKeyNum(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:2579 */
#ifndef SOAP_TYPE___ns1__DoFunction_
#define SOAP_TYPE___ns1__DoFunction_ (125)
/* Wrapper: */
struct SOAP_CMAC __ns1__DoFunction_ {
      public:
        /** Optional element 'ns1:DoFunction' of XSD type 'ns1:DoFunction' */
        _ns1__DoFunction *ns1__DoFunction;
      public:
        /** Return unique type id SOAP_TYPE___ns1__DoFunction_ */
        long soap_type() const { return SOAP_TYPE___ns1__DoFunction_; }
        /** Constructor with member initializations */
        __ns1__DoFunction_() : ns1__DoFunction() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__DoFunction_ * SOAP_FMAC2 soap_instantiate___ns1__DoFunction_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:2649 */
#ifndef SOAP_TYPE___ns1__UploadTestResult_
#define SOAP_TYPE___ns1__UploadTestResult_ (127)
/* Wrapper: */
struct SOAP_CMAC __ns1__UploadTestResult_ {
      public:
        /** Optional element 'ns1:UploadTestResult' of XSD type 'ns1:UploadTestResult' */
        _ns1__UploadTestResult *ns1__UploadTestResult;
      public:
        /** Return unique type id SOAP_TYPE___ns1__UploadTestResult_ */
        long soap_type() const { return SOAP_TYPE___ns1__UploadTestResult_; }
        /** Constructor with member initializations */
        __ns1__UploadTestResult_() : ns1__UploadTestResult() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__UploadTestResult_ * SOAP_FMAC2 soap_instantiate___ns1__UploadTestResult_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:2719 */
#ifndef SOAP_TYPE___ns1__CheckSSN_
#define SOAP_TYPE___ns1__CheckSSN_ (129)
/* Wrapper: */
struct SOAP_CMAC __ns1__CheckSSN_ {
      public:
        /** Optional element 'ns1:CheckSSN' of XSD type 'ns1:CheckSSN' */
        _ns1__CheckSSN *ns1__CheckSSN;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CheckSSN_ */
        long soap_type() const { return SOAP_TYPE___ns1__CheckSSN_; }
        /** Constructor with member initializations */
        __ns1__CheckSSN_() : ns1__CheckSSN() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__CheckSSN_ * SOAP_FMAC2 soap_instantiate___ns1__CheckSSN_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:2789 */
#ifndef SOAP_TYPE___ns1__CheckSSN_USCORENEW_
#define SOAP_TYPE___ns1__CheckSSN_USCORENEW_ (131)
/* Wrapper: */
struct SOAP_CMAC __ns1__CheckSSN_USCORENEW_ {
      public:
        /** Optional element 'ns1:CheckSSN_NEW' of XSD type 'ns1:CheckSSN_NEW' */
        _ns1__CheckSSN_USCORENEW *ns1__CheckSSN_USCORENEW;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CheckSSN_USCORENEW_ */
        long soap_type() const { return SOAP_TYPE___ns1__CheckSSN_USCORENEW_; }
        /** Constructor with member initializations */
        __ns1__CheckSSN_USCORENEW_() : ns1__CheckSSN_USCORENEW() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__CheckSSN_USCORENEW_ * SOAP_FMAC2 soap_instantiate___ns1__CheckSSN_USCORENEW_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:2859 */
#ifndef SOAP_TYPE___ns1__Binding_
#define SOAP_TYPE___ns1__Binding_ (133)
/* Wrapper: */
struct SOAP_CMAC __ns1__Binding_ {
      public:
        /** Optional element 'ns1:Binding' of XSD type 'ns1:Binding' */
        _ns1__Binding *ns1__Binding;
      public:
        /** Return unique type id SOAP_TYPE___ns1__Binding_ */
        long soap_type() const { return SOAP_TYPE___ns1__Binding_; }
        /** Constructor with member initializations */
        __ns1__Binding_() : ns1__Binding() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__Binding_ * SOAP_FMAC2 soap_instantiate___ns1__Binding_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:2929 */
#ifndef SOAP_TYPE___ns1__QueryBinding_
#define SOAP_TYPE___ns1__QueryBinding_ (135)
/* Wrapper: */
struct SOAP_CMAC __ns1__QueryBinding_ {
      public:
        /** Optional element 'ns1:QueryBinding' of XSD type 'ns1:QueryBinding' */
        _ns1__QueryBinding *ns1__QueryBinding;
      public:
        /** Return unique type id SOAP_TYPE___ns1__QueryBinding_ */
        long soap_type() const { return SOAP_TYPE___ns1__QueryBinding_; }
        /** Constructor with member initializations */
        __ns1__QueryBinding_() : ns1__QueryBinding() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__QueryBinding_ * SOAP_FMAC2 soap_instantiate___ns1__QueryBinding_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:2999 */
#ifndef SOAP_TYPE___ns1__SfcTestResult_USCOREUpload_
#define SOAP_TYPE___ns1__SfcTestResult_USCOREUpload_ (137)
/* Wrapper: */
struct SOAP_CMAC __ns1__SfcTestResult_USCOREUpload_ {
      public:
        /** Optional element 'ns1:SfcTestResult_Upload' of XSD type 'ns1:SfcTestResult_Upload' */
        _ns1__SfcTestResult_USCOREUpload *ns1__SfcTestResult_USCOREUpload;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SfcTestResult_USCOREUpload_ */
        long soap_type() const { return SOAP_TYPE___ns1__SfcTestResult_USCOREUpload_; }
        /** Constructor with member initializations */
        __ns1__SfcTestResult_USCOREUpload_() : ns1__SfcTestResult_USCOREUpload() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SfcTestResult_USCOREUpload_ * SOAP_FMAC2 soap_instantiate___ns1__SfcTestResult_USCOREUpload_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:3069 */
#ifndef SOAP_TYPE___ns1__SaveSSN_USCORENEW_
#define SOAP_TYPE___ns1__SaveSSN_USCORENEW_ (139)
/* Wrapper: */
struct SOAP_CMAC __ns1__SaveSSN_USCORENEW_ {
      public:
        /** Optional element 'ns1:SaveSSN_NEW' of XSD type 'ns1:SaveSSN_NEW' */
        _ns1__SaveSSN_USCORENEW *ns1__SaveSSN_USCORENEW;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SaveSSN_USCORENEW_ */
        long soap_type() const { return SOAP_TYPE___ns1__SaveSSN_USCORENEW_; }
        /** Constructor with member initializations */
        __ns1__SaveSSN_USCORENEW_() : ns1__SaveSSN_USCORENEW() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SaveSSN_USCORENEW_ * SOAP_FMAC2 soap_instantiate___ns1__SaveSSN_USCORENEW_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:3139 */
#ifndef SOAP_TYPE___ns1__test_
#define SOAP_TYPE___ns1__test_ (141)
/* Wrapper: */
struct SOAP_CMAC __ns1__test_ {
      public:
        /** Optional element 'ns1:test' of XSD type 'ns1:test' */
        _ns1__test *ns1__test;
      public:
        /** Return unique type id SOAP_TYPE___ns1__test_ */
        long soap_type() const { return SOAP_TYPE___ns1__test_; }
        /** Constructor with member initializations */
        __ns1__test_() : ns1__test() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__test_ * SOAP_FMAC2 soap_instantiate___ns1__test_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:3209 */
#ifndef SOAP_TYPE___ns1__GETMACID_
#define SOAP_TYPE___ns1__GETMACID_ (143)
/* Wrapper: */
struct SOAP_CMAC __ns1__GETMACID_ {
      public:
        /** Optional element 'ns1:GETMACID' of XSD type 'ns1:GETMACID' */
        _ns1__GETMACID *ns1__GETMACID;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GETMACID_ */
        long soap_type() const { return SOAP_TYPE___ns1__GETMACID_; }
        /** Constructor with member initializations */
        __ns1__GETMACID_() : ns1__GETMACID() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GETMACID_ * SOAP_FMAC2 soap_instantiate___ns1__GETMACID_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:3279 */
#ifndef SOAP_TYPE___ns1__GetMacBySn_
#define SOAP_TYPE___ns1__GetMacBySn_ (145)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetMacBySn_ {
      public:
        /** Optional element 'ns1:GetMacBySn' of XSD type 'ns1:GetMacBySn' */
        _ns1__GetMacBySn *ns1__GetMacBySn;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetMacBySn_ */
        long soap_type() const { return SOAP_TYPE___ns1__GetMacBySn_; }
        /** Constructor with member initializations */
        __ns1__GetMacBySn_() : ns1__GetMacBySn() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetMacBySn_ * SOAP_FMAC2 soap_instantiate___ns1__GetMacBySn_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:3349 */
#ifndef SOAP_TYPE___ns1__CartonWeight_USCOREUpload_
#define SOAP_TYPE___ns1__CartonWeight_USCOREUpload_ (147)
/* Wrapper: */
struct SOAP_CMAC __ns1__CartonWeight_USCOREUpload_ {
      public:
        /** Optional element 'ns1:CartonWeight_Upload' of XSD type 'ns1:CartonWeight_Upload' */
        _ns1__CartonWeight_USCOREUpload *ns1__CartonWeight_USCOREUpload;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CartonWeight_USCOREUpload_ */
        long soap_type() const { return SOAP_TYPE___ns1__CartonWeight_USCOREUpload_; }
        /** Constructor with member initializations */
        __ns1__CartonWeight_USCOREUpload_() : ns1__CartonWeight_USCOREUpload() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__CartonWeight_USCOREUpload_ * SOAP_FMAC2 soap_instantiate___ns1__CartonWeight_USCOREUpload_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:3419 */
#ifndef SOAP_TYPE___ns1__PCBData_USCOREUpload_
#define SOAP_TYPE___ns1__PCBData_USCOREUpload_ (149)
/* Wrapper: */
struct SOAP_CMAC __ns1__PCBData_USCOREUpload_ {
      public:
        /** Optional element 'ns1:PCBData_Upload' of XSD type 'ns1:PCBData_Upload' */
        _ns1__PCBData_USCOREUpload *ns1__PCBData_USCOREUpload;
      public:
        /** Return unique type id SOAP_TYPE___ns1__PCBData_USCOREUpload_ */
        long soap_type() const { return SOAP_TYPE___ns1__PCBData_USCOREUpload_; }
        /** Constructor with member initializations */
        __ns1__PCBData_USCOREUpload_() : ns1__PCBData_USCOREUpload() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__PCBData_USCOREUpload_ * SOAP_FMAC2 soap_instantiate___ns1__PCBData_USCOREUpload_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:3489 */
#ifndef SOAP_TYPE___ns1__GetShaoluKey_
#define SOAP_TYPE___ns1__GetShaoluKey_ (151)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetShaoluKey_ {
      public:
        /** Optional element 'ns1:GetShaoluKey' of XSD type 'ns1:GetShaoluKey' */
        _ns1__GetShaoluKey *ns1__GetShaoluKey;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetShaoluKey_ */
        long soap_type() const { return SOAP_TYPE___ns1__GetShaoluKey_; }
        /** Constructor with member initializations */
        __ns1__GetShaoluKey_() : ns1__GetShaoluKey() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetShaoluKey_ * SOAP_FMAC2 soap_instantiate___ns1__GetShaoluKey_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:3559 */
#ifndef SOAP_TYPE___ns1__ReleaseKey_
#define SOAP_TYPE___ns1__ReleaseKey_ (153)
/* Wrapper: */
struct SOAP_CMAC __ns1__ReleaseKey_ {
      public:
        /** Optional element 'ns1:ReleaseKey' of XSD type 'ns1:ReleaseKey' */
        _ns1__ReleaseKey *ns1__ReleaseKey;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ReleaseKey_ */
        long soap_type() const { return SOAP_TYPE___ns1__ReleaseKey_; }
        /** Constructor with member initializations */
        __ns1__ReleaseKey_() : ns1__ReleaseKey() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__ReleaseKey_ * SOAP_FMAC2 soap_instantiate___ns1__ReleaseKey_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:3629 */
#ifndef SOAP_TYPE___ns1__BindKey_
#define SOAP_TYPE___ns1__BindKey_ (155)
/* Wrapper: */
struct SOAP_CMAC __ns1__BindKey_ {
      public:
        /** Optional element 'ns1:BindKey' of XSD type 'ns1:BindKey' */
        _ns1__BindKey *ns1__BindKey;
      public:
        /** Return unique type id SOAP_TYPE___ns1__BindKey_ */
        long soap_type() const { return SOAP_TYPE___ns1__BindKey_; }
        /** Constructor with member initializations */
        __ns1__BindKey_() : ns1__BindKey() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__BindKey_ * SOAP_FMAC2 soap_instantiate___ns1__BindKey_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:3699 */
#ifndef SOAP_TYPE___ns1__GetSparrowCheckData_
#define SOAP_TYPE___ns1__GetSparrowCheckData_ (157)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetSparrowCheckData_ {
      public:
        /** Optional element 'ns1:GetSparrowCheckData' of XSD type 'ns1:GetSparrowCheckData' */
        _ns1__GetSparrowCheckData *ns1__GetSparrowCheckData;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetSparrowCheckData_ */
        long soap_type() const { return SOAP_TYPE___ns1__GetSparrowCheckData_; }
        /** Constructor with member initializations */
        __ns1__GetSparrowCheckData_() : ns1__GetSparrowCheckData() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetSparrowCheckData_ * SOAP_FMAC2 soap_instantiate___ns1__GetSparrowCheckData_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:3769 */
#ifndef SOAP_TYPE___ns1__BlindKeyNum_
#define SOAP_TYPE___ns1__BlindKeyNum_ (159)
/* Wrapper: */
struct SOAP_CMAC __ns1__BlindKeyNum_ {
      public:
        /** Optional element 'ns1:BlindKeyNum' of XSD type 'ns1:BlindKeyNum' */
        _ns1__BlindKeyNum *ns1__BlindKeyNum;
      public:
        /** Return unique type id SOAP_TYPE___ns1__BlindKeyNum_ */
        long soap_type() const { return SOAP_TYPE___ns1__BlindKeyNum_; }
        /** Constructor with member initializations */
        __ns1__BlindKeyNum_() : ns1__BlindKeyNum() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__BlindKeyNum_ * SOAP_FMAC2 soap_instantiate___ns1__BlindKeyNum_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* webservice.h:4370 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (160)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* webservice.h:4370 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (161)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XSD type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* webservice.h:4370 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (163)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_T assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* webservice.h:4370 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (166)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XSD type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* webservice.h:4370 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (167)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XSD type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XSD type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XSD type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XSD type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XSD type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XSD type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* (built-in):0 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
typedef char *_XML;
#endif

/* (built-in):0 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
typedef char *_QName;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* float has binding name 'float' for type 'xsd:float' */
#ifndef SOAP_TYPE_float
#define SOAP_TYPE_float (50)
#endif

/* time_t has binding name 'dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_dateTime
#define SOAP_TYPE_dateTime (47)
#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_bool
#define SOAP_TYPE_bool (51)
#endif

/* _ns1__GETMACIDResponse_GETMACIDResult has binding name '_ns1__GETMACIDResponse_GETMACIDResult' for type '' */
#ifndef SOAP_TYPE__ns1__GETMACIDResponse_GETMACIDResult
#define SOAP_TYPE__ns1__GETMACIDResponse_GETMACIDResult (48)
#endif

/* _ns1__BlindKeyNumResponse has binding name '_ns1__BlindKeyNumResponse' for type '' */
#ifndef SOAP_TYPE__ns1__BlindKeyNumResponse
#define SOAP_TYPE__ns1__BlindKeyNumResponse (43)
#endif

/* _ns1__BlindKeyNum has binding name '_ns1__BlindKeyNum' for type '' */
#ifndef SOAP_TYPE__ns1__BlindKeyNum
#define SOAP_TYPE__ns1__BlindKeyNum (42)
#endif

/* _ns1__GetSparrowCheckDataResponse has binding name '_ns1__GetSparrowCheckDataResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetSparrowCheckDataResponse
#define SOAP_TYPE__ns1__GetSparrowCheckDataResponse (41)
#endif

/* _ns1__GetSparrowCheckData has binding name '_ns1__GetSparrowCheckData' for type '' */
#ifndef SOAP_TYPE__ns1__GetSparrowCheckData
#define SOAP_TYPE__ns1__GetSparrowCheckData (40)
#endif

/* _ns1__BindKeyResponse has binding name '_ns1__BindKeyResponse' for type '' */
#ifndef SOAP_TYPE__ns1__BindKeyResponse
#define SOAP_TYPE__ns1__BindKeyResponse (39)
#endif

/* _ns1__BindKey has binding name '_ns1__BindKey' for type '' */
#ifndef SOAP_TYPE__ns1__BindKey
#define SOAP_TYPE__ns1__BindKey (38)
#endif

/* _ns1__ReleaseKeyResponse has binding name '_ns1__ReleaseKeyResponse' for type '' */
#ifndef SOAP_TYPE__ns1__ReleaseKeyResponse
#define SOAP_TYPE__ns1__ReleaseKeyResponse (37)
#endif

/* _ns1__ReleaseKey has binding name '_ns1__ReleaseKey' for type '' */
#ifndef SOAP_TYPE__ns1__ReleaseKey
#define SOAP_TYPE__ns1__ReleaseKey (36)
#endif

/* _ns1__GetShaoluKeyResponse has binding name '_ns1__GetShaoluKeyResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetShaoluKeyResponse
#define SOAP_TYPE__ns1__GetShaoluKeyResponse (35)
#endif

/* _ns1__GetShaoluKey has binding name '_ns1__GetShaoluKey' for type '' */
#ifndef SOAP_TYPE__ns1__GetShaoluKey
#define SOAP_TYPE__ns1__GetShaoluKey (34)
#endif

/* _ns1__PCBData_USCOREUploadResponse has binding name '_ns1__PCBData_USCOREUploadResponse' for type '' */
#ifndef SOAP_TYPE__ns1__PCBData_USCOREUploadResponse
#define SOAP_TYPE__ns1__PCBData_USCOREUploadResponse (33)
#endif

/* _ns1__PCBData_USCOREUpload has binding name '_ns1__PCBData_USCOREUpload' for type '' */
#ifndef SOAP_TYPE__ns1__PCBData_USCOREUpload
#define SOAP_TYPE__ns1__PCBData_USCOREUpload (32)
#endif

/* _ns1__CartonWeight_USCOREUploadResponse has binding name '_ns1__CartonWeight_USCOREUploadResponse' for type '' */
#ifndef SOAP_TYPE__ns1__CartonWeight_USCOREUploadResponse
#define SOAP_TYPE__ns1__CartonWeight_USCOREUploadResponse (31)
#endif

/* _ns1__CartonWeight_USCOREUpload has binding name '_ns1__CartonWeight_USCOREUpload' for type '' */
#ifndef SOAP_TYPE__ns1__CartonWeight_USCOREUpload
#define SOAP_TYPE__ns1__CartonWeight_USCOREUpload (30)
#endif

/* _ns1__GetMacBySnResponse has binding name '_ns1__GetMacBySnResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetMacBySnResponse
#define SOAP_TYPE__ns1__GetMacBySnResponse (29)
#endif

/* _ns1__GetMacBySn has binding name '_ns1__GetMacBySn' for type '' */
#ifndef SOAP_TYPE__ns1__GetMacBySn
#define SOAP_TYPE__ns1__GetMacBySn (28)
#endif

/* _ns1__GETMACIDResponse has binding name '_ns1__GETMACIDResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GETMACIDResponse
#define SOAP_TYPE__ns1__GETMACIDResponse (27)
#endif

/* _ns1__GETMACID has binding name '_ns1__GETMACID' for type '' */
#ifndef SOAP_TYPE__ns1__GETMACID
#define SOAP_TYPE__ns1__GETMACID (26)
#endif

/* _ns1__testResponse has binding name '_ns1__testResponse' for type '' */
#ifndef SOAP_TYPE__ns1__testResponse
#define SOAP_TYPE__ns1__testResponse (25)
#endif

/* _ns1__test has binding name '_ns1__test' for type '' */
#ifndef SOAP_TYPE__ns1__test
#define SOAP_TYPE__ns1__test (24)
#endif

/* _ns1__SaveSSN_USCORENEWResponse has binding name '_ns1__SaveSSN_USCORENEWResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SaveSSN_USCORENEWResponse
#define SOAP_TYPE__ns1__SaveSSN_USCORENEWResponse (23)
#endif

/* _ns1__SaveSSN_USCORENEW has binding name '_ns1__SaveSSN_USCORENEW' for type '' */
#ifndef SOAP_TYPE__ns1__SaveSSN_USCORENEW
#define SOAP_TYPE__ns1__SaveSSN_USCORENEW (22)
#endif

/* _ns1__SfcTestResult_USCOREUploadResponse has binding name '_ns1__SfcTestResult_USCOREUploadResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SfcTestResult_USCOREUploadResponse
#define SOAP_TYPE__ns1__SfcTestResult_USCOREUploadResponse (21)
#endif

/* _ns1__SfcTestResult_USCOREUpload has binding name '_ns1__SfcTestResult_USCOREUpload' for type '' */
#ifndef SOAP_TYPE__ns1__SfcTestResult_USCOREUpload
#define SOAP_TYPE__ns1__SfcTestResult_USCOREUpload (20)
#endif

/* _ns1__QueryBindingResponse has binding name '_ns1__QueryBindingResponse' for type '' */
#ifndef SOAP_TYPE__ns1__QueryBindingResponse
#define SOAP_TYPE__ns1__QueryBindingResponse (19)
#endif

/* _ns1__QueryBinding has binding name '_ns1__QueryBinding' for type '' */
#ifndef SOAP_TYPE__ns1__QueryBinding
#define SOAP_TYPE__ns1__QueryBinding (18)
#endif

/* _ns1__BindingResponse has binding name '_ns1__BindingResponse' for type '' */
#ifndef SOAP_TYPE__ns1__BindingResponse
#define SOAP_TYPE__ns1__BindingResponse (17)
#endif

/* _ns1__Binding has binding name '_ns1__Binding' for type '' */
#ifndef SOAP_TYPE__ns1__Binding
#define SOAP_TYPE__ns1__Binding (16)
#endif

/* _ns1__CheckSSN_USCORENEWResponse has binding name '_ns1__CheckSSN_USCORENEWResponse' for type '' */
#ifndef SOAP_TYPE__ns1__CheckSSN_USCORENEWResponse
#define SOAP_TYPE__ns1__CheckSSN_USCORENEWResponse (15)
#endif

/* _ns1__CheckSSN_USCORENEW has binding name '_ns1__CheckSSN_USCORENEW' for type '' */
#ifndef SOAP_TYPE__ns1__CheckSSN_USCORENEW
#define SOAP_TYPE__ns1__CheckSSN_USCORENEW (14)
#endif

/* _ns1__CheckSSNResponse has binding name '_ns1__CheckSSNResponse' for type '' */
#ifndef SOAP_TYPE__ns1__CheckSSNResponse
#define SOAP_TYPE__ns1__CheckSSNResponse (13)
#endif

/* _ns1__CheckSSN has binding name '_ns1__CheckSSN' for type '' */
#ifndef SOAP_TYPE__ns1__CheckSSN
#define SOAP_TYPE__ns1__CheckSSN (12)
#endif

/* _ns1__UploadTestResultResponse has binding name '_ns1__UploadTestResultResponse' for type '' */
#ifndef SOAP_TYPE__ns1__UploadTestResultResponse
#define SOAP_TYPE__ns1__UploadTestResultResponse (11)
#endif

/* _ns1__UploadTestResult has binding name '_ns1__UploadTestResult' for type '' */
#ifndef SOAP_TYPE__ns1__UploadTestResult
#define SOAP_TYPE__ns1__UploadTestResult (10)
#endif

/* _ns1__DoFunctionResponse has binding name '_ns1__DoFunctionResponse' for type '' */
#ifndef SOAP_TYPE__ns1__DoFunctionResponse
#define SOAP_TYPE__ns1__DoFunctionResponse (9)
#endif

/* _ns1__DoFunction has binding name '_ns1__DoFunction' for type '' */
#ifndef SOAP_TYPE__ns1__DoFunction
#define SOAP_TYPE__ns1__DoFunction (8)
#endif

/* ns1__ArrayOfAnyType has binding name 'ns1__ArrayOfAnyType' for type 'ns1:ArrayOfAnyType' */
#ifndef SOAP_TYPE_ns1__ArrayOfAnyType
#define SOAP_TYPE_ns1__ArrayOfAnyType (7)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (167)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (166)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (163)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (161)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (160)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (169)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (168)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (162)
#endif

/* _ns1__BlindKeyNum * has binding name 'PointerTo_ns1__BlindKeyNum' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__BlindKeyNum
#define SOAP_TYPE_PointerTo_ns1__BlindKeyNum (120)
#endif

/* _ns1__GetSparrowCheckData * has binding name 'PointerTo_ns1__GetSparrowCheckData' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetSparrowCheckData
#define SOAP_TYPE_PointerTo_ns1__GetSparrowCheckData (116)
#endif

/* _ns1__BindKey * has binding name 'PointerTo_ns1__BindKey' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__BindKey
#define SOAP_TYPE_PointerTo_ns1__BindKey (112)
#endif

/* _ns1__ReleaseKey * has binding name 'PointerTo_ns1__ReleaseKey' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__ReleaseKey
#define SOAP_TYPE_PointerTo_ns1__ReleaseKey (108)
#endif

/* _ns1__GetShaoluKey * has binding name 'PointerTo_ns1__GetShaoluKey' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetShaoluKey
#define SOAP_TYPE_PointerTo_ns1__GetShaoluKey (104)
#endif

/* _ns1__PCBData_USCOREUpload * has binding name 'PointerTo_ns1__PCBData_USCOREUpload' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__PCBData_USCOREUpload
#define SOAP_TYPE_PointerTo_ns1__PCBData_USCOREUpload (100)
#endif

/* _ns1__CartonWeight_USCOREUpload * has binding name 'PointerTo_ns1__CartonWeight_USCOREUpload' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__CartonWeight_USCOREUpload
#define SOAP_TYPE_PointerTo_ns1__CartonWeight_USCOREUpload (96)
#endif

/* _ns1__GetMacBySn * has binding name 'PointerTo_ns1__GetMacBySn' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetMacBySn
#define SOAP_TYPE_PointerTo_ns1__GetMacBySn (92)
#endif

/* _ns1__GETMACID * has binding name 'PointerTo_ns1__GETMACID' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GETMACID
#define SOAP_TYPE_PointerTo_ns1__GETMACID (88)
#endif

/* _ns1__test * has binding name 'PointerTo_ns1__test' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__test
#define SOAP_TYPE_PointerTo_ns1__test (84)
#endif

/* _ns1__SaveSSN_USCORENEW * has binding name 'PointerTo_ns1__SaveSSN_USCORENEW' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SaveSSN_USCORENEW
#define SOAP_TYPE_PointerTo_ns1__SaveSSN_USCORENEW (80)
#endif

/* _ns1__SfcTestResult_USCOREUpload * has binding name 'PointerTo_ns1__SfcTestResult_USCOREUpload' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SfcTestResult_USCOREUpload
#define SOAP_TYPE_PointerTo_ns1__SfcTestResult_USCOREUpload (76)
#endif

/* _ns1__QueryBinding * has binding name 'PointerTo_ns1__QueryBinding' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__QueryBinding
#define SOAP_TYPE_PointerTo_ns1__QueryBinding (72)
#endif

/* _ns1__Binding * has binding name 'PointerTo_ns1__Binding' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__Binding
#define SOAP_TYPE_PointerTo_ns1__Binding (68)
#endif

/* _ns1__CheckSSN_USCORENEW * has binding name 'PointerTo_ns1__CheckSSN_USCORENEW' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__CheckSSN_USCORENEW
#define SOAP_TYPE_PointerTo_ns1__CheckSSN_USCORENEW (64)
#endif

/* _ns1__CheckSSN * has binding name 'PointerTo_ns1__CheckSSN' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__CheckSSN
#define SOAP_TYPE_PointerTo_ns1__CheckSSN (60)
#endif

/* _ns1__UploadTestResult * has binding name 'PointerTo_ns1__UploadTestResult' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__UploadTestResult
#define SOAP_TYPE_PointerTo_ns1__UploadTestResult (56)
#endif

/* _ns1__DoFunction * has binding name 'PointerTo_ns1__DoFunction' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__DoFunction
#define SOAP_TYPE_PointerTo_ns1__DoFunction (52)
#endif

/* _ns1__GETMACIDResponse_GETMACIDResult * has binding name 'PointerTo_ns1__GETMACIDResponse_GETMACIDResult' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GETMACIDResponse_GETMACIDResult
#define SOAP_TYPE_PointerTo_ns1__GETMACIDResponse_GETMACIDResult (49)
#endif

/* ns1__ArrayOfAnyType * has binding name 'PointerTons1__ArrayOfAnyType' for type 'ns1:ArrayOfAnyType' */
#ifndef SOAP_TYPE_PointerTons1__ArrayOfAnyType
#define SOAP_TYPE_PointerTons1__ArrayOfAnyType (46)
#endif

/* char ** has binding name 'PointerTo_XML' for type '' */
#ifndef SOAP_TYPE_PointerTo_XML
#define SOAP_TYPE_PointerTo_XML (44)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
