/* soapC.cpp
   Generated by gSOAP 2.8.58 for webservice.h

gSOAP XML Web services tools
Copyright (C) 2000-2017, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "stdafx.h"
#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.58 2018-05-09 12:48:12 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_float:
		return soap_in_float(soap, NULL, NULL, "xsd:float");
	case SOAP_TYPE_dateTime:
		return soap_in_dateTime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns1__ArrayOfAnyType:
		return soap_in_ns1__ArrayOfAnyType(soap, NULL, NULL, "ns1:ArrayOfAnyType");
	case SOAP_TYPE_PointerTo_ns1__BlindKeyNum:
		return soap_in_PointerTo_ns1__BlindKeyNum(soap, NULL, NULL, "ns1:BlindKeyNum");
	case SOAP_TYPE_PointerTo_ns1__GetSparrowCheckData:
		return soap_in_PointerTo_ns1__GetSparrowCheckData(soap, NULL, NULL, "ns1:GetSparrowCheckData");
	case SOAP_TYPE_PointerTo_ns1__BindKey:
		return soap_in_PointerTo_ns1__BindKey(soap, NULL, NULL, "ns1:BindKey");
	case SOAP_TYPE_PointerTo_ns1__ReleaseKey:
		return soap_in_PointerTo_ns1__ReleaseKey(soap, NULL, NULL, "ns1:ReleaseKey");
	case SOAP_TYPE_PointerTo_ns1__GetShaoluKey:
		return soap_in_PointerTo_ns1__GetShaoluKey(soap, NULL, NULL, "ns1:GetShaoluKey");
	case SOAP_TYPE_PointerTo_ns1__PCBData_USCOREUpload:
		return soap_in_PointerTo_ns1__PCBData_USCOREUpload(soap, NULL, NULL, "ns1:PCBData_Upload");
	case SOAP_TYPE_PointerTo_ns1__CartonWeight_USCOREUpload:
		return soap_in_PointerTo_ns1__CartonWeight_USCOREUpload(soap, NULL, NULL, "ns1:CartonWeight_Upload");
	case SOAP_TYPE_PointerTo_ns1__GetMacBySn:
		return soap_in_PointerTo_ns1__GetMacBySn(soap, NULL, NULL, "ns1:GetMacBySn");
	case SOAP_TYPE_PointerTo_ns1__GETMACID:
		return soap_in_PointerTo_ns1__GETMACID(soap, NULL, NULL, "ns1:GETMACID");
	case SOAP_TYPE_PointerTo_ns1__test:
		return soap_in_PointerTo_ns1__test(soap, NULL, NULL, "ns1:test");
	case SOAP_TYPE_PointerTo_ns1__SaveSSN_USCORENEW:
		return soap_in_PointerTo_ns1__SaveSSN_USCORENEW(soap, NULL, NULL, "ns1:SaveSSN_NEW");
	case SOAP_TYPE_PointerTo_ns1__SfcTestResult_USCOREUpload:
		return soap_in_PointerTo_ns1__SfcTestResult_USCOREUpload(soap, NULL, NULL, "ns1:SfcTestResult_Upload");
	case SOAP_TYPE_PointerTo_ns1__QueryBinding:
		return soap_in_PointerTo_ns1__QueryBinding(soap, NULL, NULL, "ns1:QueryBinding");
	case SOAP_TYPE_PointerTo_ns1__Binding:
		return soap_in_PointerTo_ns1__Binding(soap, NULL, NULL, "ns1:Binding");
	case SOAP_TYPE_PointerTo_ns1__CheckSSN_USCORENEW:
		return soap_in_PointerTo_ns1__CheckSSN_USCORENEW(soap, NULL, NULL, "ns1:CheckSSN_NEW");
	case SOAP_TYPE_PointerTo_ns1__CheckSSN:
		return soap_in_PointerTo_ns1__CheckSSN(soap, NULL, NULL, "ns1:CheckSSN");
	case SOAP_TYPE_PointerTo_ns1__UploadTestResult:
		return soap_in_PointerTo_ns1__UploadTestResult(soap, NULL, NULL, "ns1:UploadTestResult");
	case SOAP_TYPE_PointerTo_ns1__DoFunction:
		return soap_in_PointerTo_ns1__DoFunction(soap, NULL, NULL, "ns1:DoFunction");
	case SOAP_TYPE_PointerTo_ns1__GETMACIDResponse_GETMACIDResult:
		return soap_in_PointerTo_ns1__GETMACIDResponse_GETMACIDResult(soap, NULL, NULL, "ns1:GETMACIDResponse-GETMACIDResult");
	case SOAP_TYPE_PointerTons1__ArrayOfAnyType:
		return soap_in_PointerTons1__ArrayOfAnyType(soap, NULL, NULL, "ns1:ArrayOfAnyType");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:ArrayOfAnyType"))
		{	*type = SOAP_TYPE_ns1__ArrayOfAnyType;
			return soap_in_ns1__ArrayOfAnyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_float;
			return soap_in_float(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_dateTime;
			return soap_in_dateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:GETMACIDResponse-GETMACIDResult"))
		{	*type = SOAP_TYPE__ns1__GETMACIDResponse_GETMACIDResult;
			return soap_in__ns1__GETMACIDResponse_GETMACIDResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BlindKeyNumResponse"))
		{	*type = SOAP_TYPE__ns1__BlindKeyNumResponse;
			return soap_in__ns1__BlindKeyNumResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BlindKeyNum"))
		{	*type = SOAP_TYPE__ns1__BlindKeyNum;
			return soap_in__ns1__BlindKeyNum(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetSparrowCheckDataResponse"))
		{	*type = SOAP_TYPE__ns1__GetSparrowCheckDataResponse;
			return soap_in__ns1__GetSparrowCheckDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetSparrowCheckData"))
		{	*type = SOAP_TYPE__ns1__GetSparrowCheckData;
			return soap_in__ns1__GetSparrowCheckData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BindKeyResponse"))
		{	*type = SOAP_TYPE__ns1__BindKeyResponse;
			return soap_in__ns1__BindKeyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BindKey"))
		{	*type = SOAP_TYPE__ns1__BindKey;
			return soap_in__ns1__BindKey(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ReleaseKeyResponse"))
		{	*type = SOAP_TYPE__ns1__ReleaseKeyResponse;
			return soap_in__ns1__ReleaseKeyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ReleaseKey"))
		{	*type = SOAP_TYPE__ns1__ReleaseKey;
			return soap_in__ns1__ReleaseKey(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetShaoluKeyResponse"))
		{	*type = SOAP_TYPE__ns1__GetShaoluKeyResponse;
			return soap_in__ns1__GetShaoluKeyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetShaoluKey"))
		{	*type = SOAP_TYPE__ns1__GetShaoluKey;
			return soap_in__ns1__GetShaoluKey(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PCBData_UploadResponse"))
		{	*type = SOAP_TYPE__ns1__PCBData_USCOREUploadResponse;
			return soap_in__ns1__PCBData_USCOREUploadResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PCBData_Upload"))
		{	*type = SOAP_TYPE__ns1__PCBData_USCOREUpload;
			return soap_in__ns1__PCBData_USCOREUpload(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CartonWeight_UploadResponse"))
		{	*type = SOAP_TYPE__ns1__CartonWeight_USCOREUploadResponse;
			return soap_in__ns1__CartonWeight_USCOREUploadResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CartonWeight_Upload"))
		{	*type = SOAP_TYPE__ns1__CartonWeight_USCOREUpload;
			return soap_in__ns1__CartonWeight_USCOREUpload(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetMacBySnResponse"))
		{	*type = SOAP_TYPE__ns1__GetMacBySnResponse;
			return soap_in__ns1__GetMacBySnResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetMacBySn"))
		{	*type = SOAP_TYPE__ns1__GetMacBySn;
			return soap_in__ns1__GetMacBySn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GETMACIDResponse"))
		{	*type = SOAP_TYPE__ns1__GETMACIDResponse;
			return soap_in__ns1__GETMACIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GETMACID"))
		{	*type = SOAP_TYPE__ns1__GETMACID;
			return soap_in__ns1__GETMACID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:testResponse"))
		{	*type = SOAP_TYPE__ns1__testResponse;
			return soap_in__ns1__testResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:test"))
		{	*type = SOAP_TYPE__ns1__test;
			return soap_in__ns1__test(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SaveSSN_NEWResponse"))
		{	*type = SOAP_TYPE__ns1__SaveSSN_USCORENEWResponse;
			return soap_in__ns1__SaveSSN_USCORENEWResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SaveSSN_NEW"))
		{	*type = SOAP_TYPE__ns1__SaveSSN_USCORENEW;
			return soap_in__ns1__SaveSSN_USCORENEW(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SfcTestResult_UploadResponse"))
		{	*type = SOAP_TYPE__ns1__SfcTestResult_USCOREUploadResponse;
			return soap_in__ns1__SfcTestResult_USCOREUploadResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SfcTestResult_Upload"))
		{	*type = SOAP_TYPE__ns1__SfcTestResult_USCOREUpload;
			return soap_in__ns1__SfcTestResult_USCOREUpload(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QueryBindingResponse"))
		{	*type = SOAP_TYPE__ns1__QueryBindingResponse;
			return soap_in__ns1__QueryBindingResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QueryBinding"))
		{	*type = SOAP_TYPE__ns1__QueryBinding;
			return soap_in__ns1__QueryBinding(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BindingResponse"))
		{	*type = SOAP_TYPE__ns1__BindingResponse;
			return soap_in__ns1__BindingResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Binding"))
		{	*type = SOAP_TYPE__ns1__Binding;
			return soap_in__ns1__Binding(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CheckSSN_NEWResponse"))
		{	*type = SOAP_TYPE__ns1__CheckSSN_USCORENEWResponse;
			return soap_in__ns1__CheckSSN_USCORENEWResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CheckSSN_NEW"))
		{	*type = SOAP_TYPE__ns1__CheckSSN_USCORENEW;
			return soap_in__ns1__CheckSSN_USCORENEW(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CheckSSNResponse"))
		{	*type = SOAP_TYPE__ns1__CheckSSNResponse;
			return soap_in__ns1__CheckSSNResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CheckSSN"))
		{	*type = SOAP_TYPE__ns1__CheckSSN;
			return soap_in__ns1__CheckSSN(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UploadTestResultResponse"))
		{	*type = SOAP_TYPE__ns1__UploadTestResultResponse;
			return soap_in__ns1__UploadTestResultResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UploadTestResult"))
		{	*type = SOAP_TYPE__ns1__UploadTestResult;
			return soap_in__ns1__UploadTestResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DoFunctionResponse"))
		{	*type = SOAP_TYPE__ns1__DoFunctionResponse;
			return soap_in__ns1__DoFunctionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DoFunction"))
		{	*type = SOAP_TYPE__ns1__DoFunction;
			return soap_in__ns1__DoFunction(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && !soap->fignore && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body && soap_ignore(soap))
				return soap->error;
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_float:
		return soap_out_float(soap, tag, id, (const float *)ptr, "xsd:float");
	case SOAP_TYPE_dateTime:
		return soap_out_dateTime(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE__ns1__GETMACIDResponse_GETMACIDResult:
		return ((_ns1__GETMACIDResponse_GETMACIDResult *)ptr)->soap_out(soap, "ns1:GETMACIDResponse-GETMACIDResult", id, "");
	case SOAP_TYPE__ns1__BlindKeyNumResponse:
		return ((_ns1__BlindKeyNumResponse *)ptr)->soap_out(soap, "ns1:BlindKeyNumResponse", id, "");
	case SOAP_TYPE__ns1__BlindKeyNum:
		return ((_ns1__BlindKeyNum *)ptr)->soap_out(soap, "ns1:BlindKeyNum", id, "");
	case SOAP_TYPE__ns1__GetSparrowCheckDataResponse:
		return ((_ns1__GetSparrowCheckDataResponse *)ptr)->soap_out(soap, "ns1:GetSparrowCheckDataResponse", id, "");
	case SOAP_TYPE__ns1__GetSparrowCheckData:
		return ((_ns1__GetSparrowCheckData *)ptr)->soap_out(soap, "ns1:GetSparrowCheckData", id, "");
	case SOAP_TYPE__ns1__BindKeyResponse:
		return ((_ns1__BindKeyResponse *)ptr)->soap_out(soap, "ns1:BindKeyResponse", id, "");
	case SOAP_TYPE__ns1__BindKey:
		return ((_ns1__BindKey *)ptr)->soap_out(soap, "ns1:BindKey", id, "");
	case SOAP_TYPE__ns1__ReleaseKeyResponse:
		return ((_ns1__ReleaseKeyResponse *)ptr)->soap_out(soap, "ns1:ReleaseKeyResponse", id, "");
	case SOAP_TYPE__ns1__ReleaseKey:
		return ((_ns1__ReleaseKey *)ptr)->soap_out(soap, "ns1:ReleaseKey", id, "");
	case SOAP_TYPE__ns1__GetShaoluKeyResponse:
		return ((_ns1__GetShaoluKeyResponse *)ptr)->soap_out(soap, "ns1:GetShaoluKeyResponse", id, "");
	case SOAP_TYPE__ns1__GetShaoluKey:
		return ((_ns1__GetShaoluKey *)ptr)->soap_out(soap, "ns1:GetShaoluKey", id, "");
	case SOAP_TYPE__ns1__PCBData_USCOREUploadResponse:
		return ((_ns1__PCBData_USCOREUploadResponse *)ptr)->soap_out(soap, "ns1:PCBData_UploadResponse", id, "");
	case SOAP_TYPE__ns1__PCBData_USCOREUpload:
		return ((_ns1__PCBData_USCOREUpload *)ptr)->soap_out(soap, "ns1:PCBData_Upload", id, "");
	case SOAP_TYPE__ns1__CartonWeight_USCOREUploadResponse:
		return ((_ns1__CartonWeight_USCOREUploadResponse *)ptr)->soap_out(soap, "ns1:CartonWeight_UploadResponse", id, "");
	case SOAP_TYPE__ns1__CartonWeight_USCOREUpload:
		return ((_ns1__CartonWeight_USCOREUpload *)ptr)->soap_out(soap, "ns1:CartonWeight_Upload", id, "");
	case SOAP_TYPE__ns1__GetMacBySnResponse:
		return ((_ns1__GetMacBySnResponse *)ptr)->soap_out(soap, "ns1:GetMacBySnResponse", id, "");
	case SOAP_TYPE__ns1__GetMacBySn:
		return ((_ns1__GetMacBySn *)ptr)->soap_out(soap, "ns1:GetMacBySn", id, "");
	case SOAP_TYPE__ns1__GETMACIDResponse:
		return ((_ns1__GETMACIDResponse *)ptr)->soap_out(soap, "ns1:GETMACIDResponse", id, "");
	case SOAP_TYPE__ns1__GETMACID:
		return ((_ns1__GETMACID *)ptr)->soap_out(soap, "ns1:GETMACID", id, "");
	case SOAP_TYPE__ns1__testResponse:
		return ((_ns1__testResponse *)ptr)->soap_out(soap, "ns1:testResponse", id, "");
	case SOAP_TYPE__ns1__test:
		return ((_ns1__test *)ptr)->soap_out(soap, "ns1:test", id, "");
	case SOAP_TYPE__ns1__SaveSSN_USCORENEWResponse:
		return ((_ns1__SaveSSN_USCORENEWResponse *)ptr)->soap_out(soap, "ns1:SaveSSN_NEWResponse", id, "");
	case SOAP_TYPE__ns1__SaveSSN_USCORENEW:
		return ((_ns1__SaveSSN_USCORENEW *)ptr)->soap_out(soap, "ns1:SaveSSN_NEW", id, "");
	case SOAP_TYPE__ns1__SfcTestResult_USCOREUploadResponse:
		return ((_ns1__SfcTestResult_USCOREUploadResponse *)ptr)->soap_out(soap, "ns1:SfcTestResult_UploadResponse", id, "");
	case SOAP_TYPE__ns1__SfcTestResult_USCOREUpload:
		return ((_ns1__SfcTestResult_USCOREUpload *)ptr)->soap_out(soap, "ns1:SfcTestResult_Upload", id, "");
	case SOAP_TYPE__ns1__QueryBindingResponse:
		return ((_ns1__QueryBindingResponse *)ptr)->soap_out(soap, "ns1:QueryBindingResponse", id, "");
	case SOAP_TYPE__ns1__QueryBinding:
		return ((_ns1__QueryBinding *)ptr)->soap_out(soap, "ns1:QueryBinding", id, "");
	case SOAP_TYPE__ns1__BindingResponse:
		return ((_ns1__BindingResponse *)ptr)->soap_out(soap, "ns1:BindingResponse", id, "");
	case SOAP_TYPE__ns1__Binding:
		return ((_ns1__Binding *)ptr)->soap_out(soap, "ns1:Binding", id, "");
	case SOAP_TYPE__ns1__CheckSSN_USCORENEWResponse:
		return ((_ns1__CheckSSN_USCORENEWResponse *)ptr)->soap_out(soap, "ns1:CheckSSN_NEWResponse", id, "");
	case SOAP_TYPE__ns1__CheckSSN_USCORENEW:
		return ((_ns1__CheckSSN_USCORENEW *)ptr)->soap_out(soap, "ns1:CheckSSN_NEW", id, "");
	case SOAP_TYPE__ns1__CheckSSNResponse:
		return ((_ns1__CheckSSNResponse *)ptr)->soap_out(soap, "ns1:CheckSSNResponse", id, "");
	case SOAP_TYPE__ns1__CheckSSN:
		return ((_ns1__CheckSSN *)ptr)->soap_out(soap, "ns1:CheckSSN", id, "");
	case SOAP_TYPE__ns1__UploadTestResultResponse:
		return ((_ns1__UploadTestResultResponse *)ptr)->soap_out(soap, "ns1:UploadTestResultResponse", id, "");
	case SOAP_TYPE__ns1__UploadTestResult:
		return ((_ns1__UploadTestResult *)ptr)->soap_out(soap, "ns1:UploadTestResult", id, "");
	case SOAP_TYPE__ns1__DoFunctionResponse:
		return ((_ns1__DoFunctionResponse *)ptr)->soap_out(soap, "ns1:DoFunctionResponse", id, "");
	case SOAP_TYPE__ns1__DoFunction:
		return ((_ns1__DoFunction *)ptr)->soap_out(soap, "ns1:DoFunction", id, "");
	case SOAP_TYPE_ns1__ArrayOfAnyType:
		return ((ns1__ArrayOfAnyType *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfAnyType");
	case SOAP_TYPE_PointerTo_ns1__BlindKeyNum:
		return soap_out_PointerTo_ns1__BlindKeyNum(soap, tag, id, (_ns1__BlindKeyNum *const*)ptr, "ns1:BlindKeyNum");
	case SOAP_TYPE_PointerTo_ns1__GetSparrowCheckData:
		return soap_out_PointerTo_ns1__GetSparrowCheckData(soap, tag, id, (_ns1__GetSparrowCheckData *const*)ptr, "ns1:GetSparrowCheckData");
	case SOAP_TYPE_PointerTo_ns1__BindKey:
		return soap_out_PointerTo_ns1__BindKey(soap, tag, id, (_ns1__BindKey *const*)ptr, "ns1:BindKey");
	case SOAP_TYPE_PointerTo_ns1__ReleaseKey:
		return soap_out_PointerTo_ns1__ReleaseKey(soap, tag, id, (_ns1__ReleaseKey *const*)ptr, "ns1:ReleaseKey");
	case SOAP_TYPE_PointerTo_ns1__GetShaoluKey:
		return soap_out_PointerTo_ns1__GetShaoluKey(soap, tag, id, (_ns1__GetShaoluKey *const*)ptr, "ns1:GetShaoluKey");
	case SOAP_TYPE_PointerTo_ns1__PCBData_USCOREUpload:
		return soap_out_PointerTo_ns1__PCBData_USCOREUpload(soap, tag, id, (_ns1__PCBData_USCOREUpload *const*)ptr, "ns1:PCBData_Upload");
	case SOAP_TYPE_PointerTo_ns1__CartonWeight_USCOREUpload:
		return soap_out_PointerTo_ns1__CartonWeight_USCOREUpload(soap, tag, id, (_ns1__CartonWeight_USCOREUpload *const*)ptr, "ns1:CartonWeight_Upload");
	case SOAP_TYPE_PointerTo_ns1__GetMacBySn:
		return soap_out_PointerTo_ns1__GetMacBySn(soap, tag, id, (_ns1__GetMacBySn *const*)ptr, "ns1:GetMacBySn");
	case SOAP_TYPE_PointerTo_ns1__GETMACID:
		return soap_out_PointerTo_ns1__GETMACID(soap, tag, id, (_ns1__GETMACID *const*)ptr, "ns1:GETMACID");
	case SOAP_TYPE_PointerTo_ns1__test:
		return soap_out_PointerTo_ns1__test(soap, tag, id, (_ns1__test *const*)ptr, "ns1:test");
	case SOAP_TYPE_PointerTo_ns1__SaveSSN_USCORENEW:
		return soap_out_PointerTo_ns1__SaveSSN_USCORENEW(soap, tag, id, (_ns1__SaveSSN_USCORENEW *const*)ptr, "ns1:SaveSSN_NEW");
	case SOAP_TYPE_PointerTo_ns1__SfcTestResult_USCOREUpload:
		return soap_out_PointerTo_ns1__SfcTestResult_USCOREUpload(soap, tag, id, (_ns1__SfcTestResult_USCOREUpload *const*)ptr, "ns1:SfcTestResult_Upload");
	case SOAP_TYPE_PointerTo_ns1__QueryBinding:
		return soap_out_PointerTo_ns1__QueryBinding(soap, tag, id, (_ns1__QueryBinding *const*)ptr, "ns1:QueryBinding");
	case SOAP_TYPE_PointerTo_ns1__Binding:
		return soap_out_PointerTo_ns1__Binding(soap, tag, id, (_ns1__Binding *const*)ptr, "ns1:Binding");
	case SOAP_TYPE_PointerTo_ns1__CheckSSN_USCORENEW:
		return soap_out_PointerTo_ns1__CheckSSN_USCORENEW(soap, tag, id, (_ns1__CheckSSN_USCORENEW *const*)ptr, "ns1:CheckSSN_NEW");
	case SOAP_TYPE_PointerTo_ns1__CheckSSN:
		return soap_out_PointerTo_ns1__CheckSSN(soap, tag, id, (_ns1__CheckSSN *const*)ptr, "ns1:CheckSSN");
	case SOAP_TYPE_PointerTo_ns1__UploadTestResult:
		return soap_out_PointerTo_ns1__UploadTestResult(soap, tag, id, (_ns1__UploadTestResult *const*)ptr, "ns1:UploadTestResult");
	case SOAP_TYPE_PointerTo_ns1__DoFunction:
		return soap_out_PointerTo_ns1__DoFunction(soap, tag, id, (_ns1__DoFunction *const*)ptr, "ns1:DoFunction");
	case SOAP_TYPE_PointerTo_ns1__GETMACIDResponse_GETMACIDResult:
		return soap_out_PointerTo_ns1__GETMACIDResponse_GETMACIDResult(soap, tag, id, (_ns1__GETMACIDResponse_GETMACIDResult *const*)ptr, "ns1:GETMACIDResponse-GETMACIDResult");
	case SOAP_TYPE_PointerTons1__ArrayOfAnyType:
		return soap_out_PointerTons1__ArrayOfAnyType(soap, tag, id, (ns1__ArrayOfAnyType *const*)ptr, "ns1:ArrayOfAnyType");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	case 0:
		return SOAP_OK;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_putelement '%s' failed for type %d in soapC.cpp\n", tag ? tag : "", type));
	return soap_element_empty(soap, tag); /* unknown type to serialize */
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__ns1__GETMACIDResponse_GETMACIDResult:
		((_ns1__GETMACIDResponse_GETMACIDResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__BlindKeyNumResponse:
		((_ns1__BlindKeyNumResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__BlindKeyNum:
		((_ns1__BlindKeyNum *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetSparrowCheckDataResponse:
		((_ns1__GetSparrowCheckDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetSparrowCheckData:
		((_ns1__GetSparrowCheckData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__BindKeyResponse:
		((_ns1__BindKeyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__BindKey:
		((_ns1__BindKey *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ReleaseKeyResponse:
		((_ns1__ReleaseKeyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ReleaseKey:
		((_ns1__ReleaseKey *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetShaoluKeyResponse:
		((_ns1__GetShaoluKeyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetShaoluKey:
		((_ns1__GetShaoluKey *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__PCBData_USCOREUploadResponse:
		((_ns1__PCBData_USCOREUploadResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__PCBData_USCOREUpload:
		((_ns1__PCBData_USCOREUpload *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CartonWeight_USCOREUploadResponse:
		((_ns1__CartonWeight_USCOREUploadResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CartonWeight_USCOREUpload:
		((_ns1__CartonWeight_USCOREUpload *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetMacBySnResponse:
		((_ns1__GetMacBySnResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetMacBySn:
		((_ns1__GetMacBySn *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GETMACIDResponse:
		((_ns1__GETMACIDResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GETMACID:
		((_ns1__GETMACID *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__testResponse:
		((_ns1__testResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__test:
		((_ns1__test *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SaveSSN_USCORENEWResponse:
		((_ns1__SaveSSN_USCORENEWResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SaveSSN_USCORENEW:
		((_ns1__SaveSSN_USCORENEW *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SfcTestResult_USCOREUploadResponse:
		((_ns1__SfcTestResult_USCOREUploadResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SfcTestResult_USCOREUpload:
		((_ns1__SfcTestResult_USCOREUpload *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__QueryBindingResponse:
		((_ns1__QueryBindingResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__QueryBinding:
		((_ns1__QueryBinding *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__BindingResponse:
		((_ns1__BindingResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__Binding:
		((_ns1__Binding *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CheckSSN_USCORENEWResponse:
		((_ns1__CheckSSN_USCORENEWResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CheckSSN_USCORENEW:
		((_ns1__CheckSSN_USCORENEW *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CheckSSNResponse:
		((_ns1__CheckSSNResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CheckSSN:
		((_ns1__CheckSSN *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UploadTestResultResponse:
		((_ns1__UploadTestResultResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UploadTestResult:
		((_ns1__UploadTestResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DoFunctionResponse:
		((_ns1__DoFunctionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DoFunction:
		((_ns1__DoFunction *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfAnyType:
		((ns1__ArrayOfAnyType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns1__BlindKeyNum_:
		soap_serialize___ns1__BlindKeyNum_(soap, (const struct __ns1__BlindKeyNum_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetSparrowCheckData_:
		soap_serialize___ns1__GetSparrowCheckData_(soap, (const struct __ns1__GetSparrowCheckData_ *)ptr);
		break;
	case SOAP_TYPE___ns1__BindKey_:
		soap_serialize___ns1__BindKey_(soap, (const struct __ns1__BindKey_ *)ptr);
		break;
	case SOAP_TYPE___ns1__ReleaseKey_:
		soap_serialize___ns1__ReleaseKey_(soap, (const struct __ns1__ReleaseKey_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetShaoluKey_:
		soap_serialize___ns1__GetShaoluKey_(soap, (const struct __ns1__GetShaoluKey_ *)ptr);
		break;
	case SOAP_TYPE___ns1__PCBData_USCOREUpload_:
		soap_serialize___ns1__PCBData_USCOREUpload_(soap, (const struct __ns1__PCBData_USCOREUpload_ *)ptr);
		break;
	case SOAP_TYPE___ns1__CartonWeight_USCOREUpload_:
		soap_serialize___ns1__CartonWeight_USCOREUpload_(soap, (const struct __ns1__CartonWeight_USCOREUpload_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetMacBySn_:
		soap_serialize___ns1__GetMacBySn_(soap, (const struct __ns1__GetMacBySn_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GETMACID_:
		soap_serialize___ns1__GETMACID_(soap, (const struct __ns1__GETMACID_ *)ptr);
		break;
	case SOAP_TYPE___ns1__test_:
		soap_serialize___ns1__test_(soap, (const struct __ns1__test_ *)ptr);
		break;
	case SOAP_TYPE___ns1__SaveSSN_USCORENEW_:
		soap_serialize___ns1__SaveSSN_USCORENEW_(soap, (const struct __ns1__SaveSSN_USCORENEW_ *)ptr);
		break;
	case SOAP_TYPE___ns1__SfcTestResult_USCOREUpload_:
		soap_serialize___ns1__SfcTestResult_USCOREUpload_(soap, (const struct __ns1__SfcTestResult_USCOREUpload_ *)ptr);
		break;
	case SOAP_TYPE___ns1__QueryBinding_:
		soap_serialize___ns1__QueryBinding_(soap, (const struct __ns1__QueryBinding_ *)ptr);
		break;
	case SOAP_TYPE___ns1__Binding_:
		soap_serialize___ns1__Binding_(soap, (const struct __ns1__Binding_ *)ptr);
		break;
	case SOAP_TYPE___ns1__CheckSSN_USCORENEW_:
		soap_serialize___ns1__CheckSSN_USCORENEW_(soap, (const struct __ns1__CheckSSN_USCORENEW_ *)ptr);
		break;
	case SOAP_TYPE___ns1__CheckSSN_:
		soap_serialize___ns1__CheckSSN_(soap, (const struct __ns1__CheckSSN_ *)ptr);
		break;
	case SOAP_TYPE___ns1__UploadTestResult_:
		soap_serialize___ns1__UploadTestResult_(soap, (const struct __ns1__UploadTestResult_ *)ptr);
		break;
	case SOAP_TYPE___ns1__DoFunction_:
		soap_serialize___ns1__DoFunction_(soap, (const struct __ns1__DoFunction_ *)ptr);
		break;
	case SOAP_TYPE___ns1__BlindKeyNum:
		soap_serialize___ns1__BlindKeyNum(soap, (const struct __ns1__BlindKeyNum *)ptr);
		break;
	case SOAP_TYPE___ns1__GetSparrowCheckData:
		soap_serialize___ns1__GetSparrowCheckData(soap, (const struct __ns1__GetSparrowCheckData *)ptr);
		break;
	case SOAP_TYPE___ns1__BindKey:
		soap_serialize___ns1__BindKey(soap, (const struct __ns1__BindKey *)ptr);
		break;
	case SOAP_TYPE___ns1__ReleaseKey:
		soap_serialize___ns1__ReleaseKey(soap, (const struct __ns1__ReleaseKey *)ptr);
		break;
	case SOAP_TYPE___ns1__GetShaoluKey:
		soap_serialize___ns1__GetShaoluKey(soap, (const struct __ns1__GetShaoluKey *)ptr);
		break;
	case SOAP_TYPE___ns1__PCBData_USCOREUpload:
		soap_serialize___ns1__PCBData_USCOREUpload(soap, (const struct __ns1__PCBData_USCOREUpload *)ptr);
		break;
	case SOAP_TYPE___ns1__CartonWeight_USCOREUpload:
		soap_serialize___ns1__CartonWeight_USCOREUpload(soap, (const struct __ns1__CartonWeight_USCOREUpload *)ptr);
		break;
	case SOAP_TYPE___ns1__GetMacBySn:
		soap_serialize___ns1__GetMacBySn(soap, (const struct __ns1__GetMacBySn *)ptr);
		break;
	case SOAP_TYPE___ns1__GETMACID:
		soap_serialize___ns1__GETMACID(soap, (const struct __ns1__GETMACID *)ptr);
		break;
	case SOAP_TYPE___ns1__test:
		soap_serialize___ns1__test(soap, (const struct __ns1__test *)ptr);
		break;
	case SOAP_TYPE___ns1__SaveSSN_USCORENEW:
		soap_serialize___ns1__SaveSSN_USCORENEW(soap, (const struct __ns1__SaveSSN_USCORENEW *)ptr);
		break;
	case SOAP_TYPE___ns1__SfcTestResult_USCOREUpload:
		soap_serialize___ns1__SfcTestResult_USCOREUpload(soap, (const struct __ns1__SfcTestResult_USCOREUpload *)ptr);
		break;
	case SOAP_TYPE___ns1__QueryBinding:
		soap_serialize___ns1__QueryBinding(soap, (const struct __ns1__QueryBinding *)ptr);
		break;
	case SOAP_TYPE___ns1__Binding:
		soap_serialize___ns1__Binding(soap, (const struct __ns1__Binding *)ptr);
		break;
	case SOAP_TYPE___ns1__CheckSSN_USCORENEW:
		soap_serialize___ns1__CheckSSN_USCORENEW(soap, (const struct __ns1__CheckSSN_USCORENEW *)ptr);
		break;
	case SOAP_TYPE___ns1__CheckSSN:
		soap_serialize___ns1__CheckSSN(soap, (const struct __ns1__CheckSSN *)ptr);
		break;
	case SOAP_TYPE___ns1__UploadTestResult:
		soap_serialize___ns1__UploadTestResult(soap, (const struct __ns1__UploadTestResult *)ptr);
		break;
	case SOAP_TYPE___ns1__DoFunction:
		soap_serialize___ns1__DoFunction(soap, (const struct __ns1__DoFunction *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__BlindKeyNum:
		soap_serialize_PointerTo_ns1__BlindKeyNum(soap, (_ns1__BlindKeyNum *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetSparrowCheckData:
		soap_serialize_PointerTo_ns1__GetSparrowCheckData(soap, (_ns1__GetSparrowCheckData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__BindKey:
		soap_serialize_PointerTo_ns1__BindKey(soap, (_ns1__BindKey *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ReleaseKey:
		soap_serialize_PointerTo_ns1__ReleaseKey(soap, (_ns1__ReleaseKey *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetShaoluKey:
		soap_serialize_PointerTo_ns1__GetShaoluKey(soap, (_ns1__GetShaoluKey *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__PCBData_USCOREUpload:
		soap_serialize_PointerTo_ns1__PCBData_USCOREUpload(soap, (_ns1__PCBData_USCOREUpload *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CartonWeight_USCOREUpload:
		soap_serialize_PointerTo_ns1__CartonWeight_USCOREUpload(soap, (_ns1__CartonWeight_USCOREUpload *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetMacBySn:
		soap_serialize_PointerTo_ns1__GetMacBySn(soap, (_ns1__GetMacBySn *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GETMACID:
		soap_serialize_PointerTo_ns1__GETMACID(soap, (_ns1__GETMACID *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__test:
		soap_serialize_PointerTo_ns1__test(soap, (_ns1__test *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SaveSSN_USCORENEW:
		soap_serialize_PointerTo_ns1__SaveSSN_USCORENEW(soap, (_ns1__SaveSSN_USCORENEW *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SfcTestResult_USCOREUpload:
		soap_serialize_PointerTo_ns1__SfcTestResult_USCOREUpload(soap, (_ns1__SfcTestResult_USCOREUpload *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__QueryBinding:
		soap_serialize_PointerTo_ns1__QueryBinding(soap, (_ns1__QueryBinding *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__Binding:
		soap_serialize_PointerTo_ns1__Binding(soap, (_ns1__Binding *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CheckSSN_USCORENEW:
		soap_serialize_PointerTo_ns1__CheckSSN_USCORENEW(soap, (_ns1__CheckSSN_USCORENEW *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CheckSSN:
		soap_serialize_PointerTo_ns1__CheckSSN(soap, (_ns1__CheckSSN *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UploadTestResult:
		soap_serialize_PointerTo_ns1__UploadTestResult(soap, (_ns1__UploadTestResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__DoFunction:
		soap_serialize_PointerTo_ns1__DoFunction(soap, (_ns1__DoFunction *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GETMACIDResponse_GETMACIDResult:
		soap_serialize_PointerTo_ns1__GETMACIDResponse_GETMACIDResult(soap, (_ns1__GETMACIDResponse_GETMACIDResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfAnyType:
		soap_serialize_PointerTons1__ArrayOfAnyType(soap, (ns1__ArrayOfAnyType *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_ns1__ArrayOfAnyType:
		return (void*)soap_instantiate_ns1__ArrayOfAnyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DoFunction:
		return (void*)soap_instantiate__ns1__DoFunction(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DoFunctionResponse:
		return (void*)soap_instantiate__ns1__DoFunctionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UploadTestResult:
		return (void*)soap_instantiate__ns1__UploadTestResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UploadTestResultResponse:
		return (void*)soap_instantiate__ns1__UploadTestResultResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CheckSSN:
		return (void*)soap_instantiate__ns1__CheckSSN(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CheckSSNResponse:
		return (void*)soap_instantiate__ns1__CheckSSNResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CheckSSN_USCORENEW:
		return (void*)soap_instantiate__ns1__CheckSSN_USCORENEW(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CheckSSN_USCORENEWResponse:
		return (void*)soap_instantiate__ns1__CheckSSN_USCORENEWResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__Binding:
		return (void*)soap_instantiate__ns1__Binding(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__BindingResponse:
		return (void*)soap_instantiate__ns1__BindingResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__QueryBinding:
		return (void*)soap_instantiate__ns1__QueryBinding(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__QueryBindingResponse:
		return (void*)soap_instantiate__ns1__QueryBindingResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SfcTestResult_USCOREUpload:
		return (void*)soap_instantiate__ns1__SfcTestResult_USCOREUpload(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SfcTestResult_USCOREUploadResponse:
		return (void*)soap_instantiate__ns1__SfcTestResult_USCOREUploadResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SaveSSN_USCORENEW:
		return (void*)soap_instantiate__ns1__SaveSSN_USCORENEW(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SaveSSN_USCORENEWResponse:
		return (void*)soap_instantiate__ns1__SaveSSN_USCORENEWResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__test:
		return (void*)soap_instantiate__ns1__test(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__testResponse:
		return (void*)soap_instantiate__ns1__testResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GETMACID:
		return (void*)soap_instantiate__ns1__GETMACID(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GETMACIDResponse_GETMACIDResult:
		return (void*)soap_instantiate__ns1__GETMACIDResponse_GETMACIDResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GETMACIDResponse:
		return (void*)soap_instantiate__ns1__GETMACIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetMacBySn:
		return (void*)soap_instantiate__ns1__GetMacBySn(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetMacBySnResponse:
		return (void*)soap_instantiate__ns1__GetMacBySnResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CartonWeight_USCOREUpload:
		return (void*)soap_instantiate__ns1__CartonWeight_USCOREUpload(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CartonWeight_USCOREUploadResponse:
		return (void*)soap_instantiate__ns1__CartonWeight_USCOREUploadResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__PCBData_USCOREUpload:
		return (void*)soap_instantiate__ns1__PCBData_USCOREUpload(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__PCBData_USCOREUploadResponse:
		return (void*)soap_instantiate__ns1__PCBData_USCOREUploadResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetShaoluKey:
		return (void*)soap_instantiate__ns1__GetShaoluKey(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetShaoluKeyResponse:
		return (void*)soap_instantiate__ns1__GetShaoluKeyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ReleaseKey:
		return (void*)soap_instantiate__ns1__ReleaseKey(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ReleaseKeyResponse:
		return (void*)soap_instantiate__ns1__ReleaseKeyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__BindKey:
		return (void*)soap_instantiate__ns1__BindKey(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__BindKeyResponse:
		return (void*)soap_instantiate__ns1__BindKeyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetSparrowCheckData:
		return (void*)soap_instantiate__ns1__GetSparrowCheckData(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetSparrowCheckDataResponse:
		return (void*)soap_instantiate__ns1__GetSparrowCheckDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__BlindKeyNum:
		return (void*)soap_instantiate__ns1__BlindKeyNum(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__BlindKeyNumResponse:
		return (void*)soap_instantiate__ns1__BlindKeyNumResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__DoFunction:
		return (void*)soap_instantiate___ns1__DoFunction(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UploadTestResult:
		return (void*)soap_instantiate___ns1__UploadTestResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CheckSSN:
		return (void*)soap_instantiate___ns1__CheckSSN(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CheckSSN_USCORENEW:
		return (void*)soap_instantiate___ns1__CheckSSN_USCORENEW(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Binding:
		return (void*)soap_instantiate___ns1__Binding(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__QueryBinding:
		return (void*)soap_instantiate___ns1__QueryBinding(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SfcTestResult_USCOREUpload:
		return (void*)soap_instantiate___ns1__SfcTestResult_USCOREUpload(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SaveSSN_USCORENEW:
		return (void*)soap_instantiate___ns1__SaveSSN_USCORENEW(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__test:
		return (void*)soap_instantiate___ns1__test(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GETMACID:
		return (void*)soap_instantiate___ns1__GETMACID(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetMacBySn:
		return (void*)soap_instantiate___ns1__GetMacBySn(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CartonWeight_USCOREUpload:
		return (void*)soap_instantiate___ns1__CartonWeight_USCOREUpload(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__PCBData_USCOREUpload:
		return (void*)soap_instantiate___ns1__PCBData_USCOREUpload(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetShaoluKey:
		return (void*)soap_instantiate___ns1__GetShaoluKey(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ReleaseKey:
		return (void*)soap_instantiate___ns1__ReleaseKey(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__BindKey:
		return (void*)soap_instantiate___ns1__BindKey(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetSparrowCheckData:
		return (void*)soap_instantiate___ns1__GetSparrowCheckData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__BlindKeyNum:
		return (void*)soap_instantiate___ns1__BlindKeyNum(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__DoFunction_:
		return (void*)soap_instantiate___ns1__DoFunction_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UploadTestResult_:
		return (void*)soap_instantiate___ns1__UploadTestResult_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CheckSSN_:
		return (void*)soap_instantiate___ns1__CheckSSN_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CheckSSN_USCORENEW_:
		return (void*)soap_instantiate___ns1__CheckSSN_USCORENEW_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Binding_:
		return (void*)soap_instantiate___ns1__Binding_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__QueryBinding_:
		return (void*)soap_instantiate___ns1__QueryBinding_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SfcTestResult_USCOREUpload_:
		return (void*)soap_instantiate___ns1__SfcTestResult_USCOREUpload_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SaveSSN_USCORENEW_:
		return (void*)soap_instantiate___ns1__SaveSSN_USCORENEW_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__test_:
		return (void*)soap_instantiate___ns1__test_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GETMACID_:
		return (void*)soap_instantiate___ns1__GETMACID_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetMacBySn_:
		return (void*)soap_instantiate___ns1__GetMacBySn_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CartonWeight_USCOREUpload_:
		return (void*)soap_instantiate___ns1__CartonWeight_USCOREUpload_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__PCBData_USCOREUpload_:
		return (void*)soap_instantiate___ns1__PCBData_USCOREUpload_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetShaoluKey_:
		return (void*)soap_instantiate___ns1__GetShaoluKey_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ReleaseKey_:
		return (void*)soap_instantiate___ns1__ReleaseKey_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__BindKey_:
		return (void*)soap_instantiate___ns1__BindKey_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetSparrowCheckData_:
		return (void*)soap_instantiate___ns1__GetSparrowCheckData_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__BlindKeyNum_:
		return (void*)soap_instantiate___ns1__BlindKeyNum_(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap *soap, struct soap_clist *p)
{	(void)soap; /* appease -Wall -Werror */
	if (!p->ptr)
		return SOAP_OK;
	switch (p->type)
	{
	case SOAP_TYPE_ns1__ArrayOfAnyType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ArrayOfAnyType*>(p->ptr), ns1__ArrayOfAnyType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ArrayOfAnyType*>(p->ptr), ns1__ArrayOfAnyType);
		break;
	case SOAP_TYPE__ns1__DoFunction:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__DoFunction*>(p->ptr), _ns1__DoFunction);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__DoFunction*>(p->ptr), _ns1__DoFunction);
		break;
	case SOAP_TYPE__ns1__DoFunctionResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__DoFunctionResponse*>(p->ptr), _ns1__DoFunctionResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__DoFunctionResponse*>(p->ptr), _ns1__DoFunctionResponse);
		break;
	case SOAP_TYPE__ns1__UploadTestResult:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__UploadTestResult*>(p->ptr), _ns1__UploadTestResult);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__UploadTestResult*>(p->ptr), _ns1__UploadTestResult);
		break;
	case SOAP_TYPE__ns1__UploadTestResultResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__UploadTestResultResponse*>(p->ptr), _ns1__UploadTestResultResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__UploadTestResultResponse*>(p->ptr), _ns1__UploadTestResultResponse);
		break;
	case SOAP_TYPE__ns1__CheckSSN:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__CheckSSN*>(p->ptr), _ns1__CheckSSN);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__CheckSSN*>(p->ptr), _ns1__CheckSSN);
		break;
	case SOAP_TYPE__ns1__CheckSSNResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__CheckSSNResponse*>(p->ptr), _ns1__CheckSSNResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__CheckSSNResponse*>(p->ptr), _ns1__CheckSSNResponse);
		break;
	case SOAP_TYPE__ns1__CheckSSN_USCORENEW:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__CheckSSN_USCORENEW*>(p->ptr), _ns1__CheckSSN_USCORENEW);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__CheckSSN_USCORENEW*>(p->ptr), _ns1__CheckSSN_USCORENEW);
		break;
	case SOAP_TYPE__ns1__CheckSSN_USCORENEWResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__CheckSSN_USCORENEWResponse*>(p->ptr), _ns1__CheckSSN_USCORENEWResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__CheckSSN_USCORENEWResponse*>(p->ptr), _ns1__CheckSSN_USCORENEWResponse);
		break;
	case SOAP_TYPE__ns1__Binding:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__Binding*>(p->ptr), _ns1__Binding);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__Binding*>(p->ptr), _ns1__Binding);
		break;
	case SOAP_TYPE__ns1__BindingResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__BindingResponse*>(p->ptr), _ns1__BindingResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__BindingResponse*>(p->ptr), _ns1__BindingResponse);
		break;
	case SOAP_TYPE__ns1__QueryBinding:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__QueryBinding*>(p->ptr), _ns1__QueryBinding);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__QueryBinding*>(p->ptr), _ns1__QueryBinding);
		break;
	case SOAP_TYPE__ns1__QueryBindingResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__QueryBindingResponse*>(p->ptr), _ns1__QueryBindingResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__QueryBindingResponse*>(p->ptr), _ns1__QueryBindingResponse);
		break;
	case SOAP_TYPE__ns1__SfcTestResult_USCOREUpload:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__SfcTestResult_USCOREUpload*>(p->ptr), _ns1__SfcTestResult_USCOREUpload);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__SfcTestResult_USCOREUpload*>(p->ptr), _ns1__SfcTestResult_USCOREUpload);
		break;
	case SOAP_TYPE__ns1__SfcTestResult_USCOREUploadResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__SfcTestResult_USCOREUploadResponse*>(p->ptr), _ns1__SfcTestResult_USCOREUploadResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__SfcTestResult_USCOREUploadResponse*>(p->ptr), _ns1__SfcTestResult_USCOREUploadResponse);
		break;
	case SOAP_TYPE__ns1__SaveSSN_USCORENEW:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__SaveSSN_USCORENEW*>(p->ptr), _ns1__SaveSSN_USCORENEW);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__SaveSSN_USCORENEW*>(p->ptr), _ns1__SaveSSN_USCORENEW);
		break;
	case SOAP_TYPE__ns1__SaveSSN_USCORENEWResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__SaveSSN_USCORENEWResponse*>(p->ptr), _ns1__SaveSSN_USCORENEWResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__SaveSSN_USCORENEWResponse*>(p->ptr), _ns1__SaveSSN_USCORENEWResponse);
		break;
	case SOAP_TYPE__ns1__test:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__test*>(p->ptr), _ns1__test);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__test*>(p->ptr), _ns1__test);
		break;
	case SOAP_TYPE__ns1__testResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__testResponse*>(p->ptr), _ns1__testResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__testResponse*>(p->ptr), _ns1__testResponse);
		break;
	case SOAP_TYPE__ns1__GETMACID:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GETMACID*>(p->ptr), _ns1__GETMACID);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GETMACID*>(p->ptr), _ns1__GETMACID);
		break;
	case SOAP_TYPE__ns1__GETMACIDResponse_GETMACIDResult:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GETMACIDResponse_GETMACIDResult*>(p->ptr), _ns1__GETMACIDResponse_GETMACIDResult);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GETMACIDResponse_GETMACIDResult*>(p->ptr), _ns1__GETMACIDResponse_GETMACIDResult);
		break;
	case SOAP_TYPE__ns1__GETMACIDResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GETMACIDResponse*>(p->ptr), _ns1__GETMACIDResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GETMACIDResponse*>(p->ptr), _ns1__GETMACIDResponse);
		break;
	case SOAP_TYPE__ns1__GetMacBySn:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetMacBySn*>(p->ptr), _ns1__GetMacBySn);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetMacBySn*>(p->ptr), _ns1__GetMacBySn);
		break;
	case SOAP_TYPE__ns1__GetMacBySnResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetMacBySnResponse*>(p->ptr), _ns1__GetMacBySnResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetMacBySnResponse*>(p->ptr), _ns1__GetMacBySnResponse);
		break;
	case SOAP_TYPE__ns1__CartonWeight_USCOREUpload:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__CartonWeight_USCOREUpload*>(p->ptr), _ns1__CartonWeight_USCOREUpload);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__CartonWeight_USCOREUpload*>(p->ptr), _ns1__CartonWeight_USCOREUpload);
		break;
	case SOAP_TYPE__ns1__CartonWeight_USCOREUploadResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__CartonWeight_USCOREUploadResponse*>(p->ptr), _ns1__CartonWeight_USCOREUploadResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__CartonWeight_USCOREUploadResponse*>(p->ptr), _ns1__CartonWeight_USCOREUploadResponse);
		break;
	case SOAP_TYPE__ns1__PCBData_USCOREUpload:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__PCBData_USCOREUpload*>(p->ptr), _ns1__PCBData_USCOREUpload);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__PCBData_USCOREUpload*>(p->ptr), _ns1__PCBData_USCOREUpload);
		break;
	case SOAP_TYPE__ns1__PCBData_USCOREUploadResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__PCBData_USCOREUploadResponse*>(p->ptr), _ns1__PCBData_USCOREUploadResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__PCBData_USCOREUploadResponse*>(p->ptr), _ns1__PCBData_USCOREUploadResponse);
		break;
	case SOAP_TYPE__ns1__GetShaoluKey:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetShaoluKey*>(p->ptr), _ns1__GetShaoluKey);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetShaoluKey*>(p->ptr), _ns1__GetShaoluKey);
		break;
	case SOAP_TYPE__ns1__GetShaoluKeyResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetShaoluKeyResponse*>(p->ptr), _ns1__GetShaoluKeyResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetShaoluKeyResponse*>(p->ptr), _ns1__GetShaoluKeyResponse);
		break;
	case SOAP_TYPE__ns1__ReleaseKey:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__ReleaseKey*>(p->ptr), _ns1__ReleaseKey);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__ReleaseKey*>(p->ptr), _ns1__ReleaseKey);
		break;
	case SOAP_TYPE__ns1__ReleaseKeyResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__ReleaseKeyResponse*>(p->ptr), _ns1__ReleaseKeyResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__ReleaseKeyResponse*>(p->ptr), _ns1__ReleaseKeyResponse);
		break;
	case SOAP_TYPE__ns1__BindKey:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__BindKey*>(p->ptr), _ns1__BindKey);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__BindKey*>(p->ptr), _ns1__BindKey);
		break;
	case SOAP_TYPE__ns1__BindKeyResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__BindKeyResponse*>(p->ptr), _ns1__BindKeyResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__BindKeyResponse*>(p->ptr), _ns1__BindKeyResponse);
		break;
	case SOAP_TYPE__ns1__GetSparrowCheckData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetSparrowCheckData*>(p->ptr), _ns1__GetSparrowCheckData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetSparrowCheckData*>(p->ptr), _ns1__GetSparrowCheckData);
		break;
	case SOAP_TYPE__ns1__GetSparrowCheckDataResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetSparrowCheckDataResponse*>(p->ptr), _ns1__GetSparrowCheckDataResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetSparrowCheckDataResponse*>(p->ptr), _ns1__GetSparrowCheckDataResponse);
		break;
	case SOAP_TYPE__ns1__BlindKeyNum:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__BlindKeyNum*>(p->ptr), _ns1__BlindKeyNum);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__BlindKeyNum*>(p->ptr), _ns1__BlindKeyNum);
		break;
	case SOAP_TYPE__ns1__BlindKeyNumResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__BlindKeyNumResponse*>(p->ptr), _ns1__BlindKeyNumResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__BlindKeyNumResponse*>(p->ptr), _ns1__BlindKeyNumResponse);
		break;
	case SOAP_TYPE___ns1__DoFunction:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__DoFunction*>(p->ptr), struct __ns1__DoFunction);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__DoFunction*>(p->ptr), struct __ns1__DoFunction);
		break;
	case SOAP_TYPE___ns1__UploadTestResult:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__UploadTestResult*>(p->ptr), struct __ns1__UploadTestResult);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__UploadTestResult*>(p->ptr), struct __ns1__UploadTestResult);
		break;
	case SOAP_TYPE___ns1__CheckSSN:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__CheckSSN*>(p->ptr), struct __ns1__CheckSSN);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__CheckSSN*>(p->ptr), struct __ns1__CheckSSN);
		break;
	case SOAP_TYPE___ns1__CheckSSN_USCORENEW:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__CheckSSN_USCORENEW*>(p->ptr), struct __ns1__CheckSSN_USCORENEW);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__CheckSSN_USCORENEW*>(p->ptr), struct __ns1__CheckSSN_USCORENEW);
		break;
	case SOAP_TYPE___ns1__Binding:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__Binding*>(p->ptr), struct __ns1__Binding);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__Binding*>(p->ptr), struct __ns1__Binding);
		break;
	case SOAP_TYPE___ns1__QueryBinding:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__QueryBinding*>(p->ptr), struct __ns1__QueryBinding);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__QueryBinding*>(p->ptr), struct __ns1__QueryBinding);
		break;
	case SOAP_TYPE___ns1__SfcTestResult_USCOREUpload:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__SfcTestResult_USCOREUpload*>(p->ptr), struct __ns1__SfcTestResult_USCOREUpload);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__SfcTestResult_USCOREUpload*>(p->ptr), struct __ns1__SfcTestResult_USCOREUpload);
		break;
	case SOAP_TYPE___ns1__SaveSSN_USCORENEW:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__SaveSSN_USCORENEW*>(p->ptr), struct __ns1__SaveSSN_USCORENEW);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__SaveSSN_USCORENEW*>(p->ptr), struct __ns1__SaveSSN_USCORENEW);
		break;
	case SOAP_TYPE___ns1__test:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__test*>(p->ptr), struct __ns1__test);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__test*>(p->ptr), struct __ns1__test);
		break;
	case SOAP_TYPE___ns1__GETMACID:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GETMACID*>(p->ptr), struct __ns1__GETMACID);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GETMACID*>(p->ptr), struct __ns1__GETMACID);
		break;
	case SOAP_TYPE___ns1__GetMacBySn:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetMacBySn*>(p->ptr), struct __ns1__GetMacBySn);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetMacBySn*>(p->ptr), struct __ns1__GetMacBySn);
		break;
	case SOAP_TYPE___ns1__CartonWeight_USCOREUpload:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__CartonWeight_USCOREUpload*>(p->ptr), struct __ns1__CartonWeight_USCOREUpload);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__CartonWeight_USCOREUpload*>(p->ptr), struct __ns1__CartonWeight_USCOREUpload);
		break;
	case SOAP_TYPE___ns1__PCBData_USCOREUpload:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__PCBData_USCOREUpload*>(p->ptr), struct __ns1__PCBData_USCOREUpload);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__PCBData_USCOREUpload*>(p->ptr), struct __ns1__PCBData_USCOREUpload);
		break;
	case SOAP_TYPE___ns1__GetShaoluKey:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetShaoluKey*>(p->ptr), struct __ns1__GetShaoluKey);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetShaoluKey*>(p->ptr), struct __ns1__GetShaoluKey);
		break;
	case SOAP_TYPE___ns1__ReleaseKey:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__ReleaseKey*>(p->ptr), struct __ns1__ReleaseKey);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__ReleaseKey*>(p->ptr), struct __ns1__ReleaseKey);
		break;
	case SOAP_TYPE___ns1__BindKey:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__BindKey*>(p->ptr), struct __ns1__BindKey);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__BindKey*>(p->ptr), struct __ns1__BindKey);
		break;
	case SOAP_TYPE___ns1__GetSparrowCheckData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetSparrowCheckData*>(p->ptr), struct __ns1__GetSparrowCheckData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetSparrowCheckData*>(p->ptr), struct __ns1__GetSparrowCheckData);
		break;
	case SOAP_TYPE___ns1__BlindKeyNum:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__BlindKeyNum*>(p->ptr), struct __ns1__BlindKeyNum);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__BlindKeyNum*>(p->ptr), struct __ns1__BlindKeyNum);
		break;
	case SOAP_TYPE___ns1__DoFunction_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__DoFunction_*>(p->ptr), struct __ns1__DoFunction_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__DoFunction_*>(p->ptr), struct __ns1__DoFunction_);
		break;
	case SOAP_TYPE___ns1__UploadTestResult_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__UploadTestResult_*>(p->ptr), struct __ns1__UploadTestResult_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__UploadTestResult_*>(p->ptr), struct __ns1__UploadTestResult_);
		break;
	case SOAP_TYPE___ns1__CheckSSN_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__CheckSSN_*>(p->ptr), struct __ns1__CheckSSN_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__CheckSSN_*>(p->ptr), struct __ns1__CheckSSN_);
		break;
	case SOAP_TYPE___ns1__CheckSSN_USCORENEW_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__CheckSSN_USCORENEW_*>(p->ptr), struct __ns1__CheckSSN_USCORENEW_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__CheckSSN_USCORENEW_*>(p->ptr), struct __ns1__CheckSSN_USCORENEW_);
		break;
	case SOAP_TYPE___ns1__Binding_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__Binding_*>(p->ptr), struct __ns1__Binding_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__Binding_*>(p->ptr), struct __ns1__Binding_);
		break;
	case SOAP_TYPE___ns1__QueryBinding_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__QueryBinding_*>(p->ptr), struct __ns1__QueryBinding_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__QueryBinding_*>(p->ptr), struct __ns1__QueryBinding_);
		break;
	case SOAP_TYPE___ns1__SfcTestResult_USCOREUpload_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__SfcTestResult_USCOREUpload_*>(p->ptr), struct __ns1__SfcTestResult_USCOREUpload_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__SfcTestResult_USCOREUpload_*>(p->ptr), struct __ns1__SfcTestResult_USCOREUpload_);
		break;
	case SOAP_TYPE___ns1__SaveSSN_USCORENEW_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__SaveSSN_USCORENEW_*>(p->ptr), struct __ns1__SaveSSN_USCORENEW_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__SaveSSN_USCORENEW_*>(p->ptr), struct __ns1__SaveSSN_USCORENEW_);
		break;
	case SOAP_TYPE___ns1__test_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__test_*>(p->ptr), struct __ns1__test_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__test_*>(p->ptr), struct __ns1__test_);
		break;
	case SOAP_TYPE___ns1__GETMACID_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GETMACID_*>(p->ptr), struct __ns1__GETMACID_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GETMACID_*>(p->ptr), struct __ns1__GETMACID_);
		break;
	case SOAP_TYPE___ns1__GetMacBySn_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetMacBySn_*>(p->ptr), struct __ns1__GetMacBySn_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetMacBySn_*>(p->ptr), struct __ns1__GetMacBySn_);
		break;
	case SOAP_TYPE___ns1__CartonWeight_USCOREUpload_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__CartonWeight_USCOREUpload_*>(p->ptr), struct __ns1__CartonWeight_USCOREUpload_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__CartonWeight_USCOREUpload_*>(p->ptr), struct __ns1__CartonWeight_USCOREUpload_);
		break;
	case SOAP_TYPE___ns1__PCBData_USCOREUpload_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__PCBData_USCOREUpload_*>(p->ptr), struct __ns1__PCBData_USCOREUpload_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__PCBData_USCOREUpload_*>(p->ptr), struct __ns1__PCBData_USCOREUpload_);
		break;
	case SOAP_TYPE___ns1__GetShaoluKey_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetShaoluKey_*>(p->ptr), struct __ns1__GetShaoluKey_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetShaoluKey_*>(p->ptr), struct __ns1__GetShaoluKey_);
		break;
	case SOAP_TYPE___ns1__ReleaseKey_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__ReleaseKey_*>(p->ptr), struct __ns1__ReleaseKey_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__ReleaseKey_*>(p->ptr), struct __ns1__ReleaseKey_);
		break;
	case SOAP_TYPE___ns1__BindKey_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__BindKey_*>(p->ptr), struct __ns1__BindKey_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__BindKey_*>(p->ptr), struct __ns1__BindKey_);
		break;
	case SOAP_TYPE___ns1__GetSparrowCheckData_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetSparrowCheckData_*>(p->ptr), struct __ns1__GetSparrowCheckData_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetSparrowCheckData_*>(p->ptr), struct __ns1__GetSparrowCheckData_);
		break;
	case SOAP_TYPE___ns1__BlindKeyNum_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__BlindKeyNum_*>(p->ptr), struct __ns1__BlindKeyNum_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__BlindKeyNum_*>(p->ptr), struct __ns1__BlindKeyNum_);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		break;
#endif
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_fbase(int t, int b)
{	(void)t; (void)b; /* appease -Wall -Werror */
	return 0;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_ns1__ArrayOfAnyType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ArrayOfAnyType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ArrayOfAnyType*)p = *(ns1__ArrayOfAnyType*)q;
		break;
	case SOAP_TYPE__ns1__DoFunction:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__DoFunction type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__DoFunction*)p = *(_ns1__DoFunction*)q;
		break;
	case SOAP_TYPE__ns1__DoFunctionResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__DoFunctionResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__DoFunctionResponse*)p = *(_ns1__DoFunctionResponse*)q;
		break;
	case SOAP_TYPE__ns1__UploadTestResult:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__UploadTestResult type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__UploadTestResult*)p = *(_ns1__UploadTestResult*)q;
		break;
	case SOAP_TYPE__ns1__UploadTestResultResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__UploadTestResultResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__UploadTestResultResponse*)p = *(_ns1__UploadTestResultResponse*)q;
		break;
	case SOAP_TYPE__ns1__CheckSSN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CheckSSN type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CheckSSN*)p = *(_ns1__CheckSSN*)q;
		break;
	case SOAP_TYPE__ns1__CheckSSNResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CheckSSNResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CheckSSNResponse*)p = *(_ns1__CheckSSNResponse*)q;
		break;
	case SOAP_TYPE__ns1__CheckSSN_USCORENEW:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CheckSSN_USCORENEW type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CheckSSN_USCORENEW*)p = *(_ns1__CheckSSN_USCORENEW*)q;
		break;
	case SOAP_TYPE__ns1__CheckSSN_USCORENEWResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CheckSSN_USCORENEWResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CheckSSN_USCORENEWResponse*)p = *(_ns1__CheckSSN_USCORENEWResponse*)q;
		break;
	case SOAP_TYPE__ns1__Binding:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__Binding type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__Binding*)p = *(_ns1__Binding*)q;
		break;
	case SOAP_TYPE__ns1__BindingResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__BindingResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__BindingResponse*)p = *(_ns1__BindingResponse*)q;
		break;
	case SOAP_TYPE__ns1__QueryBinding:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__QueryBinding type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__QueryBinding*)p = *(_ns1__QueryBinding*)q;
		break;
	case SOAP_TYPE__ns1__QueryBindingResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__QueryBindingResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__QueryBindingResponse*)p = *(_ns1__QueryBindingResponse*)q;
		break;
	case SOAP_TYPE__ns1__SfcTestResult_USCOREUpload:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SfcTestResult_USCOREUpload type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SfcTestResult_USCOREUpload*)p = *(_ns1__SfcTestResult_USCOREUpload*)q;
		break;
	case SOAP_TYPE__ns1__SfcTestResult_USCOREUploadResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SfcTestResult_USCOREUploadResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SfcTestResult_USCOREUploadResponse*)p = *(_ns1__SfcTestResult_USCOREUploadResponse*)q;
		break;
	case SOAP_TYPE__ns1__SaveSSN_USCORENEW:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SaveSSN_USCORENEW type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SaveSSN_USCORENEW*)p = *(_ns1__SaveSSN_USCORENEW*)q;
		break;
	case SOAP_TYPE__ns1__SaveSSN_USCORENEWResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SaveSSN_USCORENEWResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SaveSSN_USCORENEWResponse*)p = *(_ns1__SaveSSN_USCORENEWResponse*)q;
		break;
	case SOAP_TYPE__ns1__test:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__test type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__test*)p = *(_ns1__test*)q;
		break;
	case SOAP_TYPE__ns1__testResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__testResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__testResponse*)p = *(_ns1__testResponse*)q;
		break;
	case SOAP_TYPE__ns1__GETMACID:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GETMACID type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GETMACID*)p = *(_ns1__GETMACID*)q;
		break;
	case SOAP_TYPE__ns1__GETMACIDResponse_GETMACIDResult:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GETMACIDResponse_GETMACIDResult type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GETMACIDResponse_GETMACIDResult*)p = *(_ns1__GETMACIDResponse_GETMACIDResult*)q;
		break;
	case SOAP_TYPE__ns1__GETMACIDResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GETMACIDResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GETMACIDResponse*)p = *(_ns1__GETMACIDResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetMacBySn:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetMacBySn type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetMacBySn*)p = *(_ns1__GetMacBySn*)q;
		break;
	case SOAP_TYPE__ns1__GetMacBySnResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetMacBySnResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetMacBySnResponse*)p = *(_ns1__GetMacBySnResponse*)q;
		break;
	case SOAP_TYPE__ns1__CartonWeight_USCOREUpload:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CartonWeight_USCOREUpload type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CartonWeight_USCOREUpload*)p = *(_ns1__CartonWeight_USCOREUpload*)q;
		break;
	case SOAP_TYPE__ns1__CartonWeight_USCOREUploadResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CartonWeight_USCOREUploadResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CartonWeight_USCOREUploadResponse*)p = *(_ns1__CartonWeight_USCOREUploadResponse*)q;
		break;
	case SOAP_TYPE__ns1__PCBData_USCOREUpload:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__PCBData_USCOREUpload type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__PCBData_USCOREUpload*)p = *(_ns1__PCBData_USCOREUpload*)q;
		break;
	case SOAP_TYPE__ns1__PCBData_USCOREUploadResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__PCBData_USCOREUploadResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__PCBData_USCOREUploadResponse*)p = *(_ns1__PCBData_USCOREUploadResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetShaoluKey:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetShaoluKey type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetShaoluKey*)p = *(_ns1__GetShaoluKey*)q;
		break;
	case SOAP_TYPE__ns1__GetShaoluKeyResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetShaoluKeyResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetShaoluKeyResponse*)p = *(_ns1__GetShaoluKeyResponse*)q;
		break;
	case SOAP_TYPE__ns1__ReleaseKey:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ReleaseKey type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ReleaseKey*)p = *(_ns1__ReleaseKey*)q;
		break;
	case SOAP_TYPE__ns1__ReleaseKeyResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ReleaseKeyResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ReleaseKeyResponse*)p = *(_ns1__ReleaseKeyResponse*)q;
		break;
	case SOAP_TYPE__ns1__BindKey:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__BindKey type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__BindKey*)p = *(_ns1__BindKey*)q;
		break;
	case SOAP_TYPE__ns1__BindKeyResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__BindKeyResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__BindKeyResponse*)p = *(_ns1__BindKeyResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetSparrowCheckData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetSparrowCheckData type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetSparrowCheckData*)p = *(_ns1__GetSparrowCheckData*)q;
		break;
	case SOAP_TYPE__ns1__GetSparrowCheckDataResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetSparrowCheckDataResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetSparrowCheckDataResponse*)p = *(_ns1__GetSparrowCheckDataResponse*)q;
		break;
	case SOAP_TYPE__ns1__BlindKeyNum:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__BlindKeyNum type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__BlindKeyNum*)p = *(_ns1__BlindKeyNum*)q;
		break;
	case SOAP_TYPE__ns1__BlindKeyNumResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__BlindKeyNumResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__BlindKeyNumResponse*)p = *(_ns1__BlindKeyNumResponse*)q;
		break;
	case SOAP_TYPE___ns1__DoFunction:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__DoFunction type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__DoFunction*)p = *(struct __ns1__DoFunction*)q;
		break;
	case SOAP_TYPE___ns1__UploadTestResult:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__UploadTestResult type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__UploadTestResult*)p = *(struct __ns1__UploadTestResult*)q;
		break;
	case SOAP_TYPE___ns1__CheckSSN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CheckSSN type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CheckSSN*)p = *(struct __ns1__CheckSSN*)q;
		break;
	case SOAP_TYPE___ns1__CheckSSN_USCORENEW:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CheckSSN_USCORENEW type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CheckSSN_USCORENEW*)p = *(struct __ns1__CheckSSN_USCORENEW*)q;
		break;
	case SOAP_TYPE___ns1__Binding:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Binding type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Binding*)p = *(struct __ns1__Binding*)q;
		break;
	case SOAP_TYPE___ns1__QueryBinding:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__QueryBinding type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__QueryBinding*)p = *(struct __ns1__QueryBinding*)q;
		break;
	case SOAP_TYPE___ns1__SfcTestResult_USCOREUpload:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SfcTestResult_USCOREUpload type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SfcTestResult_USCOREUpload*)p = *(struct __ns1__SfcTestResult_USCOREUpload*)q;
		break;
	case SOAP_TYPE___ns1__SaveSSN_USCORENEW:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SaveSSN_USCORENEW type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SaveSSN_USCORENEW*)p = *(struct __ns1__SaveSSN_USCORENEW*)q;
		break;
	case SOAP_TYPE___ns1__test:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__test type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__test*)p = *(struct __ns1__test*)q;
		break;
	case SOAP_TYPE___ns1__GETMACID:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GETMACID type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GETMACID*)p = *(struct __ns1__GETMACID*)q;
		break;
	case SOAP_TYPE___ns1__GetMacBySn:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetMacBySn type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetMacBySn*)p = *(struct __ns1__GetMacBySn*)q;
		break;
	case SOAP_TYPE___ns1__CartonWeight_USCOREUpload:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CartonWeight_USCOREUpload type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CartonWeight_USCOREUpload*)p = *(struct __ns1__CartonWeight_USCOREUpload*)q;
		break;
	case SOAP_TYPE___ns1__PCBData_USCOREUpload:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__PCBData_USCOREUpload type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__PCBData_USCOREUpload*)p = *(struct __ns1__PCBData_USCOREUpload*)q;
		break;
	case SOAP_TYPE___ns1__GetShaoluKey:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetShaoluKey type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetShaoluKey*)p = *(struct __ns1__GetShaoluKey*)q;
		break;
	case SOAP_TYPE___ns1__ReleaseKey:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ReleaseKey type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ReleaseKey*)p = *(struct __ns1__ReleaseKey*)q;
		break;
	case SOAP_TYPE___ns1__BindKey:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__BindKey type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__BindKey*)p = *(struct __ns1__BindKey*)q;
		break;
	case SOAP_TYPE___ns1__GetSparrowCheckData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetSparrowCheckData type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetSparrowCheckData*)p = *(struct __ns1__GetSparrowCheckData*)q;
		break;
	case SOAP_TYPE___ns1__BlindKeyNum:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__BlindKeyNum type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__BlindKeyNum*)p = *(struct __ns1__BlindKeyNum*)q;
		break;
	case SOAP_TYPE___ns1__DoFunction_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__DoFunction_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__DoFunction_*)p = *(struct __ns1__DoFunction_*)q;
		break;
	case SOAP_TYPE___ns1__UploadTestResult_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__UploadTestResult_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__UploadTestResult_*)p = *(struct __ns1__UploadTestResult_*)q;
		break;
	case SOAP_TYPE___ns1__CheckSSN_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CheckSSN_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CheckSSN_*)p = *(struct __ns1__CheckSSN_*)q;
		break;
	case SOAP_TYPE___ns1__CheckSSN_USCORENEW_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CheckSSN_USCORENEW_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CheckSSN_USCORENEW_*)p = *(struct __ns1__CheckSSN_USCORENEW_*)q;
		break;
	case SOAP_TYPE___ns1__Binding_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Binding_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Binding_*)p = *(struct __ns1__Binding_*)q;
		break;
	case SOAP_TYPE___ns1__QueryBinding_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__QueryBinding_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__QueryBinding_*)p = *(struct __ns1__QueryBinding_*)q;
		break;
	case SOAP_TYPE___ns1__SfcTestResult_USCOREUpload_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SfcTestResult_USCOREUpload_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SfcTestResult_USCOREUpload_*)p = *(struct __ns1__SfcTestResult_USCOREUpload_*)q;
		break;
	case SOAP_TYPE___ns1__SaveSSN_USCORENEW_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SaveSSN_USCORENEW_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SaveSSN_USCORENEW_*)p = *(struct __ns1__SaveSSN_USCORENEW_*)q;
		break;
	case SOAP_TYPE___ns1__test_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__test_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__test_*)p = *(struct __ns1__test_*)q;
		break;
	case SOAP_TYPE___ns1__GETMACID_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GETMACID_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GETMACID_*)p = *(struct __ns1__GETMACID_*)q;
		break;
	case SOAP_TYPE___ns1__GetMacBySn_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetMacBySn_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetMacBySn_*)p = *(struct __ns1__GetMacBySn_*)q;
		break;
	case SOAP_TYPE___ns1__CartonWeight_USCOREUpload_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CartonWeight_USCOREUpload_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CartonWeight_USCOREUpload_*)p = *(struct __ns1__CartonWeight_USCOREUpload_*)q;
		break;
	case SOAP_TYPE___ns1__PCBData_USCOREUpload_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__PCBData_USCOREUpload_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__PCBData_USCOREUpload_*)p = *(struct __ns1__PCBData_USCOREUpload_*)q;
		break;
	case SOAP_TYPE___ns1__GetShaoluKey_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetShaoluKey_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetShaoluKey_*)p = *(struct __ns1__GetShaoluKey_*)q;
		break;
	case SOAP_TYPE___ns1__ReleaseKey_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ReleaseKey_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ReleaseKey_*)p = *(struct __ns1__ReleaseKey_*)q;
		break;
	case SOAP_TYPE___ns1__BindKey_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__BindKey_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__BindKey_*)p = *(struct __ns1__BindKey_*)q;
		break;
	case SOAP_TYPE___ns1__GetSparrowCheckData_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetSparrowCheckData_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetSparrowCheckData_*)p = *(struct __ns1__GetSparrowCheckData_*)q;
		break;
	case SOAP_TYPE___ns1__BlindKeyNum_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__BlindKeyNum_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__BlindKeyNum_*)p = *(struct __ns1__BlindKeyNum_*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *a = static_cast<char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char)));
	for (char *p = a; p && n--; ++p)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *a = static_cast<int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(int)));
	for (int *p = a; p && n--; ++p)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_float(struct soap *soap, const char *tag, int id, const float *a, const char *type)
{
	return soap_outfloat(soap, tag, id, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_in_float(struct soap *soap, const char *tag, float *a, const char *type)
{
	a = soap_infloat(soap, tag, a, type, SOAP_TYPE_float);
	return a;
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_new_float(struct soap *soap, int n)
{
	float *a = static_cast<float *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(float)));
	for (float *p = a; p && n--; ++p)
		soap_default_float(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_float(struct soap *soap, const float *a, const char *tag, const char *type)
{
	if (soap_out_float(soap, tag ? tag : "float", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_get_float(struct soap *soap, float *p, const char *tag, const char *type)
{
	if ((p = soap_in_float(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dateTime(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_dateTime);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_dateTime(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	a = soap_indateTime(soap, tag, a, type, SOAP_TYPE_dateTime);
	return a;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_new_dateTime(struct soap *soap, int n)
{
	time_t *a = static_cast<time_t *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(time_t)));
	for (time_t *p = a; p && n--; ++p)
		soap_default_dateTime(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dateTime(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	if (soap_out_dateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_dateTime(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (LONG64)false, "false" },
	{ (LONG64)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
	return soap_code_str(soap_codes_bool, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2bool(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_new_bool(struct soap *soap, int n)
{
	bool *a = static_cast<bool *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(bool)));
	for (bool *p = a; p && n--; ++p)
		soap_default_bool(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	if (soap_out_bool(soap, tag ? tag : "boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GETMACIDResponse_GETMACIDResult::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_ns1__GETMACIDResponse_GETMACIDResult::__size = 0;
	this->_ns1__GETMACIDResponse_GETMACIDResult::__any = NULL;
	this->_ns1__GETMACIDResponse_GETMACIDResult::__any_ = NULL;
}

void _ns1__GETMACIDResponse_GETMACIDResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__GETMACIDResponse_GETMACIDResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GETMACIDResponse_GETMACIDResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GETMACIDResponse_GETMACIDResult(struct soap *soap, const char *tag, int id, const _ns1__GETMACIDResponse_GETMACIDResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GETMACIDResponse_GETMACIDResult), type))
		return soap->error;
	if (a->_ns1__GETMACIDResponse_GETMACIDResult::__any)
	{	int i;
		for (i = 0; i < (int)a->_ns1__GETMACIDResponse_GETMACIDResult::__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->_ns1__GETMACIDResponse_GETMACIDResult::__any + i, ""))
				return soap->error;
	}
	if (soap_outliteral(soap, "-any", (char*const*)&a->_ns1__GETMACIDResponse_GETMACIDResult::__any_, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GETMACIDResponse_GETMACIDResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GETMACIDResponse_GETMACIDResult(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GETMACIDResponse_GETMACIDResult * SOAP_FMAC4 soap_in__ns1__GETMACIDResponse_GETMACIDResult(struct soap *soap, const char *tag, _ns1__GETMACIDResponse_GETMACIDResult *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GETMACIDResponse_GETMACIDResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GETMACIDResponse_GETMACIDResult, sizeof(_ns1__GETMACIDResponse_GETMACIDResult), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GETMACIDResponse_GETMACIDResult)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GETMACIDResponse_GETMACIDResult *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	struct soap_blist *soap_blist___any1 = NULL;
	size_t soap_flag___any_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->_ns1__GETMACIDResponse_GETMACIDResult::__any == NULL)
				{	if (soap_blist___any1 == NULL)
						soap_blist___any1 = soap_alloc_block(soap);
					a->_ns1__GETMACIDResponse_GETMACIDResult::__any = (char *)soap_push_block_max(soap, soap_blist___any1, sizeof(char));
					if (a->_ns1__GETMACIDResponse_GETMACIDResult::__any == NULL)
						return NULL;
					soap_default_byte(soap, a->_ns1__GETMACIDResponse_GETMACIDResult::__any);
				}
				if (soap_in_byte(soap, "-any", a->_ns1__GETMACIDResponse_GETMACIDResult::__any, "xsd:byte"))
				{	a->_ns1__GETMACIDResponse_GETMACIDResult::__size++;
					a->_ns1__GETMACIDResponse_GETMACIDResult::__any = NULL;
					continue;
				}
			}
			if (soap_flag___any_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->_ns1__GETMACIDResponse_GETMACIDResult::__any_))
				{	soap_flag___any_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__GETMACIDResponse_GETMACIDResult::__any)
			soap_pop_block(soap, soap_blist___any1);
		if (a->_ns1__GETMACIDResponse_GETMACIDResult::__size)
		{	a->_ns1__GETMACIDResponse_GETMACIDResult::__any = (char *)soap_save_block(soap, soap_blist___any1, NULL, 1);
		}
		else
		{	a->_ns1__GETMACIDResponse_GETMACIDResult::__any = NULL;
			if (soap_blist___any1)
				soap_end_block(soap, soap_blist___any1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GETMACIDResponse_GETMACIDResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GETMACIDResponse_GETMACIDResult, SOAP_TYPE__ns1__GETMACIDResponse_GETMACIDResult, sizeof(_ns1__GETMACIDResponse_GETMACIDResult), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GETMACIDResponse_GETMACIDResult * SOAP_FMAC2 soap_instantiate__ns1__GETMACIDResponse_GETMACIDResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GETMACIDResponse_GETMACIDResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GETMACIDResponse_GETMACIDResult *p;
	size_t k = sizeof(_ns1__GETMACIDResponse_GETMACIDResult);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GETMACIDResponse_GETMACIDResult, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GETMACIDResponse_GETMACIDResult);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GETMACIDResponse_GETMACIDResult, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GETMACIDResponse_GETMACIDResult location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GETMACIDResponse_GETMACIDResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GETMACIDResponse_GETMACIDResult(soap, tag ? tag : "ns1:GETMACIDResponse-GETMACIDResult", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GETMACIDResponse_GETMACIDResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GETMACIDResponse_GETMACIDResult(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GETMACIDResponse_GETMACIDResult * SOAP_FMAC4 soap_get__ns1__GETMACIDResponse_GETMACIDResult(struct soap *soap, _ns1__GETMACIDResponse_GETMACIDResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GETMACIDResponse_GETMACIDResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__BlindKeyNumResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__BlindKeyNumResponse::BlindKeyNumResult = NULL;
	/* transient soap skipped */
}

void _ns1__BlindKeyNumResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfAnyType(soap, &this->_ns1__BlindKeyNumResponse::BlindKeyNumResult);
#endif
}

int _ns1__BlindKeyNumResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__BlindKeyNumResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__BlindKeyNumResponse(struct soap *soap, const char *tag, int id, const _ns1__BlindKeyNumResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__BlindKeyNumResponse), type))
		return soap->error;
	if (a->BlindKeyNumResult)
		soap_element_result(soap, "ns1:BlindKeyNumResult");
	if (soap_out_PointerTons1__ArrayOfAnyType(soap, "ns1:BlindKeyNumResult", -1, &a->_ns1__BlindKeyNumResponse::BlindKeyNumResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__BlindKeyNumResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__BlindKeyNumResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__BlindKeyNumResponse * SOAP_FMAC4 soap_in__ns1__BlindKeyNumResponse(struct soap *soap, const char *tag, _ns1__BlindKeyNumResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__BlindKeyNumResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__BlindKeyNumResponse, sizeof(_ns1__BlindKeyNumResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__BlindKeyNumResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__BlindKeyNumResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_BlindKeyNumResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BlindKeyNumResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfAnyType(soap, "ns1:BlindKeyNumResult", &a->_ns1__BlindKeyNumResponse::BlindKeyNumResult, "ns1:ArrayOfAnyType"))
				{	soap_flag_BlindKeyNumResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:BlindKeyNumResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__BlindKeyNumResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__BlindKeyNumResponse, SOAP_TYPE__ns1__BlindKeyNumResponse, sizeof(_ns1__BlindKeyNumResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__BlindKeyNumResponse * SOAP_FMAC2 soap_instantiate__ns1__BlindKeyNumResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__BlindKeyNumResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__BlindKeyNumResponse *p;
	size_t k = sizeof(_ns1__BlindKeyNumResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__BlindKeyNumResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__BlindKeyNumResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__BlindKeyNumResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__BlindKeyNumResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__BlindKeyNumResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__BlindKeyNumResponse(soap, tag ? tag : "ns1:BlindKeyNumResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__BlindKeyNumResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__BlindKeyNumResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__BlindKeyNumResponse * SOAP_FMAC4 soap_get__ns1__BlindKeyNumResponse(struct soap *soap, _ns1__BlindKeyNumResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__BlindKeyNumResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__BlindKeyNum::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__BlindKeyNum::strSSN);
	soap_default_string(soap, &this->_ns1__BlindKeyNum::strEventPoint);
	soap_default_string(soap, &this->_ns1__BlindKeyNum::user);
	soap_default_string(soap, &this->_ns1__BlindKeyNum::Key);
	soap_default_string(soap, &this->_ns1__BlindKeyNum::Key2);
	soap_default_string(soap, &this->_ns1__BlindKeyNum::Key3);
	/* transient soap skipped */
}

void _ns1__BlindKeyNum::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__BlindKeyNum::strSSN);
	soap_serialize_string(soap, (char*const*)&this->_ns1__BlindKeyNum::strEventPoint);
	soap_serialize_string(soap, (char*const*)&this->_ns1__BlindKeyNum::user);
	soap_serialize_string(soap, (char*const*)&this->_ns1__BlindKeyNum::Key);
	soap_serialize_string(soap, (char*const*)&this->_ns1__BlindKeyNum::Key2);
	soap_serialize_string(soap, (char*const*)&this->_ns1__BlindKeyNum::Key3);
#endif
}

int _ns1__BlindKeyNum::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__BlindKeyNum(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__BlindKeyNum(struct soap *soap, const char *tag, int id, const _ns1__BlindKeyNum *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__BlindKeyNum), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:strSSN", -1, (char*const*)&a->_ns1__BlindKeyNum::strSSN, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:strEventPoint", -1, (char*const*)&a->_ns1__BlindKeyNum::strEventPoint, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:user", -1, (char*const*)&a->_ns1__BlindKeyNum::user, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Key", -1, (char*const*)&a->_ns1__BlindKeyNum::Key, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Key2", -1, (char*const*)&a->_ns1__BlindKeyNum::Key2, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Key3", -1, (char*const*)&a->_ns1__BlindKeyNum::Key3, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__BlindKeyNum::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__BlindKeyNum(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__BlindKeyNum * SOAP_FMAC4 soap_in__ns1__BlindKeyNum(struct soap *soap, const char *tag, _ns1__BlindKeyNum *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__BlindKeyNum *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__BlindKeyNum, sizeof(_ns1__BlindKeyNum), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__BlindKeyNum)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__BlindKeyNum *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_strSSN1 = 1;
	size_t soap_flag_strEventPoint1 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_Key1 = 1;
	size_t soap_flag_Key21 = 1;
	size_t soap_flag_Key31 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_strSSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:strSSN", (char**)&a->_ns1__BlindKeyNum::strSSN, "xsd:string"))
				{	soap_flag_strSSN1--;
					continue;
				}
			}
			if (soap_flag_strEventPoint1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:strEventPoint", (char**)&a->_ns1__BlindKeyNum::strEventPoint, "xsd:string"))
				{	soap_flag_strEventPoint1--;
					continue;
				}
			}
			if (soap_flag_user1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:user", (char**)&a->_ns1__BlindKeyNum::user, "xsd:string"))
				{	soap_flag_user1--;
					continue;
				}
			}
			if (soap_flag_Key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:Key", (char**)&a->_ns1__BlindKeyNum::Key, "xsd:string"))
				{	soap_flag_Key1--;
					continue;
				}
			}
			if (soap_flag_Key21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:Key2", (char**)&a->_ns1__BlindKeyNum::Key2, "xsd:string"))
				{	soap_flag_Key21--;
					continue;
				}
			}
			if (soap_flag_Key31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:Key3", (char**)&a->_ns1__BlindKeyNum::Key3, "xsd:string"))
				{	soap_flag_Key31--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__BlindKeyNum *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__BlindKeyNum, SOAP_TYPE__ns1__BlindKeyNum, sizeof(_ns1__BlindKeyNum), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__BlindKeyNum * SOAP_FMAC2 soap_instantiate__ns1__BlindKeyNum(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__BlindKeyNum(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__BlindKeyNum *p;
	size_t k = sizeof(_ns1__BlindKeyNum);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__BlindKeyNum, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__BlindKeyNum);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__BlindKeyNum, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__BlindKeyNum location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__BlindKeyNum::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__BlindKeyNum(soap, tag ? tag : "ns1:BlindKeyNum", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__BlindKeyNum::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__BlindKeyNum(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__BlindKeyNum * SOAP_FMAC4 soap_get__ns1__BlindKeyNum(struct soap *soap, _ns1__BlindKeyNum *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__BlindKeyNum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetSparrowCheckDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetSparrowCheckDataResponse::GetSparrowCheckDataResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetSparrowCheckDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfAnyType(soap, &this->_ns1__GetSparrowCheckDataResponse::GetSparrowCheckDataResult);
#endif
}

int _ns1__GetSparrowCheckDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetSparrowCheckDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetSparrowCheckDataResponse(struct soap *soap, const char *tag, int id, const _ns1__GetSparrowCheckDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetSparrowCheckDataResponse), type))
		return soap->error;
	if (a->GetSparrowCheckDataResult)
		soap_element_result(soap, "ns1:GetSparrowCheckDataResult");
	if (soap_out_PointerTons1__ArrayOfAnyType(soap, "ns1:GetSparrowCheckDataResult", -1, &a->_ns1__GetSparrowCheckDataResponse::GetSparrowCheckDataResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetSparrowCheckDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetSparrowCheckDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetSparrowCheckDataResponse * SOAP_FMAC4 soap_in__ns1__GetSparrowCheckDataResponse(struct soap *soap, const char *tag, _ns1__GetSparrowCheckDataResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetSparrowCheckDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetSparrowCheckDataResponse, sizeof(_ns1__GetSparrowCheckDataResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetSparrowCheckDataResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetSparrowCheckDataResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetSparrowCheckDataResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetSparrowCheckDataResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfAnyType(soap, "ns1:GetSparrowCheckDataResult", &a->_ns1__GetSparrowCheckDataResponse::GetSparrowCheckDataResult, "ns1:ArrayOfAnyType"))
				{	soap_flag_GetSparrowCheckDataResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetSparrowCheckDataResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetSparrowCheckDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetSparrowCheckDataResponse, SOAP_TYPE__ns1__GetSparrowCheckDataResponse, sizeof(_ns1__GetSparrowCheckDataResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetSparrowCheckDataResponse * SOAP_FMAC2 soap_instantiate__ns1__GetSparrowCheckDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetSparrowCheckDataResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetSparrowCheckDataResponse *p;
	size_t k = sizeof(_ns1__GetSparrowCheckDataResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetSparrowCheckDataResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetSparrowCheckDataResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetSparrowCheckDataResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetSparrowCheckDataResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetSparrowCheckDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetSparrowCheckDataResponse(soap, tag ? tag : "ns1:GetSparrowCheckDataResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetSparrowCheckDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetSparrowCheckDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetSparrowCheckDataResponse * SOAP_FMAC4 soap_get__ns1__GetSparrowCheckDataResponse(struct soap *soap, _ns1__GetSparrowCheckDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetSparrowCheckDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetSparrowCheckData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetSparrowCheckData::SN);
	/* transient soap skipped */
}

void _ns1__GetSparrowCheckData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetSparrowCheckData::SN);
#endif
}

int _ns1__GetSparrowCheckData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetSparrowCheckData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetSparrowCheckData(struct soap *soap, const char *tag, int id, const _ns1__GetSparrowCheckData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetSparrowCheckData), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:SN", -1, (char*const*)&a->_ns1__GetSparrowCheckData::SN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetSparrowCheckData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetSparrowCheckData(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetSparrowCheckData * SOAP_FMAC4 soap_in__ns1__GetSparrowCheckData(struct soap *soap, const char *tag, _ns1__GetSparrowCheckData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetSparrowCheckData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetSparrowCheckData, sizeof(_ns1__GetSparrowCheckData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetSparrowCheckData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetSparrowCheckData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SN1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:SN", (char**)&a->_ns1__GetSparrowCheckData::SN, "xsd:string"))
				{	soap_flag_SN1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetSparrowCheckData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetSparrowCheckData, SOAP_TYPE__ns1__GetSparrowCheckData, sizeof(_ns1__GetSparrowCheckData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetSparrowCheckData * SOAP_FMAC2 soap_instantiate__ns1__GetSparrowCheckData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetSparrowCheckData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetSparrowCheckData *p;
	size_t k = sizeof(_ns1__GetSparrowCheckData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetSparrowCheckData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetSparrowCheckData);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetSparrowCheckData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetSparrowCheckData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetSparrowCheckData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetSparrowCheckData(soap, tag ? tag : "ns1:GetSparrowCheckData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetSparrowCheckData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetSparrowCheckData(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetSparrowCheckData * SOAP_FMAC4 soap_get__ns1__GetSparrowCheckData(struct soap *soap, _ns1__GetSparrowCheckData *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetSparrowCheckData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__BindKeyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__BindKeyResponse::BindKeyResult = NULL;
	/* transient soap skipped */
}

void _ns1__BindKeyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfAnyType(soap, &this->_ns1__BindKeyResponse::BindKeyResult);
#endif
}

int _ns1__BindKeyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__BindKeyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__BindKeyResponse(struct soap *soap, const char *tag, int id, const _ns1__BindKeyResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__BindKeyResponse), type))
		return soap->error;
	if (a->BindKeyResult)
		soap_element_result(soap, "ns1:BindKeyResult");
	if (soap_out_PointerTons1__ArrayOfAnyType(soap, "ns1:BindKeyResult", -1, &a->_ns1__BindKeyResponse::BindKeyResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__BindKeyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__BindKeyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__BindKeyResponse * SOAP_FMAC4 soap_in__ns1__BindKeyResponse(struct soap *soap, const char *tag, _ns1__BindKeyResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__BindKeyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__BindKeyResponse, sizeof(_ns1__BindKeyResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__BindKeyResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__BindKeyResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_BindKeyResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BindKeyResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfAnyType(soap, "ns1:BindKeyResult", &a->_ns1__BindKeyResponse::BindKeyResult, "ns1:ArrayOfAnyType"))
				{	soap_flag_BindKeyResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:BindKeyResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__BindKeyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__BindKeyResponse, SOAP_TYPE__ns1__BindKeyResponse, sizeof(_ns1__BindKeyResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__BindKeyResponse * SOAP_FMAC2 soap_instantiate__ns1__BindKeyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__BindKeyResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__BindKeyResponse *p;
	size_t k = sizeof(_ns1__BindKeyResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__BindKeyResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__BindKeyResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__BindKeyResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__BindKeyResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__BindKeyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__BindKeyResponse(soap, tag ? tag : "ns1:BindKeyResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__BindKeyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__BindKeyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__BindKeyResponse * SOAP_FMAC4 soap_get__ns1__BindKeyResponse(struct soap *soap, _ns1__BindKeyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__BindKeyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__BindKey::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__BindKey::key);
	soap_default_string(soap, &this->_ns1__BindKey::ssn);
	/* transient soap skipped */
}

void _ns1__BindKey::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__BindKey::key);
	soap_serialize_string(soap, (char*const*)&this->_ns1__BindKey::ssn);
#endif
}

int _ns1__BindKey::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__BindKey(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__BindKey(struct soap *soap, const char *tag, int id, const _ns1__BindKey *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__BindKey), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:key", -1, (char*const*)&a->_ns1__BindKey::key, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:ssn", -1, (char*const*)&a->_ns1__BindKey::ssn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__BindKey::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__BindKey(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__BindKey * SOAP_FMAC4 soap_in__ns1__BindKey(struct soap *soap, const char *tag, _ns1__BindKey *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__BindKey *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__BindKey, sizeof(_ns1__BindKey), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__BindKey)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__BindKey *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_key1 = 1;
	size_t soap_flag_ssn1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:key", (char**)&a->_ns1__BindKey::key, "xsd:string"))
				{	soap_flag_key1--;
					continue;
				}
			}
			if (soap_flag_ssn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:ssn", (char**)&a->_ns1__BindKey::ssn, "xsd:string"))
				{	soap_flag_ssn1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__BindKey *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__BindKey, SOAP_TYPE__ns1__BindKey, sizeof(_ns1__BindKey), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__BindKey * SOAP_FMAC2 soap_instantiate__ns1__BindKey(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__BindKey(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__BindKey *p;
	size_t k = sizeof(_ns1__BindKey);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__BindKey, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__BindKey);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__BindKey, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__BindKey location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__BindKey::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__BindKey(soap, tag ? tag : "ns1:BindKey", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__BindKey::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__BindKey(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__BindKey * SOAP_FMAC4 soap_get__ns1__BindKey(struct soap *soap, _ns1__BindKey *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__BindKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ReleaseKeyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ReleaseKeyResponse::ReleaseKeyResult = NULL;
	/* transient soap skipped */
}

void _ns1__ReleaseKeyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfAnyType(soap, &this->_ns1__ReleaseKeyResponse::ReleaseKeyResult);
#endif
}

int _ns1__ReleaseKeyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ReleaseKeyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ReleaseKeyResponse(struct soap *soap, const char *tag, int id, const _ns1__ReleaseKeyResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ReleaseKeyResponse), type))
		return soap->error;
	if (a->ReleaseKeyResult)
		soap_element_result(soap, "ns1:ReleaseKeyResult");
	if (soap_out_PointerTons1__ArrayOfAnyType(soap, "ns1:ReleaseKeyResult", -1, &a->_ns1__ReleaseKeyResponse::ReleaseKeyResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ReleaseKeyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ReleaseKeyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ReleaseKeyResponse * SOAP_FMAC4 soap_in__ns1__ReleaseKeyResponse(struct soap *soap, const char *tag, _ns1__ReleaseKeyResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ReleaseKeyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ReleaseKeyResponse, sizeof(_ns1__ReleaseKeyResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ReleaseKeyResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ReleaseKeyResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ReleaseKeyResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ReleaseKeyResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfAnyType(soap, "ns1:ReleaseKeyResult", &a->_ns1__ReleaseKeyResponse::ReleaseKeyResult, "ns1:ArrayOfAnyType"))
				{	soap_flag_ReleaseKeyResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:ReleaseKeyResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ReleaseKeyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ReleaseKeyResponse, SOAP_TYPE__ns1__ReleaseKeyResponse, sizeof(_ns1__ReleaseKeyResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ReleaseKeyResponse * SOAP_FMAC2 soap_instantiate__ns1__ReleaseKeyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ReleaseKeyResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ReleaseKeyResponse *p;
	size_t k = sizeof(_ns1__ReleaseKeyResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__ReleaseKeyResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__ReleaseKeyResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__ReleaseKeyResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ReleaseKeyResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__ReleaseKeyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ReleaseKeyResponse(soap, tag ? tag : "ns1:ReleaseKeyResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ReleaseKeyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ReleaseKeyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ReleaseKeyResponse * SOAP_FMAC4 soap_get__ns1__ReleaseKeyResponse(struct soap *soap, _ns1__ReleaseKeyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ReleaseKeyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ReleaseKey::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__ReleaseKey::key);
	/* transient soap skipped */
}

void _ns1__ReleaseKey::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__ReleaseKey::key);
#endif
}

int _ns1__ReleaseKey::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ReleaseKey(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ReleaseKey(struct soap *soap, const char *tag, int id, const _ns1__ReleaseKey *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ReleaseKey), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:key", -1, (char*const*)&a->_ns1__ReleaseKey::key, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ReleaseKey::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ReleaseKey(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ReleaseKey * SOAP_FMAC4 soap_in__ns1__ReleaseKey(struct soap *soap, const char *tag, _ns1__ReleaseKey *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ReleaseKey *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ReleaseKey, sizeof(_ns1__ReleaseKey), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ReleaseKey)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ReleaseKey *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_key1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:key", (char**)&a->_ns1__ReleaseKey::key, "xsd:string"))
				{	soap_flag_key1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ReleaseKey *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ReleaseKey, SOAP_TYPE__ns1__ReleaseKey, sizeof(_ns1__ReleaseKey), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ReleaseKey * SOAP_FMAC2 soap_instantiate__ns1__ReleaseKey(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ReleaseKey(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ReleaseKey *p;
	size_t k = sizeof(_ns1__ReleaseKey);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__ReleaseKey, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__ReleaseKey);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__ReleaseKey, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ReleaseKey location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__ReleaseKey::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ReleaseKey(soap, tag ? tag : "ns1:ReleaseKey", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ReleaseKey::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ReleaseKey(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ReleaseKey * SOAP_FMAC4 soap_get__ns1__ReleaseKey(struct soap *soap, _ns1__ReleaseKey *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ReleaseKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetShaoluKeyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetShaoluKeyResponse::GetShaoluKeyResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetShaoluKeyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfAnyType(soap, &this->_ns1__GetShaoluKeyResponse::GetShaoluKeyResult);
#endif
}

int _ns1__GetShaoluKeyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetShaoluKeyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetShaoluKeyResponse(struct soap *soap, const char *tag, int id, const _ns1__GetShaoluKeyResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetShaoluKeyResponse), type))
		return soap->error;
	if (a->GetShaoluKeyResult)
		soap_element_result(soap, "ns1:GetShaoluKeyResult");
	if (soap_out_PointerTons1__ArrayOfAnyType(soap, "ns1:GetShaoluKeyResult", -1, &a->_ns1__GetShaoluKeyResponse::GetShaoluKeyResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetShaoluKeyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetShaoluKeyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetShaoluKeyResponse * SOAP_FMAC4 soap_in__ns1__GetShaoluKeyResponse(struct soap *soap, const char *tag, _ns1__GetShaoluKeyResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetShaoluKeyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetShaoluKeyResponse, sizeof(_ns1__GetShaoluKeyResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetShaoluKeyResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetShaoluKeyResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetShaoluKeyResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetShaoluKeyResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfAnyType(soap, "ns1:GetShaoluKeyResult", &a->_ns1__GetShaoluKeyResponse::GetShaoluKeyResult, "ns1:ArrayOfAnyType"))
				{	soap_flag_GetShaoluKeyResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetShaoluKeyResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetShaoluKeyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetShaoluKeyResponse, SOAP_TYPE__ns1__GetShaoluKeyResponse, sizeof(_ns1__GetShaoluKeyResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetShaoluKeyResponse * SOAP_FMAC2 soap_instantiate__ns1__GetShaoluKeyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetShaoluKeyResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetShaoluKeyResponse *p;
	size_t k = sizeof(_ns1__GetShaoluKeyResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetShaoluKeyResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetShaoluKeyResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetShaoluKeyResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetShaoluKeyResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetShaoluKeyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetShaoluKeyResponse(soap, tag ? tag : "ns1:GetShaoluKeyResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetShaoluKeyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetShaoluKeyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetShaoluKeyResponse * SOAP_FMAC4 soap_get__ns1__GetShaoluKeyResponse(struct soap *soap, _ns1__GetShaoluKeyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetShaoluKeyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetShaoluKey::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetShaoluKey::customer);
	soap_default_string(soap, &this->_ns1__GetShaoluKey::ssn);
	/* transient soap skipped */
}

void _ns1__GetShaoluKey::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetShaoluKey::customer);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetShaoluKey::ssn);
#endif
}

int _ns1__GetShaoluKey::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetShaoluKey(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetShaoluKey(struct soap *soap, const char *tag, int id, const _ns1__GetShaoluKey *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetShaoluKey), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:customer", -1, (char*const*)&a->_ns1__GetShaoluKey::customer, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:ssn", -1, (char*const*)&a->_ns1__GetShaoluKey::ssn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetShaoluKey::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetShaoluKey(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetShaoluKey * SOAP_FMAC4 soap_in__ns1__GetShaoluKey(struct soap *soap, const char *tag, _ns1__GetShaoluKey *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetShaoluKey *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetShaoluKey, sizeof(_ns1__GetShaoluKey), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetShaoluKey)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetShaoluKey *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_customer1 = 1;
	size_t soap_flag_ssn1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_customer1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:customer", (char**)&a->_ns1__GetShaoluKey::customer, "xsd:string"))
				{	soap_flag_customer1--;
					continue;
				}
			}
			if (soap_flag_ssn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:ssn", (char**)&a->_ns1__GetShaoluKey::ssn, "xsd:string"))
				{	soap_flag_ssn1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetShaoluKey *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetShaoluKey, SOAP_TYPE__ns1__GetShaoluKey, sizeof(_ns1__GetShaoluKey), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetShaoluKey * SOAP_FMAC2 soap_instantiate__ns1__GetShaoluKey(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetShaoluKey(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetShaoluKey *p;
	size_t k = sizeof(_ns1__GetShaoluKey);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetShaoluKey, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetShaoluKey);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetShaoluKey, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetShaoluKey location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetShaoluKey::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetShaoluKey(soap, tag ? tag : "ns1:GetShaoluKey", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetShaoluKey::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetShaoluKey(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetShaoluKey * SOAP_FMAC4 soap_get__ns1__GetShaoluKey(struct soap *soap, _ns1__GetShaoluKey *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetShaoluKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__PCBData_USCOREUploadResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__PCBData_USCOREUploadResponse::PCBData_USCOREUploadResult = NULL;
	/* transient soap skipped */
}

void _ns1__PCBData_USCOREUploadResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfAnyType(soap, &this->_ns1__PCBData_USCOREUploadResponse::PCBData_USCOREUploadResult);
#endif
}

int _ns1__PCBData_USCOREUploadResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__PCBData_USCOREUploadResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__PCBData_USCOREUploadResponse(struct soap *soap, const char *tag, int id, const _ns1__PCBData_USCOREUploadResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__PCBData_USCOREUploadResponse), type))
		return soap->error;
	if (a->PCBData_USCOREUploadResult)
		soap_element_result(soap, "ns1:PCBData_UploadResult");
	if (soap_out_PointerTons1__ArrayOfAnyType(soap, "ns1:PCBData_UploadResult", -1, &a->_ns1__PCBData_USCOREUploadResponse::PCBData_USCOREUploadResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__PCBData_USCOREUploadResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__PCBData_USCOREUploadResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__PCBData_USCOREUploadResponse * SOAP_FMAC4 soap_in__ns1__PCBData_USCOREUploadResponse(struct soap *soap, const char *tag, _ns1__PCBData_USCOREUploadResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__PCBData_USCOREUploadResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__PCBData_USCOREUploadResponse, sizeof(_ns1__PCBData_USCOREUploadResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__PCBData_USCOREUploadResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__PCBData_USCOREUploadResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_PCBData_USCOREUploadResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PCBData_USCOREUploadResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfAnyType(soap, "ns1:PCBData_UploadResult", &a->_ns1__PCBData_USCOREUploadResponse::PCBData_USCOREUploadResult, "ns1:ArrayOfAnyType"))
				{	soap_flag_PCBData_USCOREUploadResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:PCBData_UploadResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__PCBData_USCOREUploadResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__PCBData_USCOREUploadResponse, SOAP_TYPE__ns1__PCBData_USCOREUploadResponse, sizeof(_ns1__PCBData_USCOREUploadResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__PCBData_USCOREUploadResponse * SOAP_FMAC2 soap_instantiate__ns1__PCBData_USCOREUploadResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__PCBData_USCOREUploadResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__PCBData_USCOREUploadResponse *p;
	size_t k = sizeof(_ns1__PCBData_USCOREUploadResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__PCBData_USCOREUploadResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__PCBData_USCOREUploadResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__PCBData_USCOREUploadResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__PCBData_USCOREUploadResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__PCBData_USCOREUploadResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__PCBData_USCOREUploadResponse(soap, tag ? tag : "ns1:PCBData_UploadResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__PCBData_USCOREUploadResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__PCBData_USCOREUploadResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__PCBData_USCOREUploadResponse * SOAP_FMAC4 soap_get__ns1__PCBData_USCOREUploadResponse(struct soap *soap, _ns1__PCBData_USCOREUploadResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__PCBData_USCOREUploadResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__PCBData_USCOREUpload::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__PCBData_USCOREUpload::partno);
	soap_default_string(soap, &this->_ns1__PCBData_USCOREUpload::FTdata);
	soap_default_string(soap, &this->_ns1__PCBData_USCOREUpload::version);
	soap_default_string(soap, &this->_ns1__PCBData_USCOREUpload::PCBsn);
	soap_default_string(soap, &this->_ns1__PCBData_USCOREUpload::cpu);
	soap_default_string(soap, &this->_ns1__PCBData_USCOREUpload::flash);
	soap_default_string(soap, &this->_ns1__PCBData_USCOREUpload::rom);
	soap_default_string(soap, &this->_ns1__PCBData_USCOREUpload::wifi);
	soap_default_string(soap, &this->_ns1__PCBData_USCOREUpload::bt);
	/* transient soap skipped */
}

void _ns1__PCBData_USCOREUpload::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__PCBData_USCOREUpload::partno);
	soap_serialize_string(soap, (char*const*)&this->_ns1__PCBData_USCOREUpload::FTdata);
	soap_serialize_string(soap, (char*const*)&this->_ns1__PCBData_USCOREUpload::version);
	soap_serialize_string(soap, (char*const*)&this->_ns1__PCBData_USCOREUpload::PCBsn);
	soap_serialize_string(soap, (char*const*)&this->_ns1__PCBData_USCOREUpload::cpu);
	soap_serialize_string(soap, (char*const*)&this->_ns1__PCBData_USCOREUpload::flash);
	soap_serialize_string(soap, (char*const*)&this->_ns1__PCBData_USCOREUpload::rom);
	soap_serialize_string(soap, (char*const*)&this->_ns1__PCBData_USCOREUpload::wifi);
	soap_serialize_string(soap, (char*const*)&this->_ns1__PCBData_USCOREUpload::bt);
#endif
}

int _ns1__PCBData_USCOREUpload::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__PCBData_USCOREUpload(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__PCBData_USCOREUpload(struct soap *soap, const char *tag, int id, const _ns1__PCBData_USCOREUpload *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__PCBData_USCOREUpload), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:partno", -1, (char*const*)&a->_ns1__PCBData_USCOREUpload::partno, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:FTdata", -1, (char*const*)&a->_ns1__PCBData_USCOREUpload::FTdata, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:version", -1, (char*const*)&a->_ns1__PCBData_USCOREUpload::version, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:PCBsn", -1, (char*const*)&a->_ns1__PCBData_USCOREUpload::PCBsn, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:cpu", -1, (char*const*)&a->_ns1__PCBData_USCOREUpload::cpu, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:flash", -1, (char*const*)&a->_ns1__PCBData_USCOREUpload::flash, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:rom", -1, (char*const*)&a->_ns1__PCBData_USCOREUpload::rom, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:wifi", -1, (char*const*)&a->_ns1__PCBData_USCOREUpload::wifi, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:bt", -1, (char*const*)&a->_ns1__PCBData_USCOREUpload::bt, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__PCBData_USCOREUpload::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__PCBData_USCOREUpload(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__PCBData_USCOREUpload * SOAP_FMAC4 soap_in__ns1__PCBData_USCOREUpload(struct soap *soap, const char *tag, _ns1__PCBData_USCOREUpload *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__PCBData_USCOREUpload *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__PCBData_USCOREUpload, sizeof(_ns1__PCBData_USCOREUpload), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__PCBData_USCOREUpload)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__PCBData_USCOREUpload *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_partno1 = 1;
	size_t soap_flag_FTdata1 = 1;
	size_t soap_flag_version1 = 1;
	size_t soap_flag_PCBsn1 = 1;
	size_t soap_flag_cpu1 = 1;
	size_t soap_flag_flash1 = 1;
	size_t soap_flag_rom1 = 1;
	size_t soap_flag_wifi1 = 1;
	size_t soap_flag_bt1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_partno1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:partno", (char**)&a->_ns1__PCBData_USCOREUpload::partno, "xsd:string"))
				{	soap_flag_partno1--;
					continue;
				}
			}
			if (soap_flag_FTdata1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:FTdata", (char**)&a->_ns1__PCBData_USCOREUpload::FTdata, "xsd:string"))
				{	soap_flag_FTdata1--;
					continue;
				}
			}
			if (soap_flag_version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:version", (char**)&a->_ns1__PCBData_USCOREUpload::version, "xsd:string"))
				{	soap_flag_version1--;
					continue;
				}
			}
			if (soap_flag_PCBsn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:PCBsn", (char**)&a->_ns1__PCBData_USCOREUpload::PCBsn, "xsd:string"))
				{	soap_flag_PCBsn1--;
					continue;
				}
			}
			if (soap_flag_cpu1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:cpu", (char**)&a->_ns1__PCBData_USCOREUpload::cpu, "xsd:string"))
				{	soap_flag_cpu1--;
					continue;
				}
			}
			if (soap_flag_flash1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:flash", (char**)&a->_ns1__PCBData_USCOREUpload::flash, "xsd:string"))
				{	soap_flag_flash1--;
					continue;
				}
			}
			if (soap_flag_rom1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:rom", (char**)&a->_ns1__PCBData_USCOREUpload::rom, "xsd:string"))
				{	soap_flag_rom1--;
					continue;
				}
			}
			if (soap_flag_wifi1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:wifi", (char**)&a->_ns1__PCBData_USCOREUpload::wifi, "xsd:string"))
				{	soap_flag_wifi1--;
					continue;
				}
			}
			if (soap_flag_bt1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:bt", (char**)&a->_ns1__PCBData_USCOREUpload::bt, "xsd:string"))
				{	soap_flag_bt1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__PCBData_USCOREUpload *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__PCBData_USCOREUpload, SOAP_TYPE__ns1__PCBData_USCOREUpload, sizeof(_ns1__PCBData_USCOREUpload), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__PCBData_USCOREUpload * SOAP_FMAC2 soap_instantiate__ns1__PCBData_USCOREUpload(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__PCBData_USCOREUpload(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__PCBData_USCOREUpload *p;
	size_t k = sizeof(_ns1__PCBData_USCOREUpload);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__PCBData_USCOREUpload, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__PCBData_USCOREUpload);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__PCBData_USCOREUpload, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__PCBData_USCOREUpload location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__PCBData_USCOREUpload::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__PCBData_USCOREUpload(soap, tag ? tag : "ns1:PCBData_Upload", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__PCBData_USCOREUpload::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__PCBData_USCOREUpload(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__PCBData_USCOREUpload * SOAP_FMAC4 soap_get__ns1__PCBData_USCOREUpload(struct soap *soap, _ns1__PCBData_USCOREUpload *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__PCBData_USCOREUpload(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CartonWeight_USCOREUploadResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__CartonWeight_USCOREUploadResponse::CartonWeight_USCOREUploadResult = NULL;
	/* transient soap skipped */
}

void _ns1__CartonWeight_USCOREUploadResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfAnyType(soap, &this->_ns1__CartonWeight_USCOREUploadResponse::CartonWeight_USCOREUploadResult);
#endif
}

int _ns1__CartonWeight_USCOREUploadResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CartonWeight_USCOREUploadResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CartonWeight_USCOREUploadResponse(struct soap *soap, const char *tag, int id, const _ns1__CartonWeight_USCOREUploadResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CartonWeight_USCOREUploadResponse), type))
		return soap->error;
	if (a->CartonWeight_USCOREUploadResult)
		soap_element_result(soap, "ns1:CartonWeight_UploadResult");
	if (soap_out_PointerTons1__ArrayOfAnyType(soap, "ns1:CartonWeight_UploadResult", -1, &a->_ns1__CartonWeight_USCOREUploadResponse::CartonWeight_USCOREUploadResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CartonWeight_USCOREUploadResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CartonWeight_USCOREUploadResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CartonWeight_USCOREUploadResponse * SOAP_FMAC4 soap_in__ns1__CartonWeight_USCOREUploadResponse(struct soap *soap, const char *tag, _ns1__CartonWeight_USCOREUploadResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CartonWeight_USCOREUploadResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CartonWeight_USCOREUploadResponse, sizeof(_ns1__CartonWeight_USCOREUploadResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__CartonWeight_USCOREUploadResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__CartonWeight_USCOREUploadResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CartonWeight_USCOREUploadResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CartonWeight_USCOREUploadResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfAnyType(soap, "ns1:CartonWeight_UploadResult", &a->_ns1__CartonWeight_USCOREUploadResponse::CartonWeight_USCOREUploadResult, "ns1:ArrayOfAnyType"))
				{	soap_flag_CartonWeight_USCOREUploadResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:CartonWeight_UploadResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CartonWeight_USCOREUploadResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CartonWeight_USCOREUploadResponse, SOAP_TYPE__ns1__CartonWeight_USCOREUploadResponse, sizeof(_ns1__CartonWeight_USCOREUploadResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CartonWeight_USCOREUploadResponse * SOAP_FMAC2 soap_instantiate__ns1__CartonWeight_USCOREUploadResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CartonWeight_USCOREUploadResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CartonWeight_USCOREUploadResponse *p;
	size_t k = sizeof(_ns1__CartonWeight_USCOREUploadResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__CartonWeight_USCOREUploadResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__CartonWeight_USCOREUploadResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__CartonWeight_USCOREUploadResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CartonWeight_USCOREUploadResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__CartonWeight_USCOREUploadResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__CartonWeight_USCOREUploadResponse(soap, tag ? tag : "ns1:CartonWeight_UploadResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CartonWeight_USCOREUploadResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CartonWeight_USCOREUploadResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CartonWeight_USCOREUploadResponse * SOAP_FMAC4 soap_get__ns1__CartonWeight_USCOREUploadResponse(struct soap *soap, _ns1__CartonWeight_USCOREUploadResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CartonWeight_USCOREUploadResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CartonWeight_USCOREUpload::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__CartonWeight_USCOREUpload::strSN);
	soap_default_float(soap, &this->_ns1__CartonWeight_USCOREUpload::weight);
	soap_default_bool(soap, &this->_ns1__CartonWeight_USCOREUpload::ismore);
	soap_default_string(soap, &this->_ns1__CartonWeight_USCOREUpload::editby);
	/* transient soap skipped */
}

void _ns1__CartonWeight_USCOREUpload::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__CartonWeight_USCOREUpload::strSN);
	soap_serialize_string(soap, (char*const*)&this->_ns1__CartonWeight_USCOREUpload::editby);
#endif
}

int _ns1__CartonWeight_USCOREUpload::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CartonWeight_USCOREUpload(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CartonWeight_USCOREUpload(struct soap *soap, const char *tag, int id, const _ns1__CartonWeight_USCOREUpload *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CartonWeight_USCOREUpload), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:strSN", -1, (char*const*)&a->_ns1__CartonWeight_USCOREUpload::strSN, ""))
		return soap->error;
	if (soap_out_float(soap, "ns1:weight", -1, &a->_ns1__CartonWeight_USCOREUpload::weight, ""))
		return soap->error;
	if (soap_out_bool(soap, "ns1:ismore", -1, &a->_ns1__CartonWeight_USCOREUpload::ismore, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:editby", -1, (char*const*)&a->_ns1__CartonWeight_USCOREUpload::editby, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CartonWeight_USCOREUpload::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CartonWeight_USCOREUpload(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CartonWeight_USCOREUpload * SOAP_FMAC4 soap_in__ns1__CartonWeight_USCOREUpload(struct soap *soap, const char *tag, _ns1__CartonWeight_USCOREUpload *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CartonWeight_USCOREUpload *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CartonWeight_USCOREUpload, sizeof(_ns1__CartonWeight_USCOREUpload), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__CartonWeight_USCOREUpload)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__CartonWeight_USCOREUpload *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_strSN1 = 1;
	size_t soap_flag_weight1 = 1;
	size_t soap_flag_ismore1 = 1;
	size_t soap_flag_editby1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_strSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:strSN", (char**)&a->_ns1__CartonWeight_USCOREUpload::strSN, "xsd:string"))
				{	soap_flag_strSN1--;
					continue;
				}
			}
			if (soap_flag_weight1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "ns1:weight", &a->_ns1__CartonWeight_USCOREUpload::weight, "xsd:float"))
				{	soap_flag_weight1--;
					continue;
				}
			}
			if (soap_flag_ismore1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "ns1:ismore", &a->_ns1__CartonWeight_USCOREUpload::ismore, "xsd:boolean"))
				{	soap_flag_ismore1--;
					continue;
				}
			}
			if (soap_flag_editby1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:editby", (char**)&a->_ns1__CartonWeight_USCOREUpload::editby, "xsd:string"))
				{	soap_flag_editby1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_weight1 > 0 || soap_flag_ismore1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__CartonWeight_USCOREUpload *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CartonWeight_USCOREUpload, SOAP_TYPE__ns1__CartonWeight_USCOREUpload, sizeof(_ns1__CartonWeight_USCOREUpload), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CartonWeight_USCOREUpload * SOAP_FMAC2 soap_instantiate__ns1__CartonWeight_USCOREUpload(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CartonWeight_USCOREUpload(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CartonWeight_USCOREUpload *p;
	size_t k = sizeof(_ns1__CartonWeight_USCOREUpload);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__CartonWeight_USCOREUpload, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__CartonWeight_USCOREUpload);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__CartonWeight_USCOREUpload, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CartonWeight_USCOREUpload location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__CartonWeight_USCOREUpload::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__CartonWeight_USCOREUpload(soap, tag ? tag : "ns1:CartonWeight_Upload", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CartonWeight_USCOREUpload::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CartonWeight_USCOREUpload(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CartonWeight_USCOREUpload * SOAP_FMAC4 soap_get__ns1__CartonWeight_USCOREUpload(struct soap *soap, _ns1__CartonWeight_USCOREUpload *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CartonWeight_USCOREUpload(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetMacBySnResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetMacBySnResponse::GetMacBySnResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetMacBySnResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfAnyType(soap, &this->_ns1__GetMacBySnResponse::GetMacBySnResult);
#endif
}

int _ns1__GetMacBySnResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetMacBySnResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetMacBySnResponse(struct soap *soap, const char *tag, int id, const _ns1__GetMacBySnResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetMacBySnResponse), type))
		return soap->error;
	if (a->GetMacBySnResult)
		soap_element_result(soap, "ns1:GetMacBySnResult");
	if (soap_out_PointerTons1__ArrayOfAnyType(soap, "ns1:GetMacBySnResult", -1, &a->_ns1__GetMacBySnResponse::GetMacBySnResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetMacBySnResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetMacBySnResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetMacBySnResponse * SOAP_FMAC4 soap_in__ns1__GetMacBySnResponse(struct soap *soap, const char *tag, _ns1__GetMacBySnResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetMacBySnResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetMacBySnResponse, sizeof(_ns1__GetMacBySnResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetMacBySnResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetMacBySnResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetMacBySnResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetMacBySnResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfAnyType(soap, "ns1:GetMacBySnResult", &a->_ns1__GetMacBySnResponse::GetMacBySnResult, "ns1:ArrayOfAnyType"))
				{	soap_flag_GetMacBySnResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetMacBySnResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetMacBySnResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetMacBySnResponse, SOAP_TYPE__ns1__GetMacBySnResponse, sizeof(_ns1__GetMacBySnResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetMacBySnResponse * SOAP_FMAC2 soap_instantiate__ns1__GetMacBySnResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetMacBySnResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetMacBySnResponse *p;
	size_t k = sizeof(_ns1__GetMacBySnResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetMacBySnResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetMacBySnResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetMacBySnResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetMacBySnResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetMacBySnResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetMacBySnResponse(soap, tag ? tag : "ns1:GetMacBySnResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetMacBySnResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetMacBySnResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetMacBySnResponse * SOAP_FMAC4 soap_get__ns1__GetMacBySnResponse(struct soap *soap, _ns1__GetMacBySnResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetMacBySnResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetMacBySn::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetMacBySn::strSN);
	/* transient soap skipped */
}

void _ns1__GetMacBySn::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetMacBySn::strSN);
#endif
}

int _ns1__GetMacBySn::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetMacBySn(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetMacBySn(struct soap *soap, const char *tag, int id, const _ns1__GetMacBySn *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetMacBySn), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:strSN", -1, (char*const*)&a->_ns1__GetMacBySn::strSN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetMacBySn::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetMacBySn(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetMacBySn * SOAP_FMAC4 soap_in__ns1__GetMacBySn(struct soap *soap, const char *tag, _ns1__GetMacBySn *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetMacBySn *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetMacBySn, sizeof(_ns1__GetMacBySn), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetMacBySn)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetMacBySn *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_strSN1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_strSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:strSN", (char**)&a->_ns1__GetMacBySn::strSN, "xsd:string"))
				{	soap_flag_strSN1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetMacBySn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetMacBySn, SOAP_TYPE__ns1__GetMacBySn, sizeof(_ns1__GetMacBySn), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetMacBySn * SOAP_FMAC2 soap_instantiate__ns1__GetMacBySn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetMacBySn(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetMacBySn *p;
	size_t k = sizeof(_ns1__GetMacBySn);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetMacBySn, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetMacBySn);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetMacBySn, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetMacBySn location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetMacBySn::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetMacBySn(soap, tag ? tag : "ns1:GetMacBySn", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetMacBySn::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetMacBySn(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetMacBySn * SOAP_FMAC4 soap_get__ns1__GetMacBySn(struct soap *soap, _ns1__GetMacBySn *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetMacBySn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GETMACIDResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GETMACIDResponse::GETMACIDResult = NULL;
	/* transient soap skipped */
}

void _ns1__GETMACIDResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GETMACIDResponse_GETMACIDResult(soap, &this->_ns1__GETMACIDResponse::GETMACIDResult);
#endif
}

int _ns1__GETMACIDResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GETMACIDResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GETMACIDResponse(struct soap *soap, const char *tag, int id, const _ns1__GETMACIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GETMACIDResponse), type))
		return soap->error;
	if (a->GETMACIDResult)
		soap_element_result(soap, "ns1:GETMACIDResult");
	if (soap_out_PointerTo_ns1__GETMACIDResponse_GETMACIDResult(soap, "ns1:GETMACIDResult", -1, &a->_ns1__GETMACIDResponse::GETMACIDResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GETMACIDResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GETMACIDResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GETMACIDResponse * SOAP_FMAC4 soap_in__ns1__GETMACIDResponse(struct soap *soap, const char *tag, _ns1__GETMACIDResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GETMACIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GETMACIDResponse, sizeof(_ns1__GETMACIDResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GETMACIDResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GETMACIDResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GETMACIDResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GETMACIDResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GETMACIDResponse_GETMACIDResult(soap, "ns1:GETMACIDResult", &a->_ns1__GETMACIDResponse::GETMACIDResult, ""))
				{	soap_flag_GETMACIDResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GETMACIDResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GETMACIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GETMACIDResponse, SOAP_TYPE__ns1__GETMACIDResponse, sizeof(_ns1__GETMACIDResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GETMACIDResponse * SOAP_FMAC2 soap_instantiate__ns1__GETMACIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GETMACIDResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GETMACIDResponse *p;
	size_t k = sizeof(_ns1__GETMACIDResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GETMACIDResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GETMACIDResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GETMACIDResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GETMACIDResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GETMACIDResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GETMACIDResponse(soap, tag ? tag : "ns1:GETMACIDResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GETMACIDResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GETMACIDResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GETMACIDResponse * SOAP_FMAC4 soap_get__ns1__GETMACIDResponse(struct soap *soap, _ns1__GETMACIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GETMACIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GETMACID::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GETMACID::strSN);
	/* transient soap skipped */
}

void _ns1__GETMACID::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GETMACID::strSN);
#endif
}

int _ns1__GETMACID::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GETMACID(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GETMACID(struct soap *soap, const char *tag, int id, const _ns1__GETMACID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GETMACID), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:strSN", -1, (char*const*)&a->_ns1__GETMACID::strSN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GETMACID::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GETMACID(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GETMACID * SOAP_FMAC4 soap_in__ns1__GETMACID(struct soap *soap, const char *tag, _ns1__GETMACID *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GETMACID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GETMACID, sizeof(_ns1__GETMACID), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GETMACID)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GETMACID *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_strSN1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_strSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:strSN", (char**)&a->_ns1__GETMACID::strSN, "xsd:string"))
				{	soap_flag_strSN1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GETMACID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GETMACID, SOAP_TYPE__ns1__GETMACID, sizeof(_ns1__GETMACID), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GETMACID * SOAP_FMAC2 soap_instantiate__ns1__GETMACID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GETMACID(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GETMACID *p;
	size_t k = sizeof(_ns1__GETMACID);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GETMACID, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GETMACID);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GETMACID, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GETMACID location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GETMACID::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GETMACID(soap, tag ? tag : "ns1:GETMACID", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GETMACID::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GETMACID(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GETMACID * SOAP_FMAC4 soap_get__ns1__GETMACID(struct soap *soap, _ns1__GETMACID *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GETMACID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__testResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__testResponse::testResult = NULL;
	/* transient soap skipped */
}

void _ns1__testResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfAnyType(soap, &this->_ns1__testResponse::testResult);
#endif
}

int _ns1__testResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__testResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__testResponse(struct soap *soap, const char *tag, int id, const _ns1__testResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__testResponse), type))
		return soap->error;
	if (a->testResult)
		soap_element_result(soap, "ns1:testResult");
	if (soap_out_PointerTons1__ArrayOfAnyType(soap, "ns1:testResult", -1, &a->_ns1__testResponse::testResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__testResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__testResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__testResponse * SOAP_FMAC4 soap_in__ns1__testResponse(struct soap *soap, const char *tag, _ns1__testResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__testResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__testResponse, sizeof(_ns1__testResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__testResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__testResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_testResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_testResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfAnyType(soap, "ns1:testResult", &a->_ns1__testResponse::testResult, "ns1:ArrayOfAnyType"))
				{	soap_flag_testResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:testResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__testResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__testResponse, SOAP_TYPE__ns1__testResponse, sizeof(_ns1__testResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__testResponse * SOAP_FMAC2 soap_instantiate__ns1__testResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__testResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__testResponse *p;
	size_t k = sizeof(_ns1__testResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__testResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__testResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__testResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__testResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__testResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__testResponse(soap, tag ? tag : "ns1:testResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__testResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__testResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__testResponse * SOAP_FMAC4 soap_get__ns1__testResponse(struct soap *soap, _ns1__testResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__testResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__test::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__test::strSN);
	soap_default_string(soap, &this->_ns1__test::aa);
	/* transient soap skipped */
}

void _ns1__test::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__test::strSN);
	soap_serialize_string(soap, (char*const*)&this->_ns1__test::aa);
#endif
}

int _ns1__test::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__test(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__test(struct soap *soap, const char *tag, int id, const _ns1__test *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__test), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:strSN", -1, (char*const*)&a->_ns1__test::strSN, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:aa", -1, (char*const*)&a->_ns1__test::aa, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__test::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__test(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__test * SOAP_FMAC4 soap_in__ns1__test(struct soap *soap, const char *tag, _ns1__test *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__test *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__test, sizeof(_ns1__test), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__test)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__test *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_strSN1 = 1;
	size_t soap_flag_aa1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_strSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:strSN", (char**)&a->_ns1__test::strSN, "xsd:string"))
				{	soap_flag_strSN1--;
					continue;
				}
			}
			if (soap_flag_aa1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:aa", (char**)&a->_ns1__test::aa, "xsd:string"))
				{	soap_flag_aa1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__test *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__test, SOAP_TYPE__ns1__test, sizeof(_ns1__test), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__test * SOAP_FMAC2 soap_instantiate__ns1__test(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__test(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__test *p;
	size_t k = sizeof(_ns1__test);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__test, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__test);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__test, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__test location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__test::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__test(soap, tag ? tag : "ns1:test", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__test::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__test(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__test * SOAP_FMAC4 soap_get__ns1__test(struct soap *soap, _ns1__test *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__test(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SaveSSN_USCORENEWResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SaveSSN_USCORENEWResponse::SaveSSN_USCORENEWResult = NULL;
	/* transient soap skipped */
}

void _ns1__SaveSSN_USCORENEWResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfAnyType(soap, &this->_ns1__SaveSSN_USCORENEWResponse::SaveSSN_USCORENEWResult);
#endif
}

int _ns1__SaveSSN_USCORENEWResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SaveSSN_USCORENEWResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SaveSSN_USCORENEWResponse(struct soap *soap, const char *tag, int id, const _ns1__SaveSSN_USCORENEWResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SaveSSN_USCORENEWResponse), type))
		return soap->error;
	if (a->SaveSSN_USCORENEWResult)
		soap_element_result(soap, "ns1:SaveSSN_NEWResult");
	if (soap_out_PointerTons1__ArrayOfAnyType(soap, "ns1:SaveSSN_NEWResult", -1, &a->_ns1__SaveSSN_USCORENEWResponse::SaveSSN_USCORENEWResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SaveSSN_USCORENEWResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SaveSSN_USCORENEWResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SaveSSN_USCORENEWResponse * SOAP_FMAC4 soap_in__ns1__SaveSSN_USCORENEWResponse(struct soap *soap, const char *tag, _ns1__SaveSSN_USCORENEWResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SaveSSN_USCORENEWResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SaveSSN_USCORENEWResponse, sizeof(_ns1__SaveSSN_USCORENEWResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SaveSSN_USCORENEWResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SaveSSN_USCORENEWResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SaveSSN_USCORENEWResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SaveSSN_USCORENEWResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfAnyType(soap, "ns1:SaveSSN_NEWResult", &a->_ns1__SaveSSN_USCORENEWResponse::SaveSSN_USCORENEWResult, "ns1:ArrayOfAnyType"))
				{	soap_flag_SaveSSN_USCORENEWResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:SaveSSN_NEWResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SaveSSN_USCORENEWResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SaveSSN_USCORENEWResponse, SOAP_TYPE__ns1__SaveSSN_USCORENEWResponse, sizeof(_ns1__SaveSSN_USCORENEWResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SaveSSN_USCORENEWResponse * SOAP_FMAC2 soap_instantiate__ns1__SaveSSN_USCORENEWResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SaveSSN_USCORENEWResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SaveSSN_USCORENEWResponse *p;
	size_t k = sizeof(_ns1__SaveSSN_USCORENEWResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__SaveSSN_USCORENEWResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__SaveSSN_USCORENEWResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__SaveSSN_USCORENEWResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SaveSSN_USCORENEWResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__SaveSSN_USCORENEWResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SaveSSN_USCORENEWResponse(soap, tag ? tag : "ns1:SaveSSN_NEWResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SaveSSN_USCORENEWResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SaveSSN_USCORENEWResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SaveSSN_USCORENEWResponse * SOAP_FMAC4 soap_get__ns1__SaveSSN_USCORENEWResponse(struct soap *soap, _ns1__SaveSSN_USCORENEWResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SaveSSN_USCORENEWResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SaveSSN_USCORENEW::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__SaveSSN_USCORENEW::strSSN);
	soap_default_string(soap, &this->_ns1__SaveSSN_USCORENEW::strEventPoint);
	soap_default_string(soap, &this->_ns1__SaveSSN_USCORENEW::strIspass);
	soap_default_string(soap, &this->_ns1__SaveSSN_USCORENEW::strFailcode);
	soap_default_string(soap, &this->_ns1__SaveSSN_USCORENEW::strScanner);
	/* transient soap skipped */
}

void _ns1__SaveSSN_USCORENEW::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__SaveSSN_USCORENEW::strSSN);
	soap_serialize_string(soap, (char*const*)&this->_ns1__SaveSSN_USCORENEW::strEventPoint);
	soap_serialize_string(soap, (char*const*)&this->_ns1__SaveSSN_USCORENEW::strIspass);
	soap_serialize_string(soap, (char*const*)&this->_ns1__SaveSSN_USCORENEW::strFailcode);
	soap_serialize_string(soap, (char*const*)&this->_ns1__SaveSSN_USCORENEW::strScanner);
#endif
}

int _ns1__SaveSSN_USCORENEW::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SaveSSN_USCORENEW(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SaveSSN_USCORENEW(struct soap *soap, const char *tag, int id, const _ns1__SaveSSN_USCORENEW *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SaveSSN_USCORENEW), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:strSSN", -1, (char*const*)&a->_ns1__SaveSSN_USCORENEW::strSSN, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:strEventPoint", -1, (char*const*)&a->_ns1__SaveSSN_USCORENEW::strEventPoint, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:strIspass", -1, (char*const*)&a->_ns1__SaveSSN_USCORENEW::strIspass, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:strFailcode", -1, (char*const*)&a->_ns1__SaveSSN_USCORENEW::strFailcode, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:strScanner", -1, (char*const*)&a->_ns1__SaveSSN_USCORENEW::strScanner, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SaveSSN_USCORENEW::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SaveSSN_USCORENEW(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SaveSSN_USCORENEW * SOAP_FMAC4 soap_in__ns1__SaveSSN_USCORENEW(struct soap *soap, const char *tag, _ns1__SaveSSN_USCORENEW *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SaveSSN_USCORENEW *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SaveSSN_USCORENEW, sizeof(_ns1__SaveSSN_USCORENEW), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SaveSSN_USCORENEW)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SaveSSN_USCORENEW *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_strSSN1 = 1;
	size_t soap_flag_strEventPoint1 = 1;
	size_t soap_flag_strIspass1 = 1;
	size_t soap_flag_strFailcode1 = 1;
	size_t soap_flag_strScanner1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_strSSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:strSSN", (char**)&a->_ns1__SaveSSN_USCORENEW::strSSN, "xsd:string"))
				{	soap_flag_strSSN1--;
					continue;
				}
			}
			if (soap_flag_strEventPoint1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:strEventPoint", (char**)&a->_ns1__SaveSSN_USCORENEW::strEventPoint, "xsd:string"))
				{	soap_flag_strEventPoint1--;
					continue;
				}
			}
			if (soap_flag_strIspass1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:strIspass", (char**)&a->_ns1__SaveSSN_USCORENEW::strIspass, "xsd:string"))
				{	soap_flag_strIspass1--;
					continue;
				}
			}
			if (soap_flag_strFailcode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:strFailcode", (char**)&a->_ns1__SaveSSN_USCORENEW::strFailcode, "xsd:string"))
				{	soap_flag_strFailcode1--;
					continue;
				}
			}
			if (soap_flag_strScanner1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:strScanner", (char**)&a->_ns1__SaveSSN_USCORENEW::strScanner, "xsd:string"))
				{	soap_flag_strScanner1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SaveSSN_USCORENEW *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SaveSSN_USCORENEW, SOAP_TYPE__ns1__SaveSSN_USCORENEW, sizeof(_ns1__SaveSSN_USCORENEW), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SaveSSN_USCORENEW * SOAP_FMAC2 soap_instantiate__ns1__SaveSSN_USCORENEW(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SaveSSN_USCORENEW(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SaveSSN_USCORENEW *p;
	size_t k = sizeof(_ns1__SaveSSN_USCORENEW);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__SaveSSN_USCORENEW, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__SaveSSN_USCORENEW);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__SaveSSN_USCORENEW, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SaveSSN_USCORENEW location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__SaveSSN_USCORENEW::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SaveSSN_USCORENEW(soap, tag ? tag : "ns1:SaveSSN_NEW", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SaveSSN_USCORENEW::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SaveSSN_USCORENEW(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SaveSSN_USCORENEW * SOAP_FMAC4 soap_get__ns1__SaveSSN_USCORENEW(struct soap *soap, _ns1__SaveSSN_USCORENEW *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SaveSSN_USCORENEW(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SfcTestResult_USCOREUploadResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SfcTestResult_USCOREUploadResponse::SfcTestResult_USCOREUploadResult = NULL;
	/* transient soap skipped */
}

void _ns1__SfcTestResult_USCOREUploadResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfAnyType(soap, &this->_ns1__SfcTestResult_USCOREUploadResponse::SfcTestResult_USCOREUploadResult);
#endif
}

int _ns1__SfcTestResult_USCOREUploadResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SfcTestResult_USCOREUploadResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SfcTestResult_USCOREUploadResponse(struct soap *soap, const char *tag, int id, const _ns1__SfcTestResult_USCOREUploadResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SfcTestResult_USCOREUploadResponse), type))
		return soap->error;
	if (a->SfcTestResult_USCOREUploadResult)
		soap_element_result(soap, "ns1:SfcTestResult_UploadResult");
	if (soap_out_PointerTons1__ArrayOfAnyType(soap, "ns1:SfcTestResult_UploadResult", -1, &a->_ns1__SfcTestResult_USCOREUploadResponse::SfcTestResult_USCOREUploadResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SfcTestResult_USCOREUploadResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SfcTestResult_USCOREUploadResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SfcTestResult_USCOREUploadResponse * SOAP_FMAC4 soap_in__ns1__SfcTestResult_USCOREUploadResponse(struct soap *soap, const char *tag, _ns1__SfcTestResult_USCOREUploadResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SfcTestResult_USCOREUploadResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SfcTestResult_USCOREUploadResponse, sizeof(_ns1__SfcTestResult_USCOREUploadResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SfcTestResult_USCOREUploadResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SfcTestResult_USCOREUploadResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SfcTestResult_USCOREUploadResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SfcTestResult_USCOREUploadResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfAnyType(soap, "ns1:SfcTestResult_UploadResult", &a->_ns1__SfcTestResult_USCOREUploadResponse::SfcTestResult_USCOREUploadResult, "ns1:ArrayOfAnyType"))
				{	soap_flag_SfcTestResult_USCOREUploadResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:SfcTestResult_UploadResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SfcTestResult_USCOREUploadResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SfcTestResult_USCOREUploadResponse, SOAP_TYPE__ns1__SfcTestResult_USCOREUploadResponse, sizeof(_ns1__SfcTestResult_USCOREUploadResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SfcTestResult_USCOREUploadResponse * SOAP_FMAC2 soap_instantiate__ns1__SfcTestResult_USCOREUploadResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SfcTestResult_USCOREUploadResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SfcTestResult_USCOREUploadResponse *p;
	size_t k = sizeof(_ns1__SfcTestResult_USCOREUploadResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__SfcTestResult_USCOREUploadResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__SfcTestResult_USCOREUploadResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__SfcTestResult_USCOREUploadResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SfcTestResult_USCOREUploadResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__SfcTestResult_USCOREUploadResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SfcTestResult_USCOREUploadResponse(soap, tag ? tag : "ns1:SfcTestResult_UploadResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SfcTestResult_USCOREUploadResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SfcTestResult_USCOREUploadResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SfcTestResult_USCOREUploadResponse * SOAP_FMAC4 soap_get__ns1__SfcTestResult_USCOREUploadResponse(struct soap *soap, _ns1__SfcTestResult_USCOREUploadResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SfcTestResult_USCOREUploadResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SfcTestResult_USCOREUpload::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__SfcTestResult_USCOREUpload::strEventPoint);
	soap_default_string(soap, &this->_ns1__SfcTestResult_USCOREUpload::strSSN);
	soap_default_string(soap, &this->_ns1__SfcTestResult_USCOREUpload::testresult);
	soap_default_dateTime(soap, &this->_ns1__SfcTestResult_USCOREUpload::testtime);
	soap_default_string(soap, &this->_ns1__SfcTestResult_USCOREUpload::testitem);
	soap_default_string(soap, &this->_ns1__SfcTestResult_USCOREUpload::testvalue);
	soap_default_string(soap, &this->_ns1__SfcTestResult_USCOREUpload::strScanner);
	/* transient soap skipped */
}

void _ns1__SfcTestResult_USCOREUpload::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__SfcTestResult_USCOREUpload::strEventPoint);
	soap_serialize_string(soap, (char*const*)&this->_ns1__SfcTestResult_USCOREUpload::strSSN);
	soap_serialize_string(soap, (char*const*)&this->_ns1__SfcTestResult_USCOREUpload::testresult);
	soap_serialize_string(soap, (char*const*)&this->_ns1__SfcTestResult_USCOREUpload::testitem);
	soap_serialize_string(soap, (char*const*)&this->_ns1__SfcTestResult_USCOREUpload::testvalue);
	soap_serialize_string(soap, (char*const*)&this->_ns1__SfcTestResult_USCOREUpload::strScanner);
#endif
}

int _ns1__SfcTestResult_USCOREUpload::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SfcTestResult_USCOREUpload(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SfcTestResult_USCOREUpload(struct soap *soap, const char *tag, int id, const _ns1__SfcTestResult_USCOREUpload *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SfcTestResult_USCOREUpload), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:strEventPoint", -1, (char*const*)&a->_ns1__SfcTestResult_USCOREUpload::strEventPoint, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:strSSN", -1, (char*const*)&a->_ns1__SfcTestResult_USCOREUpload::strSSN, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:testresult", -1, (char*const*)&a->_ns1__SfcTestResult_USCOREUpload::testresult, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:testtime", -1, &a->_ns1__SfcTestResult_USCOREUpload::testtime, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:testitem", -1, (char*const*)&a->_ns1__SfcTestResult_USCOREUpload::testitem, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:testvalue", -1, (char*const*)&a->_ns1__SfcTestResult_USCOREUpload::testvalue, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:strScanner", -1, (char*const*)&a->_ns1__SfcTestResult_USCOREUpload::strScanner, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SfcTestResult_USCOREUpload::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SfcTestResult_USCOREUpload(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SfcTestResult_USCOREUpload * SOAP_FMAC4 soap_in__ns1__SfcTestResult_USCOREUpload(struct soap *soap, const char *tag, _ns1__SfcTestResult_USCOREUpload *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SfcTestResult_USCOREUpload *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SfcTestResult_USCOREUpload, sizeof(_ns1__SfcTestResult_USCOREUpload), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SfcTestResult_USCOREUpload)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SfcTestResult_USCOREUpload *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_strEventPoint1 = 1;
	size_t soap_flag_strSSN1 = 1;
	size_t soap_flag_testresult1 = 1;
	size_t soap_flag_testtime1 = 1;
	size_t soap_flag_testitem1 = 1;
	size_t soap_flag_testvalue1 = 1;
	size_t soap_flag_strScanner1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_strEventPoint1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:strEventPoint", (char**)&a->_ns1__SfcTestResult_USCOREUpload::strEventPoint, "xsd:string"))
				{	soap_flag_strEventPoint1--;
					continue;
				}
			}
			if (soap_flag_strSSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:strSSN", (char**)&a->_ns1__SfcTestResult_USCOREUpload::strSSN, "xsd:string"))
				{	soap_flag_strSSN1--;
					continue;
				}
			}
			if (soap_flag_testresult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:testresult", (char**)&a->_ns1__SfcTestResult_USCOREUpload::testresult, "xsd:string"))
				{	soap_flag_testresult1--;
					continue;
				}
			}
			if (soap_flag_testtime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:testtime", &a->_ns1__SfcTestResult_USCOREUpload::testtime, "xsd:dateTime"))
				{	soap_flag_testtime1--;
					continue;
				}
			}
			if (soap_flag_testitem1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:testitem", (char**)&a->_ns1__SfcTestResult_USCOREUpload::testitem, "xsd:string"))
				{	soap_flag_testitem1--;
					continue;
				}
			}
			if (soap_flag_testvalue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:testvalue", (char**)&a->_ns1__SfcTestResult_USCOREUpload::testvalue, "xsd:string"))
				{	soap_flag_testvalue1--;
					continue;
				}
			}
			if (soap_flag_strScanner1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:strScanner", (char**)&a->_ns1__SfcTestResult_USCOREUpload::strScanner, "xsd:string"))
				{	soap_flag_strScanner1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_testtime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__SfcTestResult_USCOREUpload *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SfcTestResult_USCOREUpload, SOAP_TYPE__ns1__SfcTestResult_USCOREUpload, sizeof(_ns1__SfcTestResult_USCOREUpload), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SfcTestResult_USCOREUpload * SOAP_FMAC2 soap_instantiate__ns1__SfcTestResult_USCOREUpload(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SfcTestResult_USCOREUpload(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SfcTestResult_USCOREUpload *p;
	size_t k = sizeof(_ns1__SfcTestResult_USCOREUpload);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__SfcTestResult_USCOREUpload, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__SfcTestResult_USCOREUpload);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__SfcTestResult_USCOREUpload, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SfcTestResult_USCOREUpload location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__SfcTestResult_USCOREUpload::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SfcTestResult_USCOREUpload(soap, tag ? tag : "ns1:SfcTestResult_Upload", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SfcTestResult_USCOREUpload::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SfcTestResult_USCOREUpload(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SfcTestResult_USCOREUpload * SOAP_FMAC4 soap_get__ns1__SfcTestResult_USCOREUpload(struct soap *soap, _ns1__SfcTestResult_USCOREUpload *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SfcTestResult_USCOREUpload(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__QueryBindingResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__QueryBindingResponse::QueryBindingResult = NULL;
	/* transient soap skipped */
}

void _ns1__QueryBindingResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfAnyType(soap, &this->_ns1__QueryBindingResponse::QueryBindingResult);
#endif
}

int _ns1__QueryBindingResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__QueryBindingResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__QueryBindingResponse(struct soap *soap, const char *tag, int id, const _ns1__QueryBindingResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__QueryBindingResponse), type))
		return soap->error;
	if (a->QueryBindingResult)
		soap_element_result(soap, "ns1:QueryBindingResult");
	if (soap_out_PointerTons1__ArrayOfAnyType(soap, "ns1:QueryBindingResult", -1, &a->_ns1__QueryBindingResponse::QueryBindingResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__QueryBindingResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__QueryBindingResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__QueryBindingResponse * SOAP_FMAC4 soap_in__ns1__QueryBindingResponse(struct soap *soap, const char *tag, _ns1__QueryBindingResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__QueryBindingResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__QueryBindingResponse, sizeof(_ns1__QueryBindingResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__QueryBindingResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__QueryBindingResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_QueryBindingResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_QueryBindingResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfAnyType(soap, "ns1:QueryBindingResult", &a->_ns1__QueryBindingResponse::QueryBindingResult, "ns1:ArrayOfAnyType"))
				{	soap_flag_QueryBindingResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:QueryBindingResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__QueryBindingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__QueryBindingResponse, SOAP_TYPE__ns1__QueryBindingResponse, sizeof(_ns1__QueryBindingResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__QueryBindingResponse * SOAP_FMAC2 soap_instantiate__ns1__QueryBindingResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__QueryBindingResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__QueryBindingResponse *p;
	size_t k = sizeof(_ns1__QueryBindingResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__QueryBindingResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__QueryBindingResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__QueryBindingResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__QueryBindingResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__QueryBindingResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__QueryBindingResponse(soap, tag ? tag : "ns1:QueryBindingResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__QueryBindingResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__QueryBindingResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__QueryBindingResponse * SOAP_FMAC4 soap_get__ns1__QueryBindingResponse(struct soap *soap, _ns1__QueryBindingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__QueryBindingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__QueryBinding::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__QueryBinding::DataType);
	soap_default_string(soap, &this->_ns1__QueryBinding::DataValue);
	soap_default_string(soap, &this->_ns1__QueryBinding::querytype);
	/* transient soap skipped */
}

void _ns1__QueryBinding::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__QueryBinding::DataType);
	soap_serialize_string(soap, (char*const*)&this->_ns1__QueryBinding::DataValue);
	soap_serialize_string(soap, (char*const*)&this->_ns1__QueryBinding::querytype);
#endif
}

int _ns1__QueryBinding::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__QueryBinding(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__QueryBinding(struct soap *soap, const char *tag, int id, const _ns1__QueryBinding *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__QueryBinding), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:DataType", -1, (char*const*)&a->_ns1__QueryBinding::DataType, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DataValue", -1, (char*const*)&a->_ns1__QueryBinding::DataValue, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:querytype", -1, (char*const*)&a->_ns1__QueryBinding::querytype, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__QueryBinding::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__QueryBinding(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__QueryBinding * SOAP_FMAC4 soap_in__ns1__QueryBinding(struct soap *soap, const char *tag, _ns1__QueryBinding *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__QueryBinding *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__QueryBinding, sizeof(_ns1__QueryBinding), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__QueryBinding)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__QueryBinding *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DataType1 = 1;
	size_t soap_flag_DataValue1 = 1;
	size_t soap_flag_querytype1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DataType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:DataType", (char**)&a->_ns1__QueryBinding::DataType, "xsd:string"))
				{	soap_flag_DataType1--;
					continue;
				}
			}
			if (soap_flag_DataValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:DataValue", (char**)&a->_ns1__QueryBinding::DataValue, "xsd:string"))
				{	soap_flag_DataValue1--;
					continue;
				}
			}
			if (soap_flag_querytype1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:querytype", (char**)&a->_ns1__QueryBinding::querytype, "xsd:string"))
				{	soap_flag_querytype1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__QueryBinding *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__QueryBinding, SOAP_TYPE__ns1__QueryBinding, sizeof(_ns1__QueryBinding), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__QueryBinding * SOAP_FMAC2 soap_instantiate__ns1__QueryBinding(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__QueryBinding(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__QueryBinding *p;
	size_t k = sizeof(_ns1__QueryBinding);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__QueryBinding, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__QueryBinding);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__QueryBinding, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__QueryBinding location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__QueryBinding::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__QueryBinding(soap, tag ? tag : "ns1:QueryBinding", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__QueryBinding::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__QueryBinding(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__QueryBinding * SOAP_FMAC4 soap_get__ns1__QueryBinding(struct soap *soap, _ns1__QueryBinding *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__QueryBinding(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__BindingResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__BindingResponse::BindingResult = NULL;
	/* transient soap skipped */
}

void _ns1__BindingResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfAnyType(soap, &this->_ns1__BindingResponse::BindingResult);
#endif
}

int _ns1__BindingResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__BindingResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__BindingResponse(struct soap *soap, const char *tag, int id, const _ns1__BindingResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__BindingResponse), type))
		return soap->error;
	if (a->BindingResult)
		soap_element_result(soap, "ns1:BindingResult");
	if (soap_out_PointerTons1__ArrayOfAnyType(soap, "ns1:BindingResult", -1, &a->_ns1__BindingResponse::BindingResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__BindingResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__BindingResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__BindingResponse * SOAP_FMAC4 soap_in__ns1__BindingResponse(struct soap *soap, const char *tag, _ns1__BindingResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__BindingResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__BindingResponse, sizeof(_ns1__BindingResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__BindingResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__BindingResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_BindingResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BindingResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfAnyType(soap, "ns1:BindingResult", &a->_ns1__BindingResponse::BindingResult, "ns1:ArrayOfAnyType"))
				{	soap_flag_BindingResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:BindingResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__BindingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__BindingResponse, SOAP_TYPE__ns1__BindingResponse, sizeof(_ns1__BindingResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__BindingResponse * SOAP_FMAC2 soap_instantiate__ns1__BindingResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__BindingResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__BindingResponse *p;
	size_t k = sizeof(_ns1__BindingResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__BindingResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__BindingResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__BindingResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__BindingResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__BindingResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__BindingResponse(soap, tag ? tag : "ns1:BindingResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__BindingResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__BindingResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__BindingResponse * SOAP_FMAC4 soap_get__ns1__BindingResponse(struct soap *soap, _ns1__BindingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__BindingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__Binding::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__Binding::ssn);
	soap_default_string(soap, &this->_ns1__Binding::csn);
	soap_default_string(soap, &this->_ns1__Binding::key);
	soap_default_string(soap, &this->_ns1__Binding::station);
	soap_default_string(soap, &this->_ns1__Binding::user);
	/* transient soap skipped */
}

void _ns1__Binding::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__Binding::ssn);
	soap_serialize_string(soap, (char*const*)&this->_ns1__Binding::csn);
	soap_serialize_string(soap, (char*const*)&this->_ns1__Binding::key);
	soap_serialize_string(soap, (char*const*)&this->_ns1__Binding::station);
	soap_serialize_string(soap, (char*const*)&this->_ns1__Binding::user);
#endif
}

int _ns1__Binding::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__Binding(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Binding(struct soap *soap, const char *tag, int id, const _ns1__Binding *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__Binding), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:ssn", -1, (char*const*)&a->_ns1__Binding::ssn, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:csn", -1, (char*const*)&a->_ns1__Binding::csn, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:key", -1, (char*const*)&a->_ns1__Binding::key, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:station", -1, (char*const*)&a->_ns1__Binding::station, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:user", -1, (char*const*)&a->_ns1__Binding::user, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__Binding::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__Binding(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__Binding * SOAP_FMAC4 soap_in__ns1__Binding(struct soap *soap, const char *tag, _ns1__Binding *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__Binding *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__Binding, sizeof(_ns1__Binding), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__Binding)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__Binding *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ssn1 = 1;
	size_t soap_flag_csn1 = 1;
	size_t soap_flag_key1 = 1;
	size_t soap_flag_station1 = 1;
	size_t soap_flag_user1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ssn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:ssn", (char**)&a->_ns1__Binding::ssn, "xsd:string"))
				{	soap_flag_ssn1--;
					continue;
				}
			}
			if (soap_flag_csn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:csn", (char**)&a->_ns1__Binding::csn, "xsd:string"))
				{	soap_flag_csn1--;
					continue;
				}
			}
			if (soap_flag_key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:key", (char**)&a->_ns1__Binding::key, "xsd:string"))
				{	soap_flag_key1--;
					continue;
				}
			}
			if (soap_flag_station1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:station", (char**)&a->_ns1__Binding::station, "xsd:string"))
				{	soap_flag_station1--;
					continue;
				}
			}
			if (soap_flag_user1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:user", (char**)&a->_ns1__Binding::user, "xsd:string"))
				{	soap_flag_user1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__Binding *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__Binding, SOAP_TYPE__ns1__Binding, sizeof(_ns1__Binding), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__Binding * SOAP_FMAC2 soap_instantiate__ns1__Binding(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__Binding(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__Binding *p;
	size_t k = sizeof(_ns1__Binding);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__Binding, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__Binding);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__Binding, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__Binding location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__Binding::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__Binding(soap, tag ? tag : "ns1:Binding", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__Binding::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__Binding(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__Binding * SOAP_FMAC4 soap_get__ns1__Binding(struct soap *soap, _ns1__Binding *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Binding(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CheckSSN_USCORENEWResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__CheckSSN_USCORENEWResponse::CheckSSN_USCORENEWResult = NULL;
	/* transient soap skipped */
}

void _ns1__CheckSSN_USCORENEWResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfAnyType(soap, &this->_ns1__CheckSSN_USCORENEWResponse::CheckSSN_USCORENEWResult);
#endif
}

int _ns1__CheckSSN_USCORENEWResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CheckSSN_USCORENEWResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CheckSSN_USCORENEWResponse(struct soap *soap, const char *tag, int id, const _ns1__CheckSSN_USCORENEWResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CheckSSN_USCORENEWResponse), type))
		return soap->error;
	if (a->CheckSSN_USCORENEWResult)
		soap_element_result(soap, "ns1:CheckSSN_NEWResult");
	if (soap_out_PointerTons1__ArrayOfAnyType(soap, "ns1:CheckSSN_NEWResult", -1, &a->_ns1__CheckSSN_USCORENEWResponse::CheckSSN_USCORENEWResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CheckSSN_USCORENEWResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CheckSSN_USCORENEWResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CheckSSN_USCORENEWResponse * SOAP_FMAC4 soap_in__ns1__CheckSSN_USCORENEWResponse(struct soap *soap, const char *tag, _ns1__CheckSSN_USCORENEWResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CheckSSN_USCORENEWResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CheckSSN_USCORENEWResponse, sizeof(_ns1__CheckSSN_USCORENEWResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__CheckSSN_USCORENEWResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__CheckSSN_USCORENEWResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CheckSSN_USCORENEWResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CheckSSN_USCORENEWResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfAnyType(soap, "ns1:CheckSSN_NEWResult", &a->_ns1__CheckSSN_USCORENEWResponse::CheckSSN_USCORENEWResult, "ns1:ArrayOfAnyType"))
				{	soap_flag_CheckSSN_USCORENEWResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:CheckSSN_NEWResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CheckSSN_USCORENEWResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CheckSSN_USCORENEWResponse, SOAP_TYPE__ns1__CheckSSN_USCORENEWResponse, sizeof(_ns1__CheckSSN_USCORENEWResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CheckSSN_USCORENEWResponse * SOAP_FMAC2 soap_instantiate__ns1__CheckSSN_USCORENEWResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CheckSSN_USCORENEWResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CheckSSN_USCORENEWResponse *p;
	size_t k = sizeof(_ns1__CheckSSN_USCORENEWResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__CheckSSN_USCORENEWResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__CheckSSN_USCORENEWResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__CheckSSN_USCORENEWResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CheckSSN_USCORENEWResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__CheckSSN_USCORENEWResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__CheckSSN_USCORENEWResponse(soap, tag ? tag : "ns1:CheckSSN_NEWResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CheckSSN_USCORENEWResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CheckSSN_USCORENEWResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CheckSSN_USCORENEWResponse * SOAP_FMAC4 soap_get__ns1__CheckSSN_USCORENEWResponse(struct soap *soap, _ns1__CheckSSN_USCORENEWResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CheckSSN_USCORENEWResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CheckSSN_USCORENEW::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__CheckSSN_USCORENEW::strSN);
	soap_default_string(soap, &this->_ns1__CheckSSN_USCORENEW::station);
	/* transient soap skipped */
}

void _ns1__CheckSSN_USCORENEW::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__CheckSSN_USCORENEW::strSN);
	soap_serialize_string(soap, (char*const*)&this->_ns1__CheckSSN_USCORENEW::station);
#endif
}

int _ns1__CheckSSN_USCORENEW::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CheckSSN_USCORENEW(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CheckSSN_USCORENEW(struct soap *soap, const char *tag, int id, const _ns1__CheckSSN_USCORENEW *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CheckSSN_USCORENEW), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:strSN", -1, (char*const*)&a->_ns1__CheckSSN_USCORENEW::strSN, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:station", -1, (char*const*)&a->_ns1__CheckSSN_USCORENEW::station, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CheckSSN_USCORENEW::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CheckSSN_USCORENEW(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CheckSSN_USCORENEW * SOAP_FMAC4 soap_in__ns1__CheckSSN_USCORENEW(struct soap *soap, const char *tag, _ns1__CheckSSN_USCORENEW *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CheckSSN_USCORENEW *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CheckSSN_USCORENEW, sizeof(_ns1__CheckSSN_USCORENEW), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__CheckSSN_USCORENEW)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__CheckSSN_USCORENEW *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_strSN1 = 1;
	size_t soap_flag_station1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_strSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:strSN", (char**)&a->_ns1__CheckSSN_USCORENEW::strSN, "xsd:string"))
				{	soap_flag_strSN1--;
					continue;
				}
			}
			if (soap_flag_station1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:station", (char**)&a->_ns1__CheckSSN_USCORENEW::station, "xsd:string"))
				{	soap_flag_station1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CheckSSN_USCORENEW *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CheckSSN_USCORENEW, SOAP_TYPE__ns1__CheckSSN_USCORENEW, sizeof(_ns1__CheckSSN_USCORENEW), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CheckSSN_USCORENEW * SOAP_FMAC2 soap_instantiate__ns1__CheckSSN_USCORENEW(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CheckSSN_USCORENEW(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CheckSSN_USCORENEW *p;
	size_t k = sizeof(_ns1__CheckSSN_USCORENEW);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__CheckSSN_USCORENEW, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__CheckSSN_USCORENEW);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__CheckSSN_USCORENEW, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CheckSSN_USCORENEW location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__CheckSSN_USCORENEW::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__CheckSSN_USCORENEW(soap, tag ? tag : "ns1:CheckSSN_NEW", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CheckSSN_USCORENEW::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CheckSSN_USCORENEW(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CheckSSN_USCORENEW * SOAP_FMAC4 soap_get__ns1__CheckSSN_USCORENEW(struct soap *soap, _ns1__CheckSSN_USCORENEW *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CheckSSN_USCORENEW(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CheckSSNResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__CheckSSNResponse::CheckSSNResult = NULL;
	/* transient soap skipped */
}

void _ns1__CheckSSNResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfAnyType(soap, &this->_ns1__CheckSSNResponse::CheckSSNResult);
#endif
}

int _ns1__CheckSSNResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CheckSSNResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CheckSSNResponse(struct soap *soap, const char *tag, int id, const _ns1__CheckSSNResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CheckSSNResponse), type))
		return soap->error;
	if (a->CheckSSNResult)
		soap_element_result(soap, "ns1:CheckSSNResult");
	if (soap_out_PointerTons1__ArrayOfAnyType(soap, "ns1:CheckSSNResult", -1, &a->_ns1__CheckSSNResponse::CheckSSNResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CheckSSNResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CheckSSNResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CheckSSNResponse * SOAP_FMAC4 soap_in__ns1__CheckSSNResponse(struct soap *soap, const char *tag, _ns1__CheckSSNResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CheckSSNResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CheckSSNResponse, sizeof(_ns1__CheckSSNResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__CheckSSNResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__CheckSSNResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CheckSSNResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CheckSSNResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfAnyType(soap, "ns1:CheckSSNResult", &a->_ns1__CheckSSNResponse::CheckSSNResult, "ns1:ArrayOfAnyType"))
				{	soap_flag_CheckSSNResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:CheckSSNResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CheckSSNResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CheckSSNResponse, SOAP_TYPE__ns1__CheckSSNResponse, sizeof(_ns1__CheckSSNResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CheckSSNResponse * SOAP_FMAC2 soap_instantiate__ns1__CheckSSNResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CheckSSNResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CheckSSNResponse *p;
	size_t k = sizeof(_ns1__CheckSSNResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__CheckSSNResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__CheckSSNResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__CheckSSNResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CheckSSNResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__CheckSSNResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__CheckSSNResponse(soap, tag ? tag : "ns1:CheckSSNResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CheckSSNResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CheckSSNResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CheckSSNResponse * SOAP_FMAC4 soap_get__ns1__CheckSSNResponse(struct soap *soap, _ns1__CheckSSNResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CheckSSNResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CheckSSN::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__CheckSSN::strSN);
	/* transient soap skipped */
}

void _ns1__CheckSSN::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__CheckSSN::strSN);
#endif
}

int _ns1__CheckSSN::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CheckSSN(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CheckSSN(struct soap *soap, const char *tag, int id, const _ns1__CheckSSN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CheckSSN), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:strSN", -1, (char*const*)&a->_ns1__CheckSSN::strSN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CheckSSN::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CheckSSN(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CheckSSN * SOAP_FMAC4 soap_in__ns1__CheckSSN(struct soap *soap, const char *tag, _ns1__CheckSSN *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CheckSSN *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CheckSSN, sizeof(_ns1__CheckSSN), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__CheckSSN)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__CheckSSN *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_strSN1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_strSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:strSN", (char**)&a->_ns1__CheckSSN::strSN, "xsd:string"))
				{	soap_flag_strSN1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CheckSSN *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CheckSSN, SOAP_TYPE__ns1__CheckSSN, sizeof(_ns1__CheckSSN), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CheckSSN * SOAP_FMAC2 soap_instantiate__ns1__CheckSSN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CheckSSN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CheckSSN *p;
	size_t k = sizeof(_ns1__CheckSSN);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__CheckSSN, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__CheckSSN);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__CheckSSN, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CheckSSN location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__CheckSSN::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__CheckSSN(soap, tag ? tag : "ns1:CheckSSN", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CheckSSN::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CheckSSN(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CheckSSN * SOAP_FMAC4 soap_get__ns1__CheckSSN(struct soap *soap, _ns1__CheckSSN *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CheckSSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__UploadTestResultResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__UploadTestResultResponse::UploadTestResultResult = NULL;
	/* transient soap skipped */
}

void _ns1__UploadTestResultResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfAnyType(soap, &this->_ns1__UploadTestResultResponse::UploadTestResultResult);
#endif
}

int _ns1__UploadTestResultResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UploadTestResultResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UploadTestResultResponse(struct soap *soap, const char *tag, int id, const _ns1__UploadTestResultResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UploadTestResultResponse), type))
		return soap->error;
	if (a->UploadTestResultResult)
		soap_element_result(soap, "ns1:UploadTestResultResult");
	if (soap_out_PointerTons1__ArrayOfAnyType(soap, "ns1:UploadTestResultResult", -1, &a->_ns1__UploadTestResultResponse::UploadTestResultResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__UploadTestResultResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UploadTestResultResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UploadTestResultResponse * SOAP_FMAC4 soap_in__ns1__UploadTestResultResponse(struct soap *soap, const char *tag, _ns1__UploadTestResultResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UploadTestResultResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UploadTestResultResponse, sizeof(_ns1__UploadTestResultResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__UploadTestResultResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__UploadTestResultResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_UploadTestResultResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UploadTestResultResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfAnyType(soap, "ns1:UploadTestResultResult", &a->_ns1__UploadTestResultResponse::UploadTestResultResult, "ns1:ArrayOfAnyType"))
				{	soap_flag_UploadTestResultResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:UploadTestResultResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UploadTestResultResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UploadTestResultResponse, SOAP_TYPE__ns1__UploadTestResultResponse, sizeof(_ns1__UploadTestResultResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__UploadTestResultResponse * SOAP_FMAC2 soap_instantiate__ns1__UploadTestResultResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UploadTestResultResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__UploadTestResultResponse *p;
	size_t k = sizeof(_ns1__UploadTestResultResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__UploadTestResultResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__UploadTestResultResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__UploadTestResultResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__UploadTestResultResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__UploadTestResultResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__UploadTestResultResponse(soap, tag ? tag : "ns1:UploadTestResultResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UploadTestResultResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UploadTestResultResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UploadTestResultResponse * SOAP_FMAC4 soap_get__ns1__UploadTestResultResponse(struct soap *soap, _ns1__UploadTestResultResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UploadTestResultResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__UploadTestResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__UploadTestResult::objs = NULL;
	/* transient soap skipped */
}

void _ns1__UploadTestResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfAnyType(soap, &this->_ns1__UploadTestResult::objs);
#endif
}

int _ns1__UploadTestResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UploadTestResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UploadTestResult(struct soap *soap, const char *tag, int id, const _ns1__UploadTestResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UploadTestResult), type))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfAnyType(soap, "ns1:objs", -1, &a->_ns1__UploadTestResult::objs, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__UploadTestResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UploadTestResult(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UploadTestResult * SOAP_FMAC4 soap_in__ns1__UploadTestResult(struct soap *soap, const char *tag, _ns1__UploadTestResult *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UploadTestResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UploadTestResult, sizeof(_ns1__UploadTestResult), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__UploadTestResult)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__UploadTestResult *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_objs1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_objs1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfAnyType(soap, "ns1:objs", &a->_ns1__UploadTestResult::objs, "ns1:ArrayOfAnyType"))
				{	soap_flag_objs1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UploadTestResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UploadTestResult, SOAP_TYPE__ns1__UploadTestResult, sizeof(_ns1__UploadTestResult), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__UploadTestResult * SOAP_FMAC2 soap_instantiate__ns1__UploadTestResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UploadTestResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__UploadTestResult *p;
	size_t k = sizeof(_ns1__UploadTestResult);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__UploadTestResult, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__UploadTestResult);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__UploadTestResult, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__UploadTestResult location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__UploadTestResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__UploadTestResult(soap, tag ? tag : "ns1:UploadTestResult", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UploadTestResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UploadTestResult(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UploadTestResult * SOAP_FMAC4 soap_get__ns1__UploadTestResult(struct soap *soap, _ns1__UploadTestResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UploadTestResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__DoFunctionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__DoFunctionResponse::DoFunctionResult = NULL;
	/* transient soap skipped */
}

void _ns1__DoFunctionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfAnyType(soap, &this->_ns1__DoFunctionResponse::DoFunctionResult);
#endif
}

int _ns1__DoFunctionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DoFunctionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DoFunctionResponse(struct soap *soap, const char *tag, int id, const _ns1__DoFunctionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DoFunctionResponse), type))
		return soap->error;
	if (a->DoFunctionResult)
		soap_element_result(soap, "ns1:DoFunctionResult");
	if (soap_out_PointerTons1__ArrayOfAnyType(soap, "ns1:DoFunctionResult", -1, &a->_ns1__DoFunctionResponse::DoFunctionResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__DoFunctionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DoFunctionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DoFunctionResponse * SOAP_FMAC4 soap_in__ns1__DoFunctionResponse(struct soap *soap, const char *tag, _ns1__DoFunctionResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DoFunctionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DoFunctionResponse, sizeof(_ns1__DoFunctionResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__DoFunctionResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__DoFunctionResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DoFunctionResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DoFunctionResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfAnyType(soap, "ns1:DoFunctionResult", &a->_ns1__DoFunctionResponse::DoFunctionResult, "ns1:ArrayOfAnyType"))
				{	soap_flag_DoFunctionResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:DoFunctionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__DoFunctionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DoFunctionResponse, SOAP_TYPE__ns1__DoFunctionResponse, sizeof(_ns1__DoFunctionResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__DoFunctionResponse * SOAP_FMAC2 soap_instantiate__ns1__DoFunctionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DoFunctionResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__DoFunctionResponse *p;
	size_t k = sizeof(_ns1__DoFunctionResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__DoFunctionResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__DoFunctionResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__DoFunctionResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__DoFunctionResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__DoFunctionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__DoFunctionResponse(soap, tag ? tag : "ns1:DoFunctionResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DoFunctionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DoFunctionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DoFunctionResponse * SOAP_FMAC4 soap_get__ns1__DoFunctionResponse(struct soap *soap, _ns1__DoFunctionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DoFunctionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__DoFunction::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__DoFunction::FunctionName);
	this->_ns1__DoFunction::objs = NULL;
	/* transient soap skipped */
}

void _ns1__DoFunction::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__DoFunction::FunctionName);
	soap_serialize_PointerTons1__ArrayOfAnyType(soap, &this->_ns1__DoFunction::objs);
#endif
}

int _ns1__DoFunction::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DoFunction(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DoFunction(struct soap *soap, const char *tag, int id, const _ns1__DoFunction *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DoFunction), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:FunctionName", -1, (char*const*)&a->_ns1__DoFunction::FunctionName, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfAnyType(soap, "ns1:objs", -1, &a->_ns1__DoFunction::objs, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__DoFunction::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DoFunction(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DoFunction * SOAP_FMAC4 soap_in__ns1__DoFunction(struct soap *soap, const char *tag, _ns1__DoFunction *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DoFunction *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DoFunction, sizeof(_ns1__DoFunction), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__DoFunction)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__DoFunction *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FunctionName1 = 1;
	size_t soap_flag_objs1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FunctionName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:FunctionName", (char**)&a->_ns1__DoFunction::FunctionName, "xsd:string"))
				{	soap_flag_FunctionName1--;
					continue;
				}
			}
			if (soap_flag_objs1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfAnyType(soap, "ns1:objs", &a->_ns1__DoFunction::objs, "ns1:ArrayOfAnyType"))
				{	soap_flag_objs1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__DoFunction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DoFunction, SOAP_TYPE__ns1__DoFunction, sizeof(_ns1__DoFunction), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__DoFunction * SOAP_FMAC2 soap_instantiate__ns1__DoFunction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DoFunction(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__DoFunction *p;
	size_t k = sizeof(_ns1__DoFunction);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__DoFunction, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__DoFunction);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__DoFunction, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__DoFunction location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__DoFunction::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__DoFunction(soap, tag ? tag : "ns1:DoFunction", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DoFunction::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DoFunction(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DoFunction * SOAP_FMAC4 soap_get__ns1__DoFunction(struct soap *soap, _ns1__DoFunction *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DoFunction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ArrayOfAnyType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfAnyType::__sizeanyType = 0;
	this->ns1__ArrayOfAnyType::anyType = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfAnyType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns1__ArrayOfAnyType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfAnyType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfAnyType(struct soap *soap, const char *tag, int id, const ns1__ArrayOfAnyType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfAnyType), type))
		return soap->error;
	if (a->ns1__ArrayOfAnyType::anyType)
	{	int i;
		for (i = 0; i < (int)a->ns1__ArrayOfAnyType::__sizeanyType; i++)
			if (soap_outliteral(soap, "ns1:anyType", (char*const*)(a->ns1__ArrayOfAnyType::anyType + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfAnyType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfAnyType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfAnyType * SOAP_FMAC4 soap_in_ns1__ArrayOfAnyType(struct soap *soap, const char *tag, ns1__ArrayOfAnyType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfAnyType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfAnyType, sizeof(ns1__ArrayOfAnyType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ArrayOfAnyType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ArrayOfAnyType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	struct soap_blist *soap_blist_anyType1 = NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:anyType", 1, NULL))
			{	if (a->ns1__ArrayOfAnyType::anyType == NULL)
				{	if (soap_blist_anyType1 == NULL)
						soap_blist_anyType1 = soap_alloc_block(soap);
					a->ns1__ArrayOfAnyType::anyType = (char **)soap_push_block_max(soap, soap_blist_anyType1, sizeof(char *));
					if (a->ns1__ArrayOfAnyType::anyType == NULL)
						return NULL;
					*a->ns1__ArrayOfAnyType::anyType = NULL;
				}
				soap_revert(soap);
				if (soap_inliteral(soap, "ns1:anyType", (char**)a->ns1__ArrayOfAnyType::anyType))
				{	a->ns1__ArrayOfAnyType::__sizeanyType++;
					a->ns1__ArrayOfAnyType::anyType = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfAnyType::anyType)
			soap_pop_block(soap, soap_blist_anyType1);
		if (a->ns1__ArrayOfAnyType::__sizeanyType)
		{	a->ns1__ArrayOfAnyType::anyType = (char **)soap_save_block(soap, soap_blist_anyType1, NULL, 1);
		}
		else
		{	a->ns1__ArrayOfAnyType::anyType = NULL;
			if (soap_blist_anyType1)
				soap_end_block(soap, soap_blist_anyType1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfAnyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfAnyType, SOAP_TYPE_ns1__ArrayOfAnyType, sizeof(ns1__ArrayOfAnyType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ArrayOfAnyType * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfAnyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfAnyType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ArrayOfAnyType *p;
	size_t k = sizeof(ns1__ArrayOfAnyType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ArrayOfAnyType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ArrayOfAnyType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ArrayOfAnyType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ArrayOfAnyType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ArrayOfAnyType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ArrayOfAnyType(soap, tag ? tag : "ns1:ArrayOfAnyType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfAnyType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfAnyType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfAnyType * SOAP_FMAC4 soap_get_ns1__ArrayOfAnyType(struct soap *soap, ns1__ArrayOfAnyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfAnyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__BlindKeyNum_(struct soap *soap, struct __ns1__BlindKeyNum_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__BlindKeyNum = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__BlindKeyNum_(struct soap *soap, const struct __ns1__BlindKeyNum_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__BlindKeyNum(soap, &a->ns1__BlindKeyNum);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__BlindKeyNum_(struct soap *soap, const char *tag, int id, const struct __ns1__BlindKeyNum_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__BlindKeyNum(soap, "ns1:BlindKeyNum", -1, &a->ns1__BlindKeyNum, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BlindKeyNum_ * SOAP_FMAC4 soap_in___ns1__BlindKeyNum_(struct soap *soap, const char *tag, struct __ns1__BlindKeyNum_ *a, const char *type)
{
	size_t soap_flag_ns1__BlindKeyNum = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__BlindKeyNum_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__BlindKeyNum_, sizeof(struct __ns1__BlindKeyNum_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__BlindKeyNum_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__BlindKeyNum && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__BlindKeyNum(soap, "ns1:BlindKeyNum", &a->ns1__BlindKeyNum, ""))
				{	soap_flag_ns1__BlindKeyNum--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__BlindKeyNum_ * SOAP_FMAC2 soap_instantiate___ns1__BlindKeyNum_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__BlindKeyNum_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__BlindKeyNum_ *p;
	size_t k = sizeof(struct __ns1__BlindKeyNum_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__BlindKeyNum_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__BlindKeyNum_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__BlindKeyNum_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__BlindKeyNum_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__BlindKeyNum_(struct soap *soap, const struct __ns1__BlindKeyNum_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__BlindKeyNum_(soap, tag ? tag : "-ns1:BlindKeyNum", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BlindKeyNum_ * SOAP_FMAC4 soap_get___ns1__BlindKeyNum_(struct soap *soap, struct __ns1__BlindKeyNum_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__BlindKeyNum_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetSparrowCheckData_(struct soap *soap, struct __ns1__GetSparrowCheckData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetSparrowCheckData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetSparrowCheckData_(struct soap *soap, const struct __ns1__GetSparrowCheckData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetSparrowCheckData(soap, &a->ns1__GetSparrowCheckData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetSparrowCheckData_(struct soap *soap, const char *tag, int id, const struct __ns1__GetSparrowCheckData_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetSparrowCheckData(soap, "ns1:GetSparrowCheckData", -1, &a->ns1__GetSparrowCheckData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetSparrowCheckData_ * SOAP_FMAC4 soap_in___ns1__GetSparrowCheckData_(struct soap *soap, const char *tag, struct __ns1__GetSparrowCheckData_ *a, const char *type)
{
	size_t soap_flag_ns1__GetSparrowCheckData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetSparrowCheckData_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetSparrowCheckData_, sizeof(struct __ns1__GetSparrowCheckData_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetSparrowCheckData_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetSparrowCheckData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetSparrowCheckData(soap, "ns1:GetSparrowCheckData", &a->ns1__GetSparrowCheckData, ""))
				{	soap_flag_ns1__GetSparrowCheckData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetSparrowCheckData_ * SOAP_FMAC2 soap_instantiate___ns1__GetSparrowCheckData_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetSparrowCheckData_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetSparrowCheckData_ *p;
	size_t k = sizeof(struct __ns1__GetSparrowCheckData_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetSparrowCheckData_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetSparrowCheckData_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetSparrowCheckData_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetSparrowCheckData_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetSparrowCheckData_(struct soap *soap, const struct __ns1__GetSparrowCheckData_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetSparrowCheckData_(soap, tag ? tag : "-ns1:GetSparrowCheckData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetSparrowCheckData_ * SOAP_FMAC4 soap_get___ns1__GetSparrowCheckData_(struct soap *soap, struct __ns1__GetSparrowCheckData_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetSparrowCheckData_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__BindKey_(struct soap *soap, struct __ns1__BindKey_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__BindKey = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__BindKey_(struct soap *soap, const struct __ns1__BindKey_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__BindKey(soap, &a->ns1__BindKey);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__BindKey_(struct soap *soap, const char *tag, int id, const struct __ns1__BindKey_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__BindKey(soap, "ns1:BindKey", -1, &a->ns1__BindKey, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BindKey_ * SOAP_FMAC4 soap_in___ns1__BindKey_(struct soap *soap, const char *tag, struct __ns1__BindKey_ *a, const char *type)
{
	size_t soap_flag_ns1__BindKey = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__BindKey_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__BindKey_, sizeof(struct __ns1__BindKey_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__BindKey_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__BindKey && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__BindKey(soap, "ns1:BindKey", &a->ns1__BindKey, ""))
				{	soap_flag_ns1__BindKey--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__BindKey_ * SOAP_FMAC2 soap_instantiate___ns1__BindKey_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__BindKey_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__BindKey_ *p;
	size_t k = sizeof(struct __ns1__BindKey_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__BindKey_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__BindKey_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__BindKey_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__BindKey_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__BindKey_(struct soap *soap, const struct __ns1__BindKey_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__BindKey_(soap, tag ? tag : "-ns1:BindKey", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BindKey_ * SOAP_FMAC4 soap_get___ns1__BindKey_(struct soap *soap, struct __ns1__BindKey_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__BindKey_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ReleaseKey_(struct soap *soap, struct __ns1__ReleaseKey_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ReleaseKey = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ReleaseKey_(struct soap *soap, const struct __ns1__ReleaseKey_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ReleaseKey(soap, &a->ns1__ReleaseKey);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ReleaseKey_(struct soap *soap, const char *tag, int id, const struct __ns1__ReleaseKey_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ReleaseKey(soap, "ns1:ReleaseKey", -1, &a->ns1__ReleaseKey, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ReleaseKey_ * SOAP_FMAC4 soap_in___ns1__ReleaseKey_(struct soap *soap, const char *tag, struct __ns1__ReleaseKey_ *a, const char *type)
{
	size_t soap_flag_ns1__ReleaseKey = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ReleaseKey_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ReleaseKey_, sizeof(struct __ns1__ReleaseKey_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ReleaseKey_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ReleaseKey && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ReleaseKey(soap, "ns1:ReleaseKey", &a->ns1__ReleaseKey, ""))
				{	soap_flag_ns1__ReleaseKey--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ReleaseKey_ * SOAP_FMAC2 soap_instantiate___ns1__ReleaseKey_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ReleaseKey_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ReleaseKey_ *p;
	size_t k = sizeof(struct __ns1__ReleaseKey_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__ReleaseKey_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__ReleaseKey_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__ReleaseKey_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ReleaseKey_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ReleaseKey_(struct soap *soap, const struct __ns1__ReleaseKey_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ReleaseKey_(soap, tag ? tag : "-ns1:ReleaseKey", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ReleaseKey_ * SOAP_FMAC4 soap_get___ns1__ReleaseKey_(struct soap *soap, struct __ns1__ReleaseKey_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ReleaseKey_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetShaoluKey_(struct soap *soap, struct __ns1__GetShaoluKey_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetShaoluKey = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetShaoluKey_(struct soap *soap, const struct __ns1__GetShaoluKey_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetShaoluKey(soap, &a->ns1__GetShaoluKey);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetShaoluKey_(struct soap *soap, const char *tag, int id, const struct __ns1__GetShaoluKey_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetShaoluKey(soap, "ns1:GetShaoluKey", -1, &a->ns1__GetShaoluKey, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetShaoluKey_ * SOAP_FMAC4 soap_in___ns1__GetShaoluKey_(struct soap *soap, const char *tag, struct __ns1__GetShaoluKey_ *a, const char *type)
{
	size_t soap_flag_ns1__GetShaoluKey = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetShaoluKey_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetShaoluKey_, sizeof(struct __ns1__GetShaoluKey_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetShaoluKey_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetShaoluKey && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetShaoluKey(soap, "ns1:GetShaoluKey", &a->ns1__GetShaoluKey, ""))
				{	soap_flag_ns1__GetShaoluKey--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetShaoluKey_ * SOAP_FMAC2 soap_instantiate___ns1__GetShaoluKey_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetShaoluKey_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetShaoluKey_ *p;
	size_t k = sizeof(struct __ns1__GetShaoluKey_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetShaoluKey_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetShaoluKey_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetShaoluKey_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetShaoluKey_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetShaoluKey_(struct soap *soap, const struct __ns1__GetShaoluKey_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetShaoluKey_(soap, tag ? tag : "-ns1:GetShaoluKey", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetShaoluKey_ * SOAP_FMAC4 soap_get___ns1__GetShaoluKey_(struct soap *soap, struct __ns1__GetShaoluKey_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetShaoluKey_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__PCBData_USCOREUpload_(struct soap *soap, struct __ns1__PCBData_USCOREUpload_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__PCBData_USCOREUpload = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__PCBData_USCOREUpload_(struct soap *soap, const struct __ns1__PCBData_USCOREUpload_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__PCBData_USCOREUpload(soap, &a->ns1__PCBData_USCOREUpload);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__PCBData_USCOREUpload_(struct soap *soap, const char *tag, int id, const struct __ns1__PCBData_USCOREUpload_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__PCBData_USCOREUpload(soap, "ns1:PCBData_Upload", -1, &a->ns1__PCBData_USCOREUpload, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__PCBData_USCOREUpload_ * SOAP_FMAC4 soap_in___ns1__PCBData_USCOREUpload_(struct soap *soap, const char *tag, struct __ns1__PCBData_USCOREUpload_ *a, const char *type)
{
	size_t soap_flag_ns1__PCBData_USCOREUpload = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__PCBData_USCOREUpload_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__PCBData_USCOREUpload_, sizeof(struct __ns1__PCBData_USCOREUpload_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__PCBData_USCOREUpload_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__PCBData_USCOREUpload && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__PCBData_USCOREUpload(soap, "ns1:PCBData_Upload", &a->ns1__PCBData_USCOREUpload, ""))
				{	soap_flag_ns1__PCBData_USCOREUpload--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__PCBData_USCOREUpload_ * SOAP_FMAC2 soap_instantiate___ns1__PCBData_USCOREUpload_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__PCBData_USCOREUpload_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__PCBData_USCOREUpload_ *p;
	size_t k = sizeof(struct __ns1__PCBData_USCOREUpload_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__PCBData_USCOREUpload_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__PCBData_USCOREUpload_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__PCBData_USCOREUpload_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__PCBData_USCOREUpload_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__PCBData_USCOREUpload_(struct soap *soap, const struct __ns1__PCBData_USCOREUpload_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__PCBData_USCOREUpload_(soap, tag ? tag : "-ns1:PCBData_Upload", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__PCBData_USCOREUpload_ * SOAP_FMAC4 soap_get___ns1__PCBData_USCOREUpload_(struct soap *soap, struct __ns1__PCBData_USCOREUpload_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__PCBData_USCOREUpload_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CartonWeight_USCOREUpload_(struct soap *soap, struct __ns1__CartonWeight_USCOREUpload_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CartonWeight_USCOREUpload = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CartonWeight_USCOREUpload_(struct soap *soap, const struct __ns1__CartonWeight_USCOREUpload_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CartonWeight_USCOREUpload(soap, &a->ns1__CartonWeight_USCOREUpload);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CartonWeight_USCOREUpload_(struct soap *soap, const char *tag, int id, const struct __ns1__CartonWeight_USCOREUpload_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CartonWeight_USCOREUpload(soap, "ns1:CartonWeight_Upload", -1, &a->ns1__CartonWeight_USCOREUpload, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CartonWeight_USCOREUpload_ * SOAP_FMAC4 soap_in___ns1__CartonWeight_USCOREUpload_(struct soap *soap, const char *tag, struct __ns1__CartonWeight_USCOREUpload_ *a, const char *type)
{
	size_t soap_flag_ns1__CartonWeight_USCOREUpload = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CartonWeight_USCOREUpload_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CartonWeight_USCOREUpload_, sizeof(struct __ns1__CartonWeight_USCOREUpload_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CartonWeight_USCOREUpload_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CartonWeight_USCOREUpload && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__CartonWeight_USCOREUpload(soap, "ns1:CartonWeight_Upload", &a->ns1__CartonWeight_USCOREUpload, ""))
				{	soap_flag_ns1__CartonWeight_USCOREUpload--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CartonWeight_USCOREUpload_ * SOAP_FMAC2 soap_instantiate___ns1__CartonWeight_USCOREUpload_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CartonWeight_USCOREUpload_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CartonWeight_USCOREUpload_ *p;
	size_t k = sizeof(struct __ns1__CartonWeight_USCOREUpload_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__CartonWeight_USCOREUpload_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__CartonWeight_USCOREUpload_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__CartonWeight_USCOREUpload_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CartonWeight_USCOREUpload_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CartonWeight_USCOREUpload_(struct soap *soap, const struct __ns1__CartonWeight_USCOREUpload_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CartonWeight_USCOREUpload_(soap, tag ? tag : "-ns1:CartonWeight_Upload", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CartonWeight_USCOREUpload_ * SOAP_FMAC4 soap_get___ns1__CartonWeight_USCOREUpload_(struct soap *soap, struct __ns1__CartonWeight_USCOREUpload_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CartonWeight_USCOREUpload_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetMacBySn_(struct soap *soap, struct __ns1__GetMacBySn_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetMacBySn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetMacBySn_(struct soap *soap, const struct __ns1__GetMacBySn_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetMacBySn(soap, &a->ns1__GetMacBySn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetMacBySn_(struct soap *soap, const char *tag, int id, const struct __ns1__GetMacBySn_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetMacBySn(soap, "ns1:GetMacBySn", -1, &a->ns1__GetMacBySn, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMacBySn_ * SOAP_FMAC4 soap_in___ns1__GetMacBySn_(struct soap *soap, const char *tag, struct __ns1__GetMacBySn_ *a, const char *type)
{
	size_t soap_flag_ns1__GetMacBySn = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetMacBySn_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetMacBySn_, sizeof(struct __ns1__GetMacBySn_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetMacBySn_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetMacBySn && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetMacBySn(soap, "ns1:GetMacBySn", &a->ns1__GetMacBySn, ""))
				{	soap_flag_ns1__GetMacBySn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetMacBySn_ * SOAP_FMAC2 soap_instantiate___ns1__GetMacBySn_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetMacBySn_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetMacBySn_ *p;
	size_t k = sizeof(struct __ns1__GetMacBySn_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetMacBySn_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetMacBySn_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetMacBySn_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetMacBySn_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetMacBySn_(struct soap *soap, const struct __ns1__GetMacBySn_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetMacBySn_(soap, tag ? tag : "-ns1:GetMacBySn", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMacBySn_ * SOAP_FMAC4 soap_get___ns1__GetMacBySn_(struct soap *soap, struct __ns1__GetMacBySn_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetMacBySn_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GETMACID_(struct soap *soap, struct __ns1__GETMACID_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GETMACID = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GETMACID_(struct soap *soap, const struct __ns1__GETMACID_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GETMACID(soap, &a->ns1__GETMACID);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GETMACID_(struct soap *soap, const char *tag, int id, const struct __ns1__GETMACID_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GETMACID(soap, "ns1:GETMACID", -1, &a->ns1__GETMACID, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GETMACID_ * SOAP_FMAC4 soap_in___ns1__GETMACID_(struct soap *soap, const char *tag, struct __ns1__GETMACID_ *a, const char *type)
{
	size_t soap_flag_ns1__GETMACID = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GETMACID_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GETMACID_, sizeof(struct __ns1__GETMACID_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GETMACID_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GETMACID && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GETMACID(soap, "ns1:GETMACID", &a->ns1__GETMACID, ""))
				{	soap_flag_ns1__GETMACID--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GETMACID_ * SOAP_FMAC2 soap_instantiate___ns1__GETMACID_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GETMACID_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GETMACID_ *p;
	size_t k = sizeof(struct __ns1__GETMACID_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GETMACID_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GETMACID_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GETMACID_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GETMACID_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GETMACID_(struct soap *soap, const struct __ns1__GETMACID_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GETMACID_(soap, tag ? tag : "-ns1:GETMACID", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GETMACID_ * SOAP_FMAC4 soap_get___ns1__GETMACID_(struct soap *soap, struct __ns1__GETMACID_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GETMACID_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__test_(struct soap *soap, struct __ns1__test_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__test = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__test_(struct soap *soap, const struct __ns1__test_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__test(soap, &a->ns1__test);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__test_(struct soap *soap, const char *tag, int id, const struct __ns1__test_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__test(soap, "ns1:test", -1, &a->ns1__test, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__test_ * SOAP_FMAC4 soap_in___ns1__test_(struct soap *soap, const char *tag, struct __ns1__test_ *a, const char *type)
{
	size_t soap_flag_ns1__test = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__test_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__test_, sizeof(struct __ns1__test_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__test_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__test && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__test(soap, "ns1:test", &a->ns1__test, ""))
				{	soap_flag_ns1__test--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__test_ * SOAP_FMAC2 soap_instantiate___ns1__test_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__test_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__test_ *p;
	size_t k = sizeof(struct __ns1__test_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__test_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__test_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__test_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__test_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__test_(struct soap *soap, const struct __ns1__test_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__test_(soap, tag ? tag : "-ns1:test", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__test_ * SOAP_FMAC4 soap_get___ns1__test_(struct soap *soap, struct __ns1__test_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__test_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SaveSSN_USCORENEW_(struct soap *soap, struct __ns1__SaveSSN_USCORENEW_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SaveSSN_USCORENEW = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SaveSSN_USCORENEW_(struct soap *soap, const struct __ns1__SaveSSN_USCORENEW_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SaveSSN_USCORENEW(soap, &a->ns1__SaveSSN_USCORENEW);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SaveSSN_USCORENEW_(struct soap *soap, const char *tag, int id, const struct __ns1__SaveSSN_USCORENEW_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SaveSSN_USCORENEW(soap, "ns1:SaveSSN_NEW", -1, &a->ns1__SaveSSN_USCORENEW, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SaveSSN_USCORENEW_ * SOAP_FMAC4 soap_in___ns1__SaveSSN_USCORENEW_(struct soap *soap, const char *tag, struct __ns1__SaveSSN_USCORENEW_ *a, const char *type)
{
	size_t soap_flag_ns1__SaveSSN_USCORENEW = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SaveSSN_USCORENEW_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SaveSSN_USCORENEW_, sizeof(struct __ns1__SaveSSN_USCORENEW_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SaveSSN_USCORENEW_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SaveSSN_USCORENEW && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SaveSSN_USCORENEW(soap, "ns1:SaveSSN_NEW", &a->ns1__SaveSSN_USCORENEW, ""))
				{	soap_flag_ns1__SaveSSN_USCORENEW--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SaveSSN_USCORENEW_ * SOAP_FMAC2 soap_instantiate___ns1__SaveSSN_USCORENEW_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SaveSSN_USCORENEW_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SaveSSN_USCORENEW_ *p;
	size_t k = sizeof(struct __ns1__SaveSSN_USCORENEW_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__SaveSSN_USCORENEW_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__SaveSSN_USCORENEW_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__SaveSSN_USCORENEW_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SaveSSN_USCORENEW_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SaveSSN_USCORENEW_(struct soap *soap, const struct __ns1__SaveSSN_USCORENEW_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SaveSSN_USCORENEW_(soap, tag ? tag : "-ns1:SaveSSN_NEW", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SaveSSN_USCORENEW_ * SOAP_FMAC4 soap_get___ns1__SaveSSN_USCORENEW_(struct soap *soap, struct __ns1__SaveSSN_USCORENEW_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SaveSSN_USCORENEW_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SfcTestResult_USCOREUpload_(struct soap *soap, struct __ns1__SfcTestResult_USCOREUpload_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SfcTestResult_USCOREUpload = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SfcTestResult_USCOREUpload_(struct soap *soap, const struct __ns1__SfcTestResult_USCOREUpload_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SfcTestResult_USCOREUpload(soap, &a->ns1__SfcTestResult_USCOREUpload);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SfcTestResult_USCOREUpload_(struct soap *soap, const char *tag, int id, const struct __ns1__SfcTestResult_USCOREUpload_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SfcTestResult_USCOREUpload(soap, "ns1:SfcTestResult_Upload", -1, &a->ns1__SfcTestResult_USCOREUpload, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SfcTestResult_USCOREUpload_ * SOAP_FMAC4 soap_in___ns1__SfcTestResult_USCOREUpload_(struct soap *soap, const char *tag, struct __ns1__SfcTestResult_USCOREUpload_ *a, const char *type)
{
	size_t soap_flag_ns1__SfcTestResult_USCOREUpload = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SfcTestResult_USCOREUpload_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SfcTestResult_USCOREUpload_, sizeof(struct __ns1__SfcTestResult_USCOREUpload_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SfcTestResult_USCOREUpload_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SfcTestResult_USCOREUpload && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SfcTestResult_USCOREUpload(soap, "ns1:SfcTestResult_Upload", &a->ns1__SfcTestResult_USCOREUpload, ""))
				{	soap_flag_ns1__SfcTestResult_USCOREUpload--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SfcTestResult_USCOREUpload_ * SOAP_FMAC2 soap_instantiate___ns1__SfcTestResult_USCOREUpload_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SfcTestResult_USCOREUpload_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SfcTestResult_USCOREUpload_ *p;
	size_t k = sizeof(struct __ns1__SfcTestResult_USCOREUpload_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__SfcTestResult_USCOREUpload_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__SfcTestResult_USCOREUpload_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__SfcTestResult_USCOREUpload_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SfcTestResult_USCOREUpload_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SfcTestResult_USCOREUpload_(struct soap *soap, const struct __ns1__SfcTestResult_USCOREUpload_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SfcTestResult_USCOREUpload_(soap, tag ? tag : "-ns1:SfcTestResult_Upload", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SfcTestResult_USCOREUpload_ * SOAP_FMAC4 soap_get___ns1__SfcTestResult_USCOREUpload_(struct soap *soap, struct __ns1__SfcTestResult_USCOREUpload_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SfcTestResult_USCOREUpload_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__QueryBinding_(struct soap *soap, struct __ns1__QueryBinding_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__QueryBinding = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__QueryBinding_(struct soap *soap, const struct __ns1__QueryBinding_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__QueryBinding(soap, &a->ns1__QueryBinding);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__QueryBinding_(struct soap *soap, const char *tag, int id, const struct __ns1__QueryBinding_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__QueryBinding(soap, "ns1:QueryBinding", -1, &a->ns1__QueryBinding, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QueryBinding_ * SOAP_FMAC4 soap_in___ns1__QueryBinding_(struct soap *soap, const char *tag, struct __ns1__QueryBinding_ *a, const char *type)
{
	size_t soap_flag_ns1__QueryBinding = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__QueryBinding_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__QueryBinding_, sizeof(struct __ns1__QueryBinding_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__QueryBinding_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__QueryBinding && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__QueryBinding(soap, "ns1:QueryBinding", &a->ns1__QueryBinding, ""))
				{	soap_flag_ns1__QueryBinding--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__QueryBinding_ * SOAP_FMAC2 soap_instantiate___ns1__QueryBinding_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__QueryBinding_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__QueryBinding_ *p;
	size_t k = sizeof(struct __ns1__QueryBinding_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__QueryBinding_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__QueryBinding_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__QueryBinding_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__QueryBinding_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__QueryBinding_(struct soap *soap, const struct __ns1__QueryBinding_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__QueryBinding_(soap, tag ? tag : "-ns1:QueryBinding", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QueryBinding_ * SOAP_FMAC4 soap_get___ns1__QueryBinding_(struct soap *soap, struct __ns1__QueryBinding_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__QueryBinding_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Binding_(struct soap *soap, struct __ns1__Binding_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Binding = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Binding_(struct soap *soap, const struct __ns1__Binding_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Binding(soap, &a->ns1__Binding);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Binding_(struct soap *soap, const char *tag, int id, const struct __ns1__Binding_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Binding(soap, "ns1:Binding", -1, &a->ns1__Binding, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Binding_ * SOAP_FMAC4 soap_in___ns1__Binding_(struct soap *soap, const char *tag, struct __ns1__Binding_ *a, const char *type)
{
	size_t soap_flag_ns1__Binding = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Binding_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Binding_, sizeof(struct __ns1__Binding_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Binding_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Binding && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__Binding(soap, "ns1:Binding", &a->ns1__Binding, ""))
				{	soap_flag_ns1__Binding--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Binding_ * SOAP_FMAC2 soap_instantiate___ns1__Binding_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Binding_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Binding_ *p;
	size_t k = sizeof(struct __ns1__Binding_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__Binding_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__Binding_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__Binding_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Binding_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Binding_(struct soap *soap, const struct __ns1__Binding_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Binding_(soap, tag ? tag : "-ns1:Binding", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Binding_ * SOAP_FMAC4 soap_get___ns1__Binding_(struct soap *soap, struct __ns1__Binding_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Binding_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CheckSSN_USCORENEW_(struct soap *soap, struct __ns1__CheckSSN_USCORENEW_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CheckSSN_USCORENEW = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CheckSSN_USCORENEW_(struct soap *soap, const struct __ns1__CheckSSN_USCORENEW_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CheckSSN_USCORENEW(soap, &a->ns1__CheckSSN_USCORENEW);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CheckSSN_USCORENEW_(struct soap *soap, const char *tag, int id, const struct __ns1__CheckSSN_USCORENEW_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CheckSSN_USCORENEW(soap, "ns1:CheckSSN_NEW", -1, &a->ns1__CheckSSN_USCORENEW, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CheckSSN_USCORENEW_ * SOAP_FMAC4 soap_in___ns1__CheckSSN_USCORENEW_(struct soap *soap, const char *tag, struct __ns1__CheckSSN_USCORENEW_ *a, const char *type)
{
	size_t soap_flag_ns1__CheckSSN_USCORENEW = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CheckSSN_USCORENEW_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CheckSSN_USCORENEW_, sizeof(struct __ns1__CheckSSN_USCORENEW_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CheckSSN_USCORENEW_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CheckSSN_USCORENEW && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__CheckSSN_USCORENEW(soap, "ns1:CheckSSN_NEW", &a->ns1__CheckSSN_USCORENEW, ""))
				{	soap_flag_ns1__CheckSSN_USCORENEW--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CheckSSN_USCORENEW_ * SOAP_FMAC2 soap_instantiate___ns1__CheckSSN_USCORENEW_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CheckSSN_USCORENEW_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CheckSSN_USCORENEW_ *p;
	size_t k = sizeof(struct __ns1__CheckSSN_USCORENEW_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__CheckSSN_USCORENEW_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__CheckSSN_USCORENEW_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__CheckSSN_USCORENEW_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CheckSSN_USCORENEW_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CheckSSN_USCORENEW_(struct soap *soap, const struct __ns1__CheckSSN_USCORENEW_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CheckSSN_USCORENEW_(soap, tag ? tag : "-ns1:CheckSSN_NEW", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CheckSSN_USCORENEW_ * SOAP_FMAC4 soap_get___ns1__CheckSSN_USCORENEW_(struct soap *soap, struct __ns1__CheckSSN_USCORENEW_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CheckSSN_USCORENEW_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CheckSSN_(struct soap *soap, struct __ns1__CheckSSN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CheckSSN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CheckSSN_(struct soap *soap, const struct __ns1__CheckSSN_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CheckSSN(soap, &a->ns1__CheckSSN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CheckSSN_(struct soap *soap, const char *tag, int id, const struct __ns1__CheckSSN_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CheckSSN(soap, "ns1:CheckSSN", -1, &a->ns1__CheckSSN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CheckSSN_ * SOAP_FMAC4 soap_in___ns1__CheckSSN_(struct soap *soap, const char *tag, struct __ns1__CheckSSN_ *a, const char *type)
{
	size_t soap_flag_ns1__CheckSSN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CheckSSN_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CheckSSN_, sizeof(struct __ns1__CheckSSN_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CheckSSN_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CheckSSN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__CheckSSN(soap, "ns1:CheckSSN", &a->ns1__CheckSSN, ""))
				{	soap_flag_ns1__CheckSSN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CheckSSN_ * SOAP_FMAC2 soap_instantiate___ns1__CheckSSN_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CheckSSN_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CheckSSN_ *p;
	size_t k = sizeof(struct __ns1__CheckSSN_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__CheckSSN_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__CheckSSN_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__CheckSSN_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CheckSSN_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CheckSSN_(struct soap *soap, const struct __ns1__CheckSSN_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CheckSSN_(soap, tag ? tag : "-ns1:CheckSSN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CheckSSN_ * SOAP_FMAC4 soap_get___ns1__CheckSSN_(struct soap *soap, struct __ns1__CheckSSN_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CheckSSN_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UploadTestResult_(struct soap *soap, struct __ns1__UploadTestResult_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UploadTestResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UploadTestResult_(struct soap *soap, const struct __ns1__UploadTestResult_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__UploadTestResult(soap, &a->ns1__UploadTestResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UploadTestResult_(struct soap *soap, const char *tag, int id, const struct __ns1__UploadTestResult_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__UploadTestResult(soap, "ns1:UploadTestResult", -1, &a->ns1__UploadTestResult, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UploadTestResult_ * SOAP_FMAC4 soap_in___ns1__UploadTestResult_(struct soap *soap, const char *tag, struct __ns1__UploadTestResult_ *a, const char *type)
{
	size_t soap_flag_ns1__UploadTestResult = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__UploadTestResult_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UploadTestResult_, sizeof(struct __ns1__UploadTestResult_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UploadTestResult_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UploadTestResult && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__UploadTestResult(soap, "ns1:UploadTestResult", &a->ns1__UploadTestResult, ""))
				{	soap_flag_ns1__UploadTestResult--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__UploadTestResult_ * SOAP_FMAC2 soap_instantiate___ns1__UploadTestResult_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UploadTestResult_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__UploadTestResult_ *p;
	size_t k = sizeof(struct __ns1__UploadTestResult_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__UploadTestResult_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__UploadTestResult_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__UploadTestResult_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__UploadTestResult_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UploadTestResult_(struct soap *soap, const struct __ns1__UploadTestResult_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__UploadTestResult_(soap, tag ? tag : "-ns1:UploadTestResult", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UploadTestResult_ * SOAP_FMAC4 soap_get___ns1__UploadTestResult_(struct soap *soap, struct __ns1__UploadTestResult_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UploadTestResult_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DoFunction_(struct soap *soap, struct __ns1__DoFunction_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DoFunction = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DoFunction_(struct soap *soap, const struct __ns1__DoFunction_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__DoFunction(soap, &a->ns1__DoFunction);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DoFunction_(struct soap *soap, const char *tag, int id, const struct __ns1__DoFunction_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__DoFunction(soap, "ns1:DoFunction", -1, &a->ns1__DoFunction, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DoFunction_ * SOAP_FMAC4 soap_in___ns1__DoFunction_(struct soap *soap, const char *tag, struct __ns1__DoFunction_ *a, const char *type)
{
	size_t soap_flag_ns1__DoFunction = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__DoFunction_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__DoFunction_, sizeof(struct __ns1__DoFunction_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DoFunction_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DoFunction && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__DoFunction(soap, "ns1:DoFunction", &a->ns1__DoFunction, ""))
				{	soap_flag_ns1__DoFunction--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__DoFunction_ * SOAP_FMAC2 soap_instantiate___ns1__DoFunction_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__DoFunction_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__DoFunction_ *p;
	size_t k = sizeof(struct __ns1__DoFunction_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__DoFunction_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__DoFunction_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__DoFunction_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__DoFunction_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DoFunction_(struct soap *soap, const struct __ns1__DoFunction_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__DoFunction_(soap, tag ? tag : "-ns1:DoFunction", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DoFunction_ * SOAP_FMAC4 soap_get___ns1__DoFunction_(struct soap *soap, struct __ns1__DoFunction_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DoFunction_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__BlindKeyNum(struct soap *soap, struct __ns1__BlindKeyNum *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__BlindKeyNum = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__BlindKeyNum(struct soap *soap, const struct __ns1__BlindKeyNum *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__BlindKeyNum(soap, &a->ns1__BlindKeyNum);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__BlindKeyNum(struct soap *soap, const char *tag, int id, const struct __ns1__BlindKeyNum *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__BlindKeyNum(soap, "ns1:BlindKeyNum", -1, &a->ns1__BlindKeyNum, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BlindKeyNum * SOAP_FMAC4 soap_in___ns1__BlindKeyNum(struct soap *soap, const char *tag, struct __ns1__BlindKeyNum *a, const char *type)
{
	size_t soap_flag_ns1__BlindKeyNum = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__BlindKeyNum *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__BlindKeyNum, sizeof(struct __ns1__BlindKeyNum), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__BlindKeyNum(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__BlindKeyNum && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__BlindKeyNum(soap, "ns1:BlindKeyNum", &a->ns1__BlindKeyNum, ""))
				{	soap_flag_ns1__BlindKeyNum--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__BlindKeyNum * SOAP_FMAC2 soap_instantiate___ns1__BlindKeyNum(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__BlindKeyNum(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__BlindKeyNum *p;
	size_t k = sizeof(struct __ns1__BlindKeyNum);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__BlindKeyNum, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__BlindKeyNum);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__BlindKeyNum, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__BlindKeyNum location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__BlindKeyNum(struct soap *soap, const struct __ns1__BlindKeyNum *a, const char *tag, const char *type)
{
	if (soap_out___ns1__BlindKeyNum(soap, tag ? tag : "-ns1:BlindKeyNum", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BlindKeyNum * SOAP_FMAC4 soap_get___ns1__BlindKeyNum(struct soap *soap, struct __ns1__BlindKeyNum *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__BlindKeyNum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetSparrowCheckData(struct soap *soap, struct __ns1__GetSparrowCheckData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetSparrowCheckData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetSparrowCheckData(struct soap *soap, const struct __ns1__GetSparrowCheckData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetSparrowCheckData(soap, &a->ns1__GetSparrowCheckData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetSparrowCheckData(struct soap *soap, const char *tag, int id, const struct __ns1__GetSparrowCheckData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetSparrowCheckData(soap, "ns1:GetSparrowCheckData", -1, &a->ns1__GetSparrowCheckData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetSparrowCheckData * SOAP_FMAC4 soap_in___ns1__GetSparrowCheckData(struct soap *soap, const char *tag, struct __ns1__GetSparrowCheckData *a, const char *type)
{
	size_t soap_flag_ns1__GetSparrowCheckData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetSparrowCheckData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetSparrowCheckData, sizeof(struct __ns1__GetSparrowCheckData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetSparrowCheckData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetSparrowCheckData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetSparrowCheckData(soap, "ns1:GetSparrowCheckData", &a->ns1__GetSparrowCheckData, ""))
				{	soap_flag_ns1__GetSparrowCheckData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetSparrowCheckData * SOAP_FMAC2 soap_instantiate___ns1__GetSparrowCheckData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetSparrowCheckData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetSparrowCheckData *p;
	size_t k = sizeof(struct __ns1__GetSparrowCheckData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetSparrowCheckData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetSparrowCheckData);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetSparrowCheckData, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetSparrowCheckData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetSparrowCheckData(struct soap *soap, const struct __ns1__GetSparrowCheckData *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetSparrowCheckData(soap, tag ? tag : "-ns1:GetSparrowCheckData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetSparrowCheckData * SOAP_FMAC4 soap_get___ns1__GetSparrowCheckData(struct soap *soap, struct __ns1__GetSparrowCheckData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetSparrowCheckData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__BindKey(struct soap *soap, struct __ns1__BindKey *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__BindKey = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__BindKey(struct soap *soap, const struct __ns1__BindKey *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__BindKey(soap, &a->ns1__BindKey);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__BindKey(struct soap *soap, const char *tag, int id, const struct __ns1__BindKey *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__BindKey(soap, "ns1:BindKey", -1, &a->ns1__BindKey, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BindKey * SOAP_FMAC4 soap_in___ns1__BindKey(struct soap *soap, const char *tag, struct __ns1__BindKey *a, const char *type)
{
	size_t soap_flag_ns1__BindKey = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__BindKey *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__BindKey, sizeof(struct __ns1__BindKey), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__BindKey(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__BindKey && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__BindKey(soap, "ns1:BindKey", &a->ns1__BindKey, ""))
				{	soap_flag_ns1__BindKey--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__BindKey * SOAP_FMAC2 soap_instantiate___ns1__BindKey(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__BindKey(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__BindKey *p;
	size_t k = sizeof(struct __ns1__BindKey);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__BindKey, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__BindKey);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__BindKey, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__BindKey location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__BindKey(struct soap *soap, const struct __ns1__BindKey *a, const char *tag, const char *type)
{
	if (soap_out___ns1__BindKey(soap, tag ? tag : "-ns1:BindKey", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BindKey * SOAP_FMAC4 soap_get___ns1__BindKey(struct soap *soap, struct __ns1__BindKey *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__BindKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ReleaseKey(struct soap *soap, struct __ns1__ReleaseKey *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ReleaseKey = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ReleaseKey(struct soap *soap, const struct __ns1__ReleaseKey *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ReleaseKey(soap, &a->ns1__ReleaseKey);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ReleaseKey(struct soap *soap, const char *tag, int id, const struct __ns1__ReleaseKey *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ReleaseKey(soap, "ns1:ReleaseKey", -1, &a->ns1__ReleaseKey, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ReleaseKey * SOAP_FMAC4 soap_in___ns1__ReleaseKey(struct soap *soap, const char *tag, struct __ns1__ReleaseKey *a, const char *type)
{
	size_t soap_flag_ns1__ReleaseKey = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ReleaseKey *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ReleaseKey, sizeof(struct __ns1__ReleaseKey), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ReleaseKey(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ReleaseKey && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ReleaseKey(soap, "ns1:ReleaseKey", &a->ns1__ReleaseKey, ""))
				{	soap_flag_ns1__ReleaseKey--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ReleaseKey * SOAP_FMAC2 soap_instantiate___ns1__ReleaseKey(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ReleaseKey(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ReleaseKey *p;
	size_t k = sizeof(struct __ns1__ReleaseKey);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__ReleaseKey, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__ReleaseKey);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__ReleaseKey, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ReleaseKey location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ReleaseKey(struct soap *soap, const struct __ns1__ReleaseKey *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ReleaseKey(soap, tag ? tag : "-ns1:ReleaseKey", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ReleaseKey * SOAP_FMAC4 soap_get___ns1__ReleaseKey(struct soap *soap, struct __ns1__ReleaseKey *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ReleaseKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetShaoluKey(struct soap *soap, struct __ns1__GetShaoluKey *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetShaoluKey = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetShaoluKey(struct soap *soap, const struct __ns1__GetShaoluKey *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetShaoluKey(soap, &a->ns1__GetShaoluKey);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetShaoluKey(struct soap *soap, const char *tag, int id, const struct __ns1__GetShaoluKey *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetShaoluKey(soap, "ns1:GetShaoluKey", -1, &a->ns1__GetShaoluKey, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetShaoluKey * SOAP_FMAC4 soap_in___ns1__GetShaoluKey(struct soap *soap, const char *tag, struct __ns1__GetShaoluKey *a, const char *type)
{
	size_t soap_flag_ns1__GetShaoluKey = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetShaoluKey *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetShaoluKey, sizeof(struct __ns1__GetShaoluKey), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetShaoluKey(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetShaoluKey && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetShaoluKey(soap, "ns1:GetShaoluKey", &a->ns1__GetShaoluKey, ""))
				{	soap_flag_ns1__GetShaoluKey--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetShaoluKey * SOAP_FMAC2 soap_instantiate___ns1__GetShaoluKey(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetShaoluKey(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetShaoluKey *p;
	size_t k = sizeof(struct __ns1__GetShaoluKey);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetShaoluKey, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetShaoluKey);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetShaoluKey, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetShaoluKey location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetShaoluKey(struct soap *soap, const struct __ns1__GetShaoluKey *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetShaoluKey(soap, tag ? tag : "-ns1:GetShaoluKey", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetShaoluKey * SOAP_FMAC4 soap_get___ns1__GetShaoluKey(struct soap *soap, struct __ns1__GetShaoluKey *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetShaoluKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__PCBData_USCOREUpload(struct soap *soap, struct __ns1__PCBData_USCOREUpload *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__PCBData_USCOREUpload = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__PCBData_USCOREUpload(struct soap *soap, const struct __ns1__PCBData_USCOREUpload *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__PCBData_USCOREUpload(soap, &a->ns1__PCBData_USCOREUpload);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__PCBData_USCOREUpload(struct soap *soap, const char *tag, int id, const struct __ns1__PCBData_USCOREUpload *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__PCBData_USCOREUpload(soap, "ns1:PCBData_Upload", -1, &a->ns1__PCBData_USCOREUpload, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__PCBData_USCOREUpload * SOAP_FMAC4 soap_in___ns1__PCBData_USCOREUpload(struct soap *soap, const char *tag, struct __ns1__PCBData_USCOREUpload *a, const char *type)
{
	size_t soap_flag_ns1__PCBData_USCOREUpload = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__PCBData_USCOREUpload *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__PCBData_USCOREUpload, sizeof(struct __ns1__PCBData_USCOREUpload), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__PCBData_USCOREUpload(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__PCBData_USCOREUpload && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__PCBData_USCOREUpload(soap, "ns1:PCBData_Upload", &a->ns1__PCBData_USCOREUpload, ""))
				{	soap_flag_ns1__PCBData_USCOREUpload--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__PCBData_USCOREUpload * SOAP_FMAC2 soap_instantiate___ns1__PCBData_USCOREUpload(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__PCBData_USCOREUpload(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__PCBData_USCOREUpload *p;
	size_t k = sizeof(struct __ns1__PCBData_USCOREUpload);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__PCBData_USCOREUpload, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__PCBData_USCOREUpload);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__PCBData_USCOREUpload, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__PCBData_USCOREUpload location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__PCBData_USCOREUpload(struct soap *soap, const struct __ns1__PCBData_USCOREUpload *a, const char *tag, const char *type)
{
	if (soap_out___ns1__PCBData_USCOREUpload(soap, tag ? tag : "-ns1:PCBData_Upload", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__PCBData_USCOREUpload * SOAP_FMAC4 soap_get___ns1__PCBData_USCOREUpload(struct soap *soap, struct __ns1__PCBData_USCOREUpload *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__PCBData_USCOREUpload(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CartonWeight_USCOREUpload(struct soap *soap, struct __ns1__CartonWeight_USCOREUpload *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CartonWeight_USCOREUpload = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CartonWeight_USCOREUpload(struct soap *soap, const struct __ns1__CartonWeight_USCOREUpload *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CartonWeight_USCOREUpload(soap, &a->ns1__CartonWeight_USCOREUpload);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CartonWeight_USCOREUpload(struct soap *soap, const char *tag, int id, const struct __ns1__CartonWeight_USCOREUpload *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CartonWeight_USCOREUpload(soap, "ns1:CartonWeight_Upload", -1, &a->ns1__CartonWeight_USCOREUpload, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CartonWeight_USCOREUpload * SOAP_FMAC4 soap_in___ns1__CartonWeight_USCOREUpload(struct soap *soap, const char *tag, struct __ns1__CartonWeight_USCOREUpload *a, const char *type)
{
	size_t soap_flag_ns1__CartonWeight_USCOREUpload = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CartonWeight_USCOREUpload *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CartonWeight_USCOREUpload, sizeof(struct __ns1__CartonWeight_USCOREUpload), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CartonWeight_USCOREUpload(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CartonWeight_USCOREUpload && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__CartonWeight_USCOREUpload(soap, "ns1:CartonWeight_Upload", &a->ns1__CartonWeight_USCOREUpload, ""))
				{	soap_flag_ns1__CartonWeight_USCOREUpload--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CartonWeight_USCOREUpload * SOAP_FMAC2 soap_instantiate___ns1__CartonWeight_USCOREUpload(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CartonWeight_USCOREUpload(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CartonWeight_USCOREUpload *p;
	size_t k = sizeof(struct __ns1__CartonWeight_USCOREUpload);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__CartonWeight_USCOREUpload, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__CartonWeight_USCOREUpload);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__CartonWeight_USCOREUpload, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CartonWeight_USCOREUpload location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CartonWeight_USCOREUpload(struct soap *soap, const struct __ns1__CartonWeight_USCOREUpload *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CartonWeight_USCOREUpload(soap, tag ? tag : "-ns1:CartonWeight_Upload", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CartonWeight_USCOREUpload * SOAP_FMAC4 soap_get___ns1__CartonWeight_USCOREUpload(struct soap *soap, struct __ns1__CartonWeight_USCOREUpload *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CartonWeight_USCOREUpload(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetMacBySn(struct soap *soap, struct __ns1__GetMacBySn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetMacBySn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetMacBySn(struct soap *soap, const struct __ns1__GetMacBySn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetMacBySn(soap, &a->ns1__GetMacBySn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetMacBySn(struct soap *soap, const char *tag, int id, const struct __ns1__GetMacBySn *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetMacBySn(soap, "ns1:GetMacBySn", -1, &a->ns1__GetMacBySn, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMacBySn * SOAP_FMAC4 soap_in___ns1__GetMacBySn(struct soap *soap, const char *tag, struct __ns1__GetMacBySn *a, const char *type)
{
	size_t soap_flag_ns1__GetMacBySn = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetMacBySn *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetMacBySn, sizeof(struct __ns1__GetMacBySn), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetMacBySn(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetMacBySn && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetMacBySn(soap, "ns1:GetMacBySn", &a->ns1__GetMacBySn, ""))
				{	soap_flag_ns1__GetMacBySn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetMacBySn * SOAP_FMAC2 soap_instantiate___ns1__GetMacBySn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetMacBySn(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetMacBySn *p;
	size_t k = sizeof(struct __ns1__GetMacBySn);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetMacBySn, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetMacBySn);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetMacBySn, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetMacBySn location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetMacBySn(struct soap *soap, const struct __ns1__GetMacBySn *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetMacBySn(soap, tag ? tag : "-ns1:GetMacBySn", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMacBySn * SOAP_FMAC4 soap_get___ns1__GetMacBySn(struct soap *soap, struct __ns1__GetMacBySn *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetMacBySn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GETMACID(struct soap *soap, struct __ns1__GETMACID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GETMACID = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GETMACID(struct soap *soap, const struct __ns1__GETMACID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GETMACID(soap, &a->ns1__GETMACID);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GETMACID(struct soap *soap, const char *tag, int id, const struct __ns1__GETMACID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GETMACID(soap, "ns1:GETMACID", -1, &a->ns1__GETMACID, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GETMACID * SOAP_FMAC4 soap_in___ns1__GETMACID(struct soap *soap, const char *tag, struct __ns1__GETMACID *a, const char *type)
{
	size_t soap_flag_ns1__GETMACID = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GETMACID *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GETMACID, sizeof(struct __ns1__GETMACID), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GETMACID(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GETMACID && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GETMACID(soap, "ns1:GETMACID", &a->ns1__GETMACID, ""))
				{	soap_flag_ns1__GETMACID--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GETMACID * SOAP_FMAC2 soap_instantiate___ns1__GETMACID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GETMACID(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GETMACID *p;
	size_t k = sizeof(struct __ns1__GETMACID);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GETMACID, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GETMACID);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GETMACID, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GETMACID location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GETMACID(struct soap *soap, const struct __ns1__GETMACID *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GETMACID(soap, tag ? tag : "-ns1:GETMACID", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GETMACID * SOAP_FMAC4 soap_get___ns1__GETMACID(struct soap *soap, struct __ns1__GETMACID *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GETMACID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__test(struct soap *soap, struct __ns1__test *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__test = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__test(struct soap *soap, const struct __ns1__test *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__test(soap, &a->ns1__test);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__test(struct soap *soap, const char *tag, int id, const struct __ns1__test *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__test(soap, "ns1:test", -1, &a->ns1__test, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__test * SOAP_FMAC4 soap_in___ns1__test(struct soap *soap, const char *tag, struct __ns1__test *a, const char *type)
{
	size_t soap_flag_ns1__test = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__test *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__test, sizeof(struct __ns1__test), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__test(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__test && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__test(soap, "ns1:test", &a->ns1__test, ""))
				{	soap_flag_ns1__test--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__test * SOAP_FMAC2 soap_instantiate___ns1__test(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__test(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__test *p;
	size_t k = sizeof(struct __ns1__test);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__test, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__test);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__test, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__test location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__test(struct soap *soap, const struct __ns1__test *a, const char *tag, const char *type)
{
	if (soap_out___ns1__test(soap, tag ? tag : "-ns1:test", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__test * SOAP_FMAC4 soap_get___ns1__test(struct soap *soap, struct __ns1__test *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__test(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SaveSSN_USCORENEW(struct soap *soap, struct __ns1__SaveSSN_USCORENEW *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SaveSSN_USCORENEW = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SaveSSN_USCORENEW(struct soap *soap, const struct __ns1__SaveSSN_USCORENEW *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SaveSSN_USCORENEW(soap, &a->ns1__SaveSSN_USCORENEW);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SaveSSN_USCORENEW(struct soap *soap, const char *tag, int id, const struct __ns1__SaveSSN_USCORENEW *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SaveSSN_USCORENEW(soap, "ns1:SaveSSN_NEW", -1, &a->ns1__SaveSSN_USCORENEW, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SaveSSN_USCORENEW * SOAP_FMAC4 soap_in___ns1__SaveSSN_USCORENEW(struct soap *soap, const char *tag, struct __ns1__SaveSSN_USCORENEW *a, const char *type)
{
	size_t soap_flag_ns1__SaveSSN_USCORENEW = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SaveSSN_USCORENEW *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SaveSSN_USCORENEW, sizeof(struct __ns1__SaveSSN_USCORENEW), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SaveSSN_USCORENEW(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SaveSSN_USCORENEW && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SaveSSN_USCORENEW(soap, "ns1:SaveSSN_NEW", &a->ns1__SaveSSN_USCORENEW, ""))
				{	soap_flag_ns1__SaveSSN_USCORENEW--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SaveSSN_USCORENEW * SOAP_FMAC2 soap_instantiate___ns1__SaveSSN_USCORENEW(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SaveSSN_USCORENEW(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SaveSSN_USCORENEW *p;
	size_t k = sizeof(struct __ns1__SaveSSN_USCORENEW);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__SaveSSN_USCORENEW, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__SaveSSN_USCORENEW);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__SaveSSN_USCORENEW, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SaveSSN_USCORENEW location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SaveSSN_USCORENEW(struct soap *soap, const struct __ns1__SaveSSN_USCORENEW *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SaveSSN_USCORENEW(soap, tag ? tag : "-ns1:SaveSSN_NEW", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SaveSSN_USCORENEW * SOAP_FMAC4 soap_get___ns1__SaveSSN_USCORENEW(struct soap *soap, struct __ns1__SaveSSN_USCORENEW *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SaveSSN_USCORENEW(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SfcTestResult_USCOREUpload(struct soap *soap, struct __ns1__SfcTestResult_USCOREUpload *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SfcTestResult_USCOREUpload = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SfcTestResult_USCOREUpload(struct soap *soap, const struct __ns1__SfcTestResult_USCOREUpload *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SfcTestResult_USCOREUpload(soap, &a->ns1__SfcTestResult_USCOREUpload);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SfcTestResult_USCOREUpload(struct soap *soap, const char *tag, int id, const struct __ns1__SfcTestResult_USCOREUpload *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SfcTestResult_USCOREUpload(soap, "ns1:SfcTestResult_Upload", -1, &a->ns1__SfcTestResult_USCOREUpload, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SfcTestResult_USCOREUpload * SOAP_FMAC4 soap_in___ns1__SfcTestResult_USCOREUpload(struct soap *soap, const char *tag, struct __ns1__SfcTestResult_USCOREUpload *a, const char *type)
{
	size_t soap_flag_ns1__SfcTestResult_USCOREUpload = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SfcTestResult_USCOREUpload *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SfcTestResult_USCOREUpload, sizeof(struct __ns1__SfcTestResult_USCOREUpload), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SfcTestResult_USCOREUpload(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SfcTestResult_USCOREUpload && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SfcTestResult_USCOREUpload(soap, "ns1:SfcTestResult_Upload", &a->ns1__SfcTestResult_USCOREUpload, ""))
				{	soap_flag_ns1__SfcTestResult_USCOREUpload--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SfcTestResult_USCOREUpload * SOAP_FMAC2 soap_instantiate___ns1__SfcTestResult_USCOREUpload(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SfcTestResult_USCOREUpload(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SfcTestResult_USCOREUpload *p;
	size_t k = sizeof(struct __ns1__SfcTestResult_USCOREUpload);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__SfcTestResult_USCOREUpload, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__SfcTestResult_USCOREUpload);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__SfcTestResult_USCOREUpload, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SfcTestResult_USCOREUpload location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SfcTestResult_USCOREUpload(struct soap *soap, const struct __ns1__SfcTestResult_USCOREUpload *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SfcTestResult_USCOREUpload(soap, tag ? tag : "-ns1:SfcTestResult_Upload", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SfcTestResult_USCOREUpload * SOAP_FMAC4 soap_get___ns1__SfcTestResult_USCOREUpload(struct soap *soap, struct __ns1__SfcTestResult_USCOREUpload *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SfcTestResult_USCOREUpload(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__QueryBinding(struct soap *soap, struct __ns1__QueryBinding *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__QueryBinding = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__QueryBinding(struct soap *soap, const struct __ns1__QueryBinding *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__QueryBinding(soap, &a->ns1__QueryBinding);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__QueryBinding(struct soap *soap, const char *tag, int id, const struct __ns1__QueryBinding *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__QueryBinding(soap, "ns1:QueryBinding", -1, &a->ns1__QueryBinding, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QueryBinding * SOAP_FMAC4 soap_in___ns1__QueryBinding(struct soap *soap, const char *tag, struct __ns1__QueryBinding *a, const char *type)
{
	size_t soap_flag_ns1__QueryBinding = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__QueryBinding *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__QueryBinding, sizeof(struct __ns1__QueryBinding), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__QueryBinding(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__QueryBinding && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__QueryBinding(soap, "ns1:QueryBinding", &a->ns1__QueryBinding, ""))
				{	soap_flag_ns1__QueryBinding--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__QueryBinding * SOAP_FMAC2 soap_instantiate___ns1__QueryBinding(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__QueryBinding(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__QueryBinding *p;
	size_t k = sizeof(struct __ns1__QueryBinding);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__QueryBinding, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__QueryBinding);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__QueryBinding, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__QueryBinding location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__QueryBinding(struct soap *soap, const struct __ns1__QueryBinding *a, const char *tag, const char *type)
{
	if (soap_out___ns1__QueryBinding(soap, tag ? tag : "-ns1:QueryBinding", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QueryBinding * SOAP_FMAC4 soap_get___ns1__QueryBinding(struct soap *soap, struct __ns1__QueryBinding *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__QueryBinding(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Binding(struct soap *soap, struct __ns1__Binding *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Binding = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Binding(struct soap *soap, const struct __ns1__Binding *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Binding(soap, &a->ns1__Binding);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Binding(struct soap *soap, const char *tag, int id, const struct __ns1__Binding *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Binding(soap, "ns1:Binding", -1, &a->ns1__Binding, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Binding * SOAP_FMAC4 soap_in___ns1__Binding(struct soap *soap, const char *tag, struct __ns1__Binding *a, const char *type)
{
	size_t soap_flag_ns1__Binding = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Binding *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Binding, sizeof(struct __ns1__Binding), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Binding(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Binding && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__Binding(soap, "ns1:Binding", &a->ns1__Binding, ""))
				{	soap_flag_ns1__Binding--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Binding * SOAP_FMAC2 soap_instantiate___ns1__Binding(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Binding(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Binding *p;
	size_t k = sizeof(struct __ns1__Binding);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__Binding, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__Binding);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__Binding, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Binding location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Binding(struct soap *soap, const struct __ns1__Binding *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Binding(soap, tag ? tag : "-ns1:Binding", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Binding * SOAP_FMAC4 soap_get___ns1__Binding(struct soap *soap, struct __ns1__Binding *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Binding(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CheckSSN_USCORENEW(struct soap *soap, struct __ns1__CheckSSN_USCORENEW *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CheckSSN_USCORENEW = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CheckSSN_USCORENEW(struct soap *soap, const struct __ns1__CheckSSN_USCORENEW *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CheckSSN_USCORENEW(soap, &a->ns1__CheckSSN_USCORENEW);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CheckSSN_USCORENEW(struct soap *soap, const char *tag, int id, const struct __ns1__CheckSSN_USCORENEW *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CheckSSN_USCORENEW(soap, "ns1:CheckSSN_NEW", -1, &a->ns1__CheckSSN_USCORENEW, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CheckSSN_USCORENEW * SOAP_FMAC4 soap_in___ns1__CheckSSN_USCORENEW(struct soap *soap, const char *tag, struct __ns1__CheckSSN_USCORENEW *a, const char *type)
{
	size_t soap_flag_ns1__CheckSSN_USCORENEW = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CheckSSN_USCORENEW *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CheckSSN_USCORENEW, sizeof(struct __ns1__CheckSSN_USCORENEW), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CheckSSN_USCORENEW(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CheckSSN_USCORENEW && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__CheckSSN_USCORENEW(soap, "ns1:CheckSSN_NEW", &a->ns1__CheckSSN_USCORENEW, ""))
				{	soap_flag_ns1__CheckSSN_USCORENEW--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CheckSSN_USCORENEW * SOAP_FMAC2 soap_instantiate___ns1__CheckSSN_USCORENEW(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CheckSSN_USCORENEW(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CheckSSN_USCORENEW *p;
	size_t k = sizeof(struct __ns1__CheckSSN_USCORENEW);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__CheckSSN_USCORENEW, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__CheckSSN_USCORENEW);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__CheckSSN_USCORENEW, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CheckSSN_USCORENEW location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CheckSSN_USCORENEW(struct soap *soap, const struct __ns1__CheckSSN_USCORENEW *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CheckSSN_USCORENEW(soap, tag ? tag : "-ns1:CheckSSN_NEW", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CheckSSN_USCORENEW * SOAP_FMAC4 soap_get___ns1__CheckSSN_USCORENEW(struct soap *soap, struct __ns1__CheckSSN_USCORENEW *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CheckSSN_USCORENEW(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CheckSSN(struct soap *soap, struct __ns1__CheckSSN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CheckSSN = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CheckSSN(struct soap *soap, const struct __ns1__CheckSSN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CheckSSN(soap, &a->ns1__CheckSSN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CheckSSN(struct soap *soap, const char *tag, int id, const struct __ns1__CheckSSN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CheckSSN(soap, "ns1:CheckSSN", -1, &a->ns1__CheckSSN, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CheckSSN * SOAP_FMAC4 soap_in___ns1__CheckSSN(struct soap *soap, const char *tag, struct __ns1__CheckSSN *a, const char *type)
{
	size_t soap_flag_ns1__CheckSSN = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CheckSSN *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CheckSSN, sizeof(struct __ns1__CheckSSN), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CheckSSN(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CheckSSN && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__CheckSSN(soap, "ns1:CheckSSN", &a->ns1__CheckSSN, ""))
				{	soap_flag_ns1__CheckSSN--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CheckSSN * SOAP_FMAC2 soap_instantiate___ns1__CheckSSN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CheckSSN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CheckSSN *p;
	size_t k = sizeof(struct __ns1__CheckSSN);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__CheckSSN, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__CheckSSN);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__CheckSSN, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CheckSSN location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CheckSSN(struct soap *soap, const struct __ns1__CheckSSN *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CheckSSN(soap, tag ? tag : "-ns1:CheckSSN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CheckSSN * SOAP_FMAC4 soap_get___ns1__CheckSSN(struct soap *soap, struct __ns1__CheckSSN *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CheckSSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UploadTestResult(struct soap *soap, struct __ns1__UploadTestResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UploadTestResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UploadTestResult(struct soap *soap, const struct __ns1__UploadTestResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__UploadTestResult(soap, &a->ns1__UploadTestResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UploadTestResult(struct soap *soap, const char *tag, int id, const struct __ns1__UploadTestResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__UploadTestResult(soap, "ns1:UploadTestResult", -1, &a->ns1__UploadTestResult, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UploadTestResult * SOAP_FMAC4 soap_in___ns1__UploadTestResult(struct soap *soap, const char *tag, struct __ns1__UploadTestResult *a, const char *type)
{
	size_t soap_flag_ns1__UploadTestResult = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__UploadTestResult *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UploadTestResult, sizeof(struct __ns1__UploadTestResult), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UploadTestResult(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UploadTestResult && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__UploadTestResult(soap, "ns1:UploadTestResult", &a->ns1__UploadTestResult, ""))
				{	soap_flag_ns1__UploadTestResult--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__UploadTestResult * SOAP_FMAC2 soap_instantiate___ns1__UploadTestResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UploadTestResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__UploadTestResult *p;
	size_t k = sizeof(struct __ns1__UploadTestResult);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__UploadTestResult, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__UploadTestResult);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__UploadTestResult, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__UploadTestResult location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UploadTestResult(struct soap *soap, const struct __ns1__UploadTestResult *a, const char *tag, const char *type)
{
	if (soap_out___ns1__UploadTestResult(soap, tag ? tag : "-ns1:UploadTestResult", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UploadTestResult * SOAP_FMAC4 soap_get___ns1__UploadTestResult(struct soap *soap, struct __ns1__UploadTestResult *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UploadTestResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DoFunction(struct soap *soap, struct __ns1__DoFunction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DoFunction = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DoFunction(struct soap *soap, const struct __ns1__DoFunction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__DoFunction(soap, &a->ns1__DoFunction);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DoFunction(struct soap *soap, const char *tag, int id, const struct __ns1__DoFunction *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__DoFunction(soap, "ns1:DoFunction", -1, &a->ns1__DoFunction, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DoFunction * SOAP_FMAC4 soap_in___ns1__DoFunction(struct soap *soap, const char *tag, struct __ns1__DoFunction *a, const char *type)
{
	size_t soap_flag_ns1__DoFunction = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__DoFunction *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__DoFunction, sizeof(struct __ns1__DoFunction), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DoFunction(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DoFunction && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__DoFunction(soap, "ns1:DoFunction", &a->ns1__DoFunction, ""))
				{	soap_flag_ns1__DoFunction--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__DoFunction * SOAP_FMAC2 soap_instantiate___ns1__DoFunction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__DoFunction(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__DoFunction *p;
	size_t k = sizeof(struct __ns1__DoFunction);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__DoFunction, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__DoFunction);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__DoFunction, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__DoFunction location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DoFunction(struct soap *soap, const struct __ns1__DoFunction *a, const char *tag, const char *type)
{
	if (soap_out___ns1__DoFunction(soap, tag ? tag : "-ns1:DoFunction", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DoFunction * SOAP_FMAC4 soap_get___ns1__DoFunction(struct soap *soap, struct __ns1__DoFunction *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DoFunction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__BlindKeyNum(struct soap *soap, _ns1__BlindKeyNum *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__BlindKeyNum))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__BlindKeyNum(struct soap *soap, const char *tag, int id, _ns1__BlindKeyNum *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__BlindKeyNum, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__BlindKeyNum ? type : NULL);
}

SOAP_FMAC3 _ns1__BlindKeyNum ** SOAP_FMAC4 soap_in_PointerTo_ns1__BlindKeyNum(struct soap *soap, const char *tag, _ns1__BlindKeyNum **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__BlindKeyNum **)soap_malloc(soap, sizeof(_ns1__BlindKeyNum *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__BlindKeyNum *)soap_instantiate__ns1__BlindKeyNum(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__BlindKeyNum **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__BlindKeyNum, sizeof(_ns1__BlindKeyNum), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__BlindKeyNum(struct soap *soap, _ns1__BlindKeyNum *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__BlindKeyNum(soap, tag ? tag : "ns1:BlindKeyNum", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__BlindKeyNum ** SOAP_FMAC4 soap_get_PointerTo_ns1__BlindKeyNum(struct soap *soap, _ns1__BlindKeyNum **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__BlindKeyNum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetSparrowCheckData(struct soap *soap, _ns1__GetSparrowCheckData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetSparrowCheckData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetSparrowCheckData(struct soap *soap, const char *tag, int id, _ns1__GetSparrowCheckData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetSparrowCheckData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetSparrowCheckData ? type : NULL);
}

SOAP_FMAC3 _ns1__GetSparrowCheckData ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetSparrowCheckData(struct soap *soap, const char *tag, _ns1__GetSparrowCheckData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetSparrowCheckData **)soap_malloc(soap, sizeof(_ns1__GetSparrowCheckData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetSparrowCheckData *)soap_instantiate__ns1__GetSparrowCheckData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetSparrowCheckData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetSparrowCheckData, sizeof(_ns1__GetSparrowCheckData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetSparrowCheckData(struct soap *soap, _ns1__GetSparrowCheckData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetSparrowCheckData(soap, tag ? tag : "ns1:GetSparrowCheckData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetSparrowCheckData ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetSparrowCheckData(struct soap *soap, _ns1__GetSparrowCheckData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetSparrowCheckData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__BindKey(struct soap *soap, _ns1__BindKey *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__BindKey))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__BindKey(struct soap *soap, const char *tag, int id, _ns1__BindKey *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__BindKey, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__BindKey ? type : NULL);
}

SOAP_FMAC3 _ns1__BindKey ** SOAP_FMAC4 soap_in_PointerTo_ns1__BindKey(struct soap *soap, const char *tag, _ns1__BindKey **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__BindKey **)soap_malloc(soap, sizeof(_ns1__BindKey *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__BindKey *)soap_instantiate__ns1__BindKey(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__BindKey **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__BindKey, sizeof(_ns1__BindKey), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__BindKey(struct soap *soap, _ns1__BindKey *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__BindKey(soap, tag ? tag : "ns1:BindKey", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__BindKey ** SOAP_FMAC4 soap_get_PointerTo_ns1__BindKey(struct soap *soap, _ns1__BindKey **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__BindKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ReleaseKey(struct soap *soap, _ns1__ReleaseKey *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ReleaseKey))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ReleaseKey(struct soap *soap, const char *tag, int id, _ns1__ReleaseKey *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ReleaseKey, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__ReleaseKey ? type : NULL);
}

SOAP_FMAC3 _ns1__ReleaseKey ** SOAP_FMAC4 soap_in_PointerTo_ns1__ReleaseKey(struct soap *soap, const char *tag, _ns1__ReleaseKey **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ReleaseKey **)soap_malloc(soap, sizeof(_ns1__ReleaseKey *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ReleaseKey *)soap_instantiate__ns1__ReleaseKey(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__ReleaseKey **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ReleaseKey, sizeof(_ns1__ReleaseKey), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ReleaseKey(struct soap *soap, _ns1__ReleaseKey *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__ReleaseKey(soap, tag ? tag : "ns1:ReleaseKey", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__ReleaseKey ** SOAP_FMAC4 soap_get_PointerTo_ns1__ReleaseKey(struct soap *soap, _ns1__ReleaseKey **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ReleaseKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetShaoluKey(struct soap *soap, _ns1__GetShaoluKey *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetShaoluKey))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetShaoluKey(struct soap *soap, const char *tag, int id, _ns1__GetShaoluKey *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetShaoluKey, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetShaoluKey ? type : NULL);
}

SOAP_FMAC3 _ns1__GetShaoluKey ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetShaoluKey(struct soap *soap, const char *tag, _ns1__GetShaoluKey **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetShaoluKey **)soap_malloc(soap, sizeof(_ns1__GetShaoluKey *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetShaoluKey *)soap_instantiate__ns1__GetShaoluKey(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetShaoluKey **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetShaoluKey, sizeof(_ns1__GetShaoluKey), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetShaoluKey(struct soap *soap, _ns1__GetShaoluKey *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetShaoluKey(soap, tag ? tag : "ns1:GetShaoluKey", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetShaoluKey ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetShaoluKey(struct soap *soap, _ns1__GetShaoluKey **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetShaoluKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__PCBData_USCOREUpload(struct soap *soap, _ns1__PCBData_USCOREUpload *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__PCBData_USCOREUpload))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__PCBData_USCOREUpload(struct soap *soap, const char *tag, int id, _ns1__PCBData_USCOREUpload *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__PCBData_USCOREUpload, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__PCBData_USCOREUpload ? type : NULL);
}

SOAP_FMAC3 _ns1__PCBData_USCOREUpload ** SOAP_FMAC4 soap_in_PointerTo_ns1__PCBData_USCOREUpload(struct soap *soap, const char *tag, _ns1__PCBData_USCOREUpload **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__PCBData_USCOREUpload **)soap_malloc(soap, sizeof(_ns1__PCBData_USCOREUpload *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__PCBData_USCOREUpload *)soap_instantiate__ns1__PCBData_USCOREUpload(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__PCBData_USCOREUpload **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__PCBData_USCOREUpload, sizeof(_ns1__PCBData_USCOREUpload), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__PCBData_USCOREUpload(struct soap *soap, _ns1__PCBData_USCOREUpload *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__PCBData_USCOREUpload(soap, tag ? tag : "ns1:PCBData_Upload", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__PCBData_USCOREUpload ** SOAP_FMAC4 soap_get_PointerTo_ns1__PCBData_USCOREUpload(struct soap *soap, _ns1__PCBData_USCOREUpload **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__PCBData_USCOREUpload(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CartonWeight_USCOREUpload(struct soap *soap, _ns1__CartonWeight_USCOREUpload *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CartonWeight_USCOREUpload))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CartonWeight_USCOREUpload(struct soap *soap, const char *tag, int id, _ns1__CartonWeight_USCOREUpload *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CartonWeight_USCOREUpload, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__CartonWeight_USCOREUpload ? type : NULL);
}

SOAP_FMAC3 _ns1__CartonWeight_USCOREUpload ** SOAP_FMAC4 soap_in_PointerTo_ns1__CartonWeight_USCOREUpload(struct soap *soap, const char *tag, _ns1__CartonWeight_USCOREUpload **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CartonWeight_USCOREUpload **)soap_malloc(soap, sizeof(_ns1__CartonWeight_USCOREUpload *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CartonWeight_USCOREUpload *)soap_instantiate__ns1__CartonWeight_USCOREUpload(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__CartonWeight_USCOREUpload **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CartonWeight_USCOREUpload, sizeof(_ns1__CartonWeight_USCOREUpload), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CartonWeight_USCOREUpload(struct soap *soap, _ns1__CartonWeight_USCOREUpload *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__CartonWeight_USCOREUpload(soap, tag ? tag : "ns1:CartonWeight_Upload", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__CartonWeight_USCOREUpload ** SOAP_FMAC4 soap_get_PointerTo_ns1__CartonWeight_USCOREUpload(struct soap *soap, _ns1__CartonWeight_USCOREUpload **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CartonWeight_USCOREUpload(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetMacBySn(struct soap *soap, _ns1__GetMacBySn *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetMacBySn))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetMacBySn(struct soap *soap, const char *tag, int id, _ns1__GetMacBySn *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetMacBySn, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetMacBySn ? type : NULL);
}

SOAP_FMAC3 _ns1__GetMacBySn ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetMacBySn(struct soap *soap, const char *tag, _ns1__GetMacBySn **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetMacBySn **)soap_malloc(soap, sizeof(_ns1__GetMacBySn *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetMacBySn *)soap_instantiate__ns1__GetMacBySn(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetMacBySn **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetMacBySn, sizeof(_ns1__GetMacBySn), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetMacBySn(struct soap *soap, _ns1__GetMacBySn *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetMacBySn(soap, tag ? tag : "ns1:GetMacBySn", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetMacBySn ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetMacBySn(struct soap *soap, _ns1__GetMacBySn **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetMacBySn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GETMACID(struct soap *soap, _ns1__GETMACID *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GETMACID))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GETMACID(struct soap *soap, const char *tag, int id, _ns1__GETMACID *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GETMACID, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GETMACID ? type : NULL);
}

SOAP_FMAC3 _ns1__GETMACID ** SOAP_FMAC4 soap_in_PointerTo_ns1__GETMACID(struct soap *soap, const char *tag, _ns1__GETMACID **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GETMACID **)soap_malloc(soap, sizeof(_ns1__GETMACID *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GETMACID *)soap_instantiate__ns1__GETMACID(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GETMACID **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GETMACID, sizeof(_ns1__GETMACID), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GETMACID(struct soap *soap, _ns1__GETMACID *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GETMACID(soap, tag ? tag : "ns1:GETMACID", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GETMACID ** SOAP_FMAC4 soap_get_PointerTo_ns1__GETMACID(struct soap *soap, _ns1__GETMACID **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GETMACID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__test(struct soap *soap, _ns1__test *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__test))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__test(struct soap *soap, const char *tag, int id, _ns1__test *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__test, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__test ? type : NULL);
}

SOAP_FMAC3 _ns1__test ** SOAP_FMAC4 soap_in_PointerTo_ns1__test(struct soap *soap, const char *tag, _ns1__test **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__test **)soap_malloc(soap, sizeof(_ns1__test *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__test *)soap_instantiate__ns1__test(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__test **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__test, sizeof(_ns1__test), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__test(struct soap *soap, _ns1__test *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__test(soap, tag ? tag : "ns1:test", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__test ** SOAP_FMAC4 soap_get_PointerTo_ns1__test(struct soap *soap, _ns1__test **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__test(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SaveSSN_USCORENEW(struct soap *soap, _ns1__SaveSSN_USCORENEW *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SaveSSN_USCORENEW))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SaveSSN_USCORENEW(struct soap *soap, const char *tag, int id, _ns1__SaveSSN_USCORENEW *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SaveSSN_USCORENEW, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__SaveSSN_USCORENEW ? type : NULL);
}

SOAP_FMAC3 _ns1__SaveSSN_USCORENEW ** SOAP_FMAC4 soap_in_PointerTo_ns1__SaveSSN_USCORENEW(struct soap *soap, const char *tag, _ns1__SaveSSN_USCORENEW **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SaveSSN_USCORENEW **)soap_malloc(soap, sizeof(_ns1__SaveSSN_USCORENEW *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SaveSSN_USCORENEW *)soap_instantiate__ns1__SaveSSN_USCORENEW(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SaveSSN_USCORENEW **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SaveSSN_USCORENEW, sizeof(_ns1__SaveSSN_USCORENEW), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SaveSSN_USCORENEW(struct soap *soap, _ns1__SaveSSN_USCORENEW *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SaveSSN_USCORENEW(soap, tag ? tag : "ns1:SaveSSN_NEW", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SaveSSN_USCORENEW ** SOAP_FMAC4 soap_get_PointerTo_ns1__SaveSSN_USCORENEW(struct soap *soap, _ns1__SaveSSN_USCORENEW **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SaveSSN_USCORENEW(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SfcTestResult_USCOREUpload(struct soap *soap, _ns1__SfcTestResult_USCOREUpload *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SfcTestResult_USCOREUpload))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SfcTestResult_USCOREUpload(struct soap *soap, const char *tag, int id, _ns1__SfcTestResult_USCOREUpload *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SfcTestResult_USCOREUpload, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__SfcTestResult_USCOREUpload ? type : NULL);
}

SOAP_FMAC3 _ns1__SfcTestResult_USCOREUpload ** SOAP_FMAC4 soap_in_PointerTo_ns1__SfcTestResult_USCOREUpload(struct soap *soap, const char *tag, _ns1__SfcTestResult_USCOREUpload **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SfcTestResult_USCOREUpload **)soap_malloc(soap, sizeof(_ns1__SfcTestResult_USCOREUpload *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SfcTestResult_USCOREUpload *)soap_instantiate__ns1__SfcTestResult_USCOREUpload(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SfcTestResult_USCOREUpload **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SfcTestResult_USCOREUpload, sizeof(_ns1__SfcTestResult_USCOREUpload), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SfcTestResult_USCOREUpload(struct soap *soap, _ns1__SfcTestResult_USCOREUpload *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SfcTestResult_USCOREUpload(soap, tag ? tag : "ns1:SfcTestResult_Upload", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SfcTestResult_USCOREUpload ** SOAP_FMAC4 soap_get_PointerTo_ns1__SfcTestResult_USCOREUpload(struct soap *soap, _ns1__SfcTestResult_USCOREUpload **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SfcTestResult_USCOREUpload(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__QueryBinding(struct soap *soap, _ns1__QueryBinding *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__QueryBinding))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__QueryBinding(struct soap *soap, const char *tag, int id, _ns1__QueryBinding *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__QueryBinding, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__QueryBinding ? type : NULL);
}

SOAP_FMAC3 _ns1__QueryBinding ** SOAP_FMAC4 soap_in_PointerTo_ns1__QueryBinding(struct soap *soap, const char *tag, _ns1__QueryBinding **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__QueryBinding **)soap_malloc(soap, sizeof(_ns1__QueryBinding *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__QueryBinding *)soap_instantiate__ns1__QueryBinding(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__QueryBinding **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__QueryBinding, sizeof(_ns1__QueryBinding), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__QueryBinding(struct soap *soap, _ns1__QueryBinding *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__QueryBinding(soap, tag ? tag : "ns1:QueryBinding", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__QueryBinding ** SOAP_FMAC4 soap_get_PointerTo_ns1__QueryBinding(struct soap *soap, _ns1__QueryBinding **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__QueryBinding(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__Binding(struct soap *soap, _ns1__Binding *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__Binding))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__Binding(struct soap *soap, const char *tag, int id, _ns1__Binding *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__Binding, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__Binding ? type : NULL);
}

SOAP_FMAC3 _ns1__Binding ** SOAP_FMAC4 soap_in_PointerTo_ns1__Binding(struct soap *soap, const char *tag, _ns1__Binding **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__Binding **)soap_malloc(soap, sizeof(_ns1__Binding *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__Binding *)soap_instantiate__ns1__Binding(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__Binding **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__Binding, sizeof(_ns1__Binding), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__Binding(struct soap *soap, _ns1__Binding *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__Binding(soap, tag ? tag : "ns1:Binding", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__Binding ** SOAP_FMAC4 soap_get_PointerTo_ns1__Binding(struct soap *soap, _ns1__Binding **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__Binding(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CheckSSN_USCORENEW(struct soap *soap, _ns1__CheckSSN_USCORENEW *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CheckSSN_USCORENEW))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CheckSSN_USCORENEW(struct soap *soap, const char *tag, int id, _ns1__CheckSSN_USCORENEW *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CheckSSN_USCORENEW, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__CheckSSN_USCORENEW ? type : NULL);
}

SOAP_FMAC3 _ns1__CheckSSN_USCORENEW ** SOAP_FMAC4 soap_in_PointerTo_ns1__CheckSSN_USCORENEW(struct soap *soap, const char *tag, _ns1__CheckSSN_USCORENEW **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CheckSSN_USCORENEW **)soap_malloc(soap, sizeof(_ns1__CheckSSN_USCORENEW *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CheckSSN_USCORENEW *)soap_instantiate__ns1__CheckSSN_USCORENEW(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__CheckSSN_USCORENEW **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CheckSSN_USCORENEW, sizeof(_ns1__CheckSSN_USCORENEW), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CheckSSN_USCORENEW(struct soap *soap, _ns1__CheckSSN_USCORENEW *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__CheckSSN_USCORENEW(soap, tag ? tag : "ns1:CheckSSN_NEW", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__CheckSSN_USCORENEW ** SOAP_FMAC4 soap_get_PointerTo_ns1__CheckSSN_USCORENEW(struct soap *soap, _ns1__CheckSSN_USCORENEW **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CheckSSN_USCORENEW(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CheckSSN(struct soap *soap, _ns1__CheckSSN *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CheckSSN))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CheckSSN(struct soap *soap, const char *tag, int id, _ns1__CheckSSN *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CheckSSN, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__CheckSSN ? type : NULL);
}

SOAP_FMAC3 _ns1__CheckSSN ** SOAP_FMAC4 soap_in_PointerTo_ns1__CheckSSN(struct soap *soap, const char *tag, _ns1__CheckSSN **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CheckSSN **)soap_malloc(soap, sizeof(_ns1__CheckSSN *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CheckSSN *)soap_instantiate__ns1__CheckSSN(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__CheckSSN **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CheckSSN, sizeof(_ns1__CheckSSN), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CheckSSN(struct soap *soap, _ns1__CheckSSN *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__CheckSSN(soap, tag ? tag : "ns1:CheckSSN", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__CheckSSN ** SOAP_FMAC4 soap_get_PointerTo_ns1__CheckSSN(struct soap *soap, _ns1__CheckSSN **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CheckSSN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UploadTestResult(struct soap *soap, _ns1__UploadTestResult *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UploadTestResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UploadTestResult(struct soap *soap, const char *tag, int id, _ns1__UploadTestResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UploadTestResult, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__UploadTestResult ? type : NULL);
}

SOAP_FMAC3 _ns1__UploadTestResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__UploadTestResult(struct soap *soap, const char *tag, _ns1__UploadTestResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UploadTestResult **)soap_malloc(soap, sizeof(_ns1__UploadTestResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UploadTestResult *)soap_instantiate__ns1__UploadTestResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__UploadTestResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UploadTestResult, sizeof(_ns1__UploadTestResult), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UploadTestResult(struct soap *soap, _ns1__UploadTestResult *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__UploadTestResult(soap, tag ? tag : "ns1:UploadTestResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UploadTestResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__UploadTestResult(struct soap *soap, _ns1__UploadTestResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UploadTestResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DoFunction(struct soap *soap, _ns1__DoFunction *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__DoFunction))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DoFunction(struct soap *soap, const char *tag, int id, _ns1__DoFunction *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__DoFunction, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__DoFunction ? type : NULL);
}

SOAP_FMAC3 _ns1__DoFunction ** SOAP_FMAC4 soap_in_PointerTo_ns1__DoFunction(struct soap *soap, const char *tag, _ns1__DoFunction **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__DoFunction **)soap_malloc(soap, sizeof(_ns1__DoFunction *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__DoFunction *)soap_instantiate__ns1__DoFunction(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__DoFunction **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DoFunction, sizeof(_ns1__DoFunction), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DoFunction(struct soap *soap, _ns1__DoFunction *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__DoFunction(soap, tag ? tag : "ns1:DoFunction", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__DoFunction ** SOAP_FMAC4 soap_get_PointerTo_ns1__DoFunction(struct soap *soap, _ns1__DoFunction **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DoFunction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GETMACIDResponse_GETMACIDResult(struct soap *soap, _ns1__GETMACIDResponse_GETMACIDResult *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GETMACIDResponse_GETMACIDResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GETMACIDResponse_GETMACIDResult(struct soap *soap, const char *tag, int id, _ns1__GETMACIDResponse_GETMACIDResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GETMACIDResponse_GETMACIDResult, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GETMACIDResponse_GETMACIDResult ? type : NULL);
}

SOAP_FMAC3 _ns1__GETMACIDResponse_GETMACIDResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__GETMACIDResponse_GETMACIDResult(struct soap *soap, const char *tag, _ns1__GETMACIDResponse_GETMACIDResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GETMACIDResponse_GETMACIDResult **)soap_malloc(soap, sizeof(_ns1__GETMACIDResponse_GETMACIDResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GETMACIDResponse_GETMACIDResult *)soap_instantiate__ns1__GETMACIDResponse_GETMACIDResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GETMACIDResponse_GETMACIDResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GETMACIDResponse_GETMACIDResult, sizeof(_ns1__GETMACIDResponse_GETMACIDResult), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GETMACIDResponse_GETMACIDResult(struct soap *soap, _ns1__GETMACIDResponse_GETMACIDResult *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GETMACIDResponse_GETMACIDResult(soap, tag ? tag : "ns1:GETMACIDResponse-GETMACIDResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GETMACIDResponse_GETMACIDResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__GETMACIDResponse_GETMACIDResult(struct soap *soap, _ns1__GETMACIDResponse_GETMACIDResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GETMACIDResponse_GETMACIDResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfAnyType(struct soap *soap, ns1__ArrayOfAnyType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfAnyType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfAnyType(struct soap *soap, const char *tag, int id, ns1__ArrayOfAnyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfAnyType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ArrayOfAnyType ? type : NULL);
}

SOAP_FMAC3 ns1__ArrayOfAnyType ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfAnyType(struct soap *soap, const char *tag, ns1__ArrayOfAnyType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfAnyType **)soap_malloc(soap, sizeof(ns1__ArrayOfAnyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfAnyType *)soap_instantiate_ns1__ArrayOfAnyType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ArrayOfAnyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfAnyType, sizeof(ns1__ArrayOfAnyType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfAnyType(struct soap *soap, ns1__ArrayOfAnyType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ArrayOfAnyType(soap, tag ? tag : "ns1:ArrayOfAnyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfAnyType ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfAnyType(struct soap *soap, ns1__ArrayOfAnyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfAnyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
